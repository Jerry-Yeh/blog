<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在 Vite 環境使用 React + TypeScript 載入 SVG</title>
      <link href="/react/20230429/52605/"/>
      <url>/react/20230429/52605/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>記錄在 Vite + React + TypeScript 載入 SVG 的方式與環境設定</p><span id="more"></span><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p>[<a href="https://dev.to/cassidoo/importing-svg-files-as-react-components-with-vite-l3n]">https://dev.to/cassidoo/importing-svg-files-as-react-components-with-vite-l3n]</a>(Importing SVG files as React components with Vite)<br>[<a href="https://stackoverflow.com/questions/74720726/type-definition-for-vite-plugin-svgr/75818331#75818331]">https://stackoverflow.com/questions/74720726/type-definition-for-vite-plugin-svgr/75818331#75818331]</a>(Type definition for vite-plugin-svgr?)</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> Vite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redux-persist</title>
      <link href="/uncategorized/20230419/49571/"/>
      <url>/uncategorized/20230419/49571/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在 React 中使用 Redux &amp; Resux Toolkit 並維持 persist state 的方式</p><span id="more"></span><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.npmjs.com/package/redux-persist">redux-persist</a><br><a href="https://blog.logrocket.com/persist-state-redux-persist-redux-toolkit-react/">Persist state with Redux Persist using Redux Toolkit in React</a><br><a href="https://blog.bitsrc.io/5-methods-to-persisting-state-between-page-reloads-in-react-8fc9abd3fa2f">5 Methods to Persisting State Between Page Reloads in React</a><br><a href="https://bobbyhadz.com/blog/react-call-function-in-child-component">Call a Child function from a Parent component using useImperativeHandle</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在 React strict mode 之下的 state 和 localStorage refresh</title>
      <link href="/react/20230419/60376/"/>
      <url>/react/20230419/60376/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>紀錄在 React strict mode 之下，透過 Local Storage 儲存 state 資料，並在 refresh 頁面後保留資料的方式</p><span id="more"></span><p>一般在 refresh 頁面後，component 的 state 資料就會被還原回初始值; 然而在某些情況，如: 第三方登入，會將頁面跳轉到第三方自家的認證頁面，並在成功後跳轉回 APP 頁面，這樣的行為就相當於 refresh 頁面，但有時候會希望不透過 API 將暫時資料儲存在 server，這時候最直覺的做法就是將資料儲存在 Local Storage。</p><p>一段簡易的使用者資料如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button&gt;Google 登入&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要與 Local Storage 的資料同步，就會在頁面載入時，取得 Local Storage 的資料，並在資料更新時同步更新 Local Storage 的資料，所以就可以透過 <code>useEffect</code> 執行這兩個動作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得 Local Storage 的資料</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setUser(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;user&quot;</span>)));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新 Local Storage 的資料</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user) <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;user&quot;</span>, <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">  &#125;, [user]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button&gt;Google 登入&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Strict-Mode"><a href="#Strict-Mode" class="headerlink" title="Strict Mode"></a>Strict Mode</h2><p>以上的作法在一般情況執行沒有問題，但如果在 React 18 strict mode 的環境下執行，就會發現資料並沒有被儲存到，但透過 <code>console.log</code> 印出資料就會發現，並不是資料沒有被更新到 Local Stroage，而是更新後資料又被初始值所覆蓋</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得 Local Storage 的資料</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;get&quot;</span>, <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;user&quot;</span>)).name);</span><br><span class="line">    setUser(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;user&quot;</span>)));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新 Local Storage 的資料</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set&quot;</span>, user.name);</span><br><span class="line">    <span class="keyword">if</span> (user) <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;user&quot;</span>, <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">  &#125;, [user]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button&gt;Google 登入&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原因是在 strict mode 之下，component 會被 render 兩次，而 state 從無到初始資料的過程就會觸發更新 Local Storage 的動作，所以在取得新的資料後，又把初始資料更新回去; 而為解決這種情況，除了依賴其他第三方套件之外，可以判斷如果 Local Storage 有資料，就直接以它為初始資料</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判斷 Local Storage 是否有資料，如有擇以它為初始資料</span></span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(<span class="function">() =&gt;</span></span><br><span class="line">    <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">      ? <span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;user&quot;</span>))</span><br><span class="line">      : &#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新 Local Storage 的資料</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set&quot;</span>, user.name);</span><br><span class="line">    <span class="keyword">if</span> (user) <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;user&quot;</span>, <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">  &#125;, [user]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button&gt;Google 登入&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://stackoverflow.com/questions/72222728/why-is-localstorage-getting-cleared-whenever-i-refresh-the-page">Why is localStorage getting cleared whenever I refresh the page?</a><br><a href="https://blog.bitsrc.io/5-methods-to-persisting-state-between-page-reloads-in-react-8fc9abd3fa2f">5 Methods to Persisting State Between Page Reloads in React</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Local Storage Strict mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph</title>
      <link href="/data-structure/20230320/34778/"/>
      <url>/data-structure/20230320/34778/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>先前介紹的 Tree 只是 Graph 的其中一種，所以 Graph 不一定為 Tree，Graph 也包含了更多種 Tree 不存在的資料格式，如: 循環(cycle)、雙向(undirected) …等。</p><span id="more"></span><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>Graph 可能會包含以下幾種特性:</p><ul><li><p>Directed &amp; Undirected<br>directed 代表節點之間是單向的，反之，undirected 節點之間是雙向的; 在 Tree 的資料結構中，只會有 direcrted 的情況</p></li><li><p>Connected Graph<br>一個 Graph 可能由多個獨立的 subgraph 所組成，如果這些 subgraph 的頂點彼此相連，則可以成為 Conneceted Graph</p></li><li><p>Acyclic Graph<br>與 Tree 不同的是，Graph 可以包含 cycle，也就是子結點可以指向回父結點，如果不包含 cycle 的 graph 則可以稱為 acyclic graph</p></li></ul><h2 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency List"></a>Adjacency List</h2><p>Adjacency List 是一種 Graph 中 常見的儲存方式，表示每個結點都會儲存相鄰的結點，所以在 Undirected Graph 中，如果 A 與 B 兩個結點彼此相鄰，A 的 Adjacency List 會儲存 B，反之，B 也會儲存 A。</p><p>與 Tree 不同的是，不需要透過固定的結點(root)來到達所有結點，所以基本的 Graph 會包含所有結點，如下所示:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  children: Node[]; <span class="comment">// adjacency list</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  nodes: Node[] = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，其實不需要額外定義新的資料結構來代表 Graph，任何序列的資料格式，如 Array、Linked List 或 Hash Table …等，都可以作為 Graph 的格式應用</p><p>在 JavaScript ES6+ 中，可以透過 Map 輕易地完成 Graph 結構的基本實作，其他方法如下:</p><ul><li>addNode: 新增一個節點，並賦予一個 array 以儲存相鄰的結點</li><li>addEdge: 為兩個結點建立連線，如果是 Undirected Graph，則會在兩個結點都分別記錄彼此的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> adjacencyList = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addNode = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  adjacencyList.set(value, []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add edge, undirected</span></span><br><span class="line"><span class="keyword">const</span> addEdge = <span class="function">(<span class="params">origin, destination</span>) =&gt;</span> &#123;</span><br><span class="line">  adjacencyList.get(origin).push(destination);</span><br><span class="line">  adjacencyList.get(destination).push(origin);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Adjacency-Matries"><a href="#Adjacency-Matries" class="headerlink" title="Adjacency Matries"></a>Adjacency Matries</h2><p>Adjacency Matries 是透過 NxN boolean matrix 來表示 Graph，N 代表總共有 N 個個結點，<code>matrix[i][j]</code> 指向結點 i 到結點 j，boolean 則代表彼此是否相連; 一個 Undirected Graph 的 Adjacency Matrix 會呈現對稱</p><p><img src="adjacency-matrix.png"></p><h2 id="Search-amp-Traversal"><a href="#Search-amp-Traversal" class="headerlink" title="Search &amp; Traversal"></a>Search &amp; Traversal</h2><p>在 Graph 的搜尋(search)和遍歷(traversal)上，和 Tree 一樣普遍分成兩種方法，分別是依循深度 depth-first-search (DFS) 和廣度 breadth-first-search (BFS)</p><h3 id="Bread-First-Search"><a href="#Bread-First-Search" class="headerlink" title="Bread First Search"></a>Bread First Search</h3><p>在 JavaScript 中，可以透過建立一個 Queue，選定一個結點當作結點後，將其相鄰的結點儲存到 Queue 中，而根據 first-in-first-out 的特性，會依序沿著 level 向下尋找，直到 Queue 清空為止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs = <span class="function">(<span class="params">start</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [start];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">    <span class="keyword">const</span> children = adjacencyList.get(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">      queue.push(child);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// do something if found the target</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這裡可能會有一個問題是，Graph 是允許包含 Circle 的，這種情況下， Queue 會永遠無法清空，進而產生無窮迴圈，所以需要再額外建立一個 list (visited)來儲存已經走訪過的結點，在 JavaScript 中，可以使用 Set 儲存不重複的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bfs = <span class="function">(<span class="params">start</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = [start];</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">    <span class="keyword">const</span> children = adjacencyList.get(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited.has(child)) &#123;</span><br><span class="line">        visited.add(child);</span><br><span class="line">        queue.push(child);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do something if found the target</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth First Search"></a>Depth First Search</h3><p>這種搜尋方式會優先以第一個子結點向下尋找，直到沒有子結點後，才會回到上層繼續尋找其他子結點，適用於搜尋明確的兩點間最佳距離</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dfs = <span class="function">(<span class="params">start, visited = <span class="keyword">new</span> Seet()</span>) =&gt;</span> &#123;</span><br><span class="line">  visited.add(start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> children = adjacencyList.get(start);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">    <span class="comment">// return if found the target</span></span><br><span class="line">    <span class="keyword">if</span> () <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!visted.has(child)) &#123;</span><br><span class="line">      dfs(child, visited);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h3><p>在 Graph 中，BFS 和 DFS 的時間複雜度都是 O(n)，這裡的 n 來自於結點(vertex) + 邊(edges) 的總和，所以會與資料量呈正比增加</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://crackingthecodinginterview.com/">Cracking the Coding Interview</a><br><a href="https://www.youtube.com/watch?v=cWNEl4HE2OE&ab_channel=Fireship">Graph Search Algorithms in 100 Seconds - And Beyond with JS</a></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cracking the Coding Interview </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree</title>
      <link href="/data-structure/20230319/57117/"/>
      <url>/data-structure/20230319/57117/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>先前提到的資料結構如: Array, Linked List, Stack 和 Queue 都是屬於 Linear，而接下來介紹的 Tree 和 Graph 則是屬於 Non-Linear，Tree 又屬於 Graph 的其中一種; 對於一位前端工程師來說，Non-Linear 這種資料結構在開發上鮮少會運用到，但其實每天在接觸的 Dom ，其資料結構就是 Tree!</p><span id="more"></span><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>Tree 這種資料結構之所以會被這麼稱呼就是因為它的結構像是一棵倒過來的樹，是一種 Non-Linear、具有階層的的結構，在生活上，如公司組織圖、族譜和賽程表都是很類似的應用。</p><p><img src="tree.png"></p><p>一個 Tree 是由許多 node (結點) 所組成，其資料結構會有以下特色:</p><ul><li>root: 代表最上面的根結點，每一個 Tree 只會有一個</li><li>parent node: 有 child node 的結點，所以除了 leaf 都算是</li><li>child node: 有 parent node 的都算是，所以只有 root 不算</li><li>subtree: 由結點與其後代結點所組成</li><li>leaf: 葉結點或外部結點，為沒有 child node 的結點</li><li>depth: 結點的深度，代表該結點有幾層祖先結點，root depth 即為 0</li><li>height: Tree 的高度，代表總共有幾層</li></ul><p>Tree 無法包含循環結構(cycle)，也就是 child node 無法再指向回 parent node</p><p><img src="tree-none-cycle.png"></p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>一個 Node 會包含以下內容:</p><ul><li>value: 所代表的值</li><li>children: 所指向的 child node</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.children = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tree-的種類"><a href="#Tree-的種類" class="headerlink" title="Tree 的種類"></a>Tree 的種類</h2><p>Tree 有許多種類型，接下來將介紹幾種常見的類型</p><h3 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h3><p>Binary Tree 的定義是每個 node “最多”只能有 2 個 child node，所以下方左圖是 Binary Tree，而右圖則否</p><p><img src="binary-tree.png"></p><h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><p>Binary Search Tree 是 Binary Tree 的一種，同樣也有最多 2 個 child node 的規則，只是在 key 的部分多了一些規則如下:</p><ul><li>左邊所有的 child node: key 會小於等於 parent node</li><li>右邊所有的 child node: key 會大於 parent node</li></ul><p>所以結果會是 左邊所有的 child node &lt;= parent node &lt; 右邊所有的 child node</p><p><img src="binary-search-tree.png"></p><p>在 Binary Search Tree 中，每個結點最多只會有兩個子結點 (left and right)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Insert<br>插入一個 node，其值會從 root 開始比較，如果小於 parent node，則從 left node 繼續比較，反之則從 right node 繼續比; 以新結點 4 來說，總共比較了 3 次</p><p><img src="bst-insert.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">insert</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> BinarySearchTree(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (value &lt;= <span class="built_in">this</span>.value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.left) &#123;</span><br><span class="line">      <span class="built_in">this</span>.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.left.insert(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.right) &#123;</span><br><span class="line">      <span class="built_in">this</span>.right = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.right.insert(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Min/Max<br>在 Binary Search Tree 中，最小的值一定會在最左邊，反之，最大的值會在最右邊</p><p><img src="bst-min-and-max.png"></p></li></ul><h3 id="Balanced-vs-Unbalanced-Tree"><a href="#Balanced-vs-Unbalanced-Tree" class="headerlink" title="Balanced vs. Unbalanced Tree"></a>Balanced vs. Unbalanced Tree</h3><p>Balanced Tree 指的並非是左右結點的高度相同(如果左右高度相同，總結點數勢必為奇數)，而是指包含一定程度排列，使的 insert 和 find 都可以在 O(log n) 的時間複雜度之內完成，經典的例子是紅黑樹(Red-black Trees) 和 AVL Trees。</p><h3 id="Complete-Binary-Tree"><a href="#Complete-Binary-Tree" class="headerlink" title="Complete Binary Tree"></a>Complete Binary Tree</h3><p>所有結點都是由左到右依序被填滿的，所以如果只有右結點而沒有左結點，就不是一個 Complete Binary Tree，如下左圖是，右圖則否</p><p><img src="complete-binary-tree.png"></p><h3 id="Full-Binary-Tree"><a href="#Full-Binary-Tree" class="headerlink" title="Full Binary Tree"></a>Full Binary Tree</h3><p>代表所有結點都沒有子結點或包含兩個子結點，也就是不會只有一個子結點</p><h3 id="Perfect-Binary-Tree"><a href="#Perfect-Binary-Tree" class="headerlink" title="Perfect Binary Tree"></a>Perfect Binary Tree</h3><p>同時包含 Full 和 Complete Binary Tree 的特性，所以所有 leaf node 都會在同一個 level，總結點數會是 2^k - 1 個，k 代表 level 的數量，要特別注意的是，遇到 Binary Tree 相關題目時，不應該預設為 Perfect Tree，避免考量的不夠周全。</p><h3 id="Binary-Heap"><a href="#Binary-Heap" class="headerlink" title="Binary Heap"></a>Binary Heap</h3><p>Binary Heap 是 Complete Binary Tree 的其中一種，所以同樣也有最多兩個子結點和優先填寫左子結點的特性，但有相同父結點的子結點彼此並沒有潛藏的關聯性; 其中，又根據降冪和升冪排列分成 Min/Max Binary Heap，Min 的所有父結點都會小於子結點，所以 root 會有最小的值; 反之，Max 則會是大於。</p><p><img src="binary-heap.png"></p><h4 id="什麼時候需要使用-Binary-Heap"><a href="#什麼時候需要使用-Binary-Heap" class="headerlink" title="什麼時候需要使用 Binary Heap?"></a>什麼時候需要使用 Binary Heap?</h4><p>Binary Heap 通常會使用在 Priority Queues，那什麼又是 Priority Queues?</p><p>Queues 在先前的章節有介紹過，即是一種先進先出 (FIFO) 的資料結構，而 Priority Queues 顧名思義是每個結點又額外包含優先級 (priority) 的特性，所以在取出資料時 (dequeue)，可以優先取出高優先級的資料。</p><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>以下方法都會先以 Min Binary Heap 為例</p><ul><li><p>Insert<br>在插入一個結點後，會依序往上比較，如果子結點的值大於父結點，則兩者交換位置，直到子結點小於父結點為止，反之，Max 則是大於，時間複雜度為 O(log n)</p><p><img src="binary-heap-insert.png"></p></li><li><p>Remove (Deqeue)<br>移除一個最小值非常容易，因為它就是 root (高優先級)，重點是，移除之後，要由誰來遞補 root 的位置，時間複雜度為 O(log n)，會由以下幾個步驟來完成:</p><ul><li>Step 1: 移除 root</li><li>Step 2: 取最後一個結點替換到 root</li><li>Step 3: 依序向下比較，如果父結點大於子結點，則兩者交換; 如果左右兩子結點皆符合條件，在 Min Binary Heap 中，則以”較小者”優先交換</li></ul><p><img src="binary-heap-remove.png"></p></li></ul><h2 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h2><p>在 Binary Tree 中，traversal 又分成以下 3 種:</p><h3 id="In-Order-Traversal"><a href="#In-Order-Traversal" class="headerlink" title="In-Order Traversal"></a>In-Order Traversal</h3><p>從底部開始，由左至右依序輸出，left -&gt; self -&gt; right，所以在 Binary Search Tree 中，會依序輸出由小至大的值，下圖中的數字代表執行順序</p><p><img src="in-order.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">inOrder</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  inOrder(root.left);</span><br><span class="line">  <span class="built_in">console</span>.log(root.key);</span><br><span class="line">  inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Pre-Order-Traversal"><a href="#Pre-Order-Traversal" class="headerlink" title="Pre-Order Traversal"></a>Pre-Order Traversal</h3><p>由上而下，再由左至右依序輸出，self -&gt; left -&gt; right; 所以在 Pre-Order 中，root 總會是造訪的起點，下圖中的數字代表執行順序</p><p><img src="pre-order.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">preOrder</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(root.key);</span><br><span class="line">  preOrder(root.left);</span><br><span class="line">  preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Post-Order-Traversal"><a href="#Post-Order-Traversal" class="headerlink" title="Post-Order Traversal"></a>Post-Order Traversal</h3><p>由下而上，在由左至右依序輸出，left -&gt; right -&gt; self，下圖中的數字代表執行順序</p><p><img src="post-order.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">postOrder</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  postOrder(root.left);</span><br><span class="line">  postOrder(root.right);</span><br><span class="line">  <span class="built_in">console</span>.(root.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>在搜尋上，又分成兩種，分別從廣度與深度著手搜尋</p><ul><li><p>Depth First Search(DFS): 由左至右搜尋完一個 branch 後，才會跳至右側的 branch 繼續搜尋，下圖中的數字代表執行順序</p><p><img src="dfs.png"></p></li><li><p>Breadth First Search(BFS): 由左至右搜尋完一個 level 後，才會跳至下一個 level 繼續搜尋，下圖中的數字代表執行順序</p><p><img src="bfs.png"></p></li></ul><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://crackingthecodinginterview.com/">Cracking the Coding Interview</a><br><a href="https://www.youtube.com/watch?v=fPz40W9mfCg&ab_channel=Coderbyte">Depth First &amp; Tree Traversals (Pre, In, Post) Explained</a><br><a href="https://pjchender.blogspot.com/2020/05/binary-tree.html">[資料結構] Binary Search Tree</a><br><a href="https://medium.com/geekculture/binary-heaps-in-javascript-94900035ee0c">Binary Heaps in JavaScript</a></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cracking the Coding Interview </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stacks and Queues</title>
      <link href="/data-structure/20230317/62505/"/>
      <url>/data-structure/20230317/62505/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>Stacks 與 Queues 是相對單純的資料結構，在取得資料時，只會依序取得最前或最後的那一筆資料，目的也是為了限制資料的使用; 而實作上，並不限於使用 Array 或 Linked List，只要符合個別的定義都可以稱為 Stacks 或 Queues。</p><span id="more"></span><h2 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h2><p>採用後進先出 last-in-first-out (LIFO) 的方式排列，可以想像成蝶盤子的形式，最後疊上來的盤子會優先被取出，使用上常用於操昨工具時的上一步或瀏覽器的上一頁</p><p><img src="stacks.png"></p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><ul><li>pop: 刪除最上層的一筆資料，時間複雜度為 O(1)</li><li>push: 加入一筆資料在最上層，時間複雜度為 O(1)</li><li>peek: 取得最上層的一筆資料，但不刪除資料，時間複雜度為 O(1)</li><li>isEmpty: 檢查 Stacks 是否為空</li></ul><p>在 JavaScript 中，Array 有直接提供 method 來完成 Stack 的需求，而如果採用 Linked List 來實作，就需要使用 Doubly Linked List 來提供 previous data</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  value: <span class="built_in">any</span>;</span><br><span class="line">  next: Node | <span class="literal">null</span>;</span><br><span class="line">  prev: Node | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Stacks</span> </span>&#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  head: Node | <span class="literal">null</span>;</span><br><span class="line">  tail: Node | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newNode.prev = <span class="built_in">this</span>.tail;</span><br><span class="line">      <span class="built_in">this</span>.tail!.next = newNode;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.tail!.value;</span><br><span class="line">      <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.tail!.value;</span><br><span class="line">      <span class="built_in">this</span>.tail = <span class="built_in">this</span>.tail!.prev;</span><br><span class="line">      <span class="built_in">this</span>.tail!.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.tail!.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Queues"><a href="#Queues" class="headerlink" title="Queues"></a>Queues</h2><p>採用先進先出 first-in-first-out (FIFO) 的方式排列，可以想像成排隊的人潮，第一個排隊的人就可以優先進場</p><p><img src="queues.png"></p><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h3><ul><li>add (enqueue): 加入一筆資料在最後面，時間複雜度為 O(1)</li><li>remove (dequeue): 移除最前面的一筆資料，時間複雜度為 O(1)</li><li>peek: 取得最前面的一筆資料，但不刪除資料，時間複雜度為 O(1)</li><li>isEmpty: 檢查 Queues 是否為空</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  value: <span class="built_in">any</span>;</span><br><span class="line">  next: Node | <span class="literal">null</span>;</span><br><span class="line">  prev: Node | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Queues</span> </span>&#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  head: Node | <span class="literal">null</span>;</span><br><span class="line">  tail: Node | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">      <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">      <span class="built_in">this</span>.head!.prev = newNode;</span><br><span class="line">      <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.length++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.head!.value;</span><br><span class="line">      <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.head!.value;</span><br><span class="line">      <span class="built_in">this</span>.head = <span class="built_in">this</span>.head!.next;</span><br><span class="line">      <span class="built_in">this</span>.head!.prev = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">peek</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.head!.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">isEmpty</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array-與-Linked-List-比較"><a href="#Array-與-Linked-List-比較" class="headerlink" title="Array 與 Linked List 比較"></a>Array 與 Linked List 比較</h2><p>在 JavaScript 中，如果使用 Array 來實作 Stacks 與 Queues，其實都有預設的 Array functions 可以直接達到目的，只是因為 Queues 所使用的 remove (<code>unshift</code>) 會改變所有 Array 的 index，所以在效能上會比較差 (同理 <code>shift</code> 也是)，所以如果有效能上的考量，Queues 會建議使用 Linked List 來進行實作。</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://crackingthecodinginterview.com/">Cracking the Coding Interview</a><br><a href="https://pjchender.dev/dsa/dsa-stacks-queues/">[資料結構] Stacks and Queues</a><br><a href=""></a></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cracking the Coding Interview </tag>
            
            <tag> Stack </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storybook addons panel not showing</title>
      <link href="/storybook/20230306/60961/"/>
      <url>/storybook/20230306/60961/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>截至目前為止 Storybook 7.0.0-beta.58 仍會出現此 bug</p><span id="more"></span><p>Storybook 會突然出現其餘功能正常，但無法顯示 addons panel 的情況，如下:</p><p><img src="addons-panel-not-show.png"></p><p>可透過以下指令於 Devtools Console 清除 localStorage</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.clear();</span><br></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://github.com/storybookjs/storybook/issues/8383">Addons panel not showing - but knobs are still working(?)</a><br><a href="https://storybook.js.org/docs/7.0/react/configure/features-and-behavior">Features and behavior</a></p>]]></content>
      
      
      <categories>
          
          <category> Storybook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List</title>
      <link href="/data-structure/20230302/18120/"/>
      <url>/data-structure/20230302/18120/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>Linked List 是一種包含順序的資料結構，但和 Array 不同的是，沒有 index 來指出特定 Node，因此，如果要尋找 list 中的某個 Node，就需要遍歷整個 list; 因大多數程式語言在宣告 Array 時，都會固定其長度，並在記憶體中做連續性的儲存，Linked List 就是為了解決這種長度固定的問題而存在，避免太小不夠用或太大浪費空間。</p><p>為了達到彈性長度的目的，在記憶體中儲存時就會不連續，所以每個 Node 都會明確指出下一個 Node，以確保資料之間的鏈結。</p><span id="more"></span><p>而 Listed List 又分成三種，分別是 Singly、Doubly Linked List &amp; Circularly Linked List，所有的 Node 都包含 value 與下一個 Node 的資訊 next，Doubly &amp; Circularly Linked List 的 Node 還會額外包含上一個 Node 的資訊 prev</p><h2 id="Singly-Linked-List"><a href="#Singly-Linked-List" class="headerlink" title="Singly Linked List"></a>Singly Linked List</h2><p><img src="singly-linked-list.png"></p><ul><li>每個 Node 會包含 value</li><li>每個 Node 會包含下一個 Node 的指標</li><li>從頭部 head 開始，依序往下讀取至尾部 tail 結束</li></ul><h2 id="Doubly-Linked-List"><a href="#Doubly-Linked-List" class="headerlink" title="Doubly Linked List"></a>Doubly Linked List</h2><p><img src="doubly-linked-list.png"></p><ul><li>每個 Node 會包含 value</li><li>每個 Node 會包含上一個與下一個 Node 的指標</li><li>從頭部 head 開始，依序往下讀取至尾部 tail 結束</li><li>因具備 prev 指標，所以也可以從 tail 開始往前尋找</li></ul><h2 id="Circularly-Linked-List"><a href="#Circularly-Linked-List" class="headerlink" title="Circularly-Linked-List"></a>Circularly-Linked-List</h2><p><img src="circularly-linked-list.png"></p><ul><li>每個 Node 會包含 value</li><li>每個 Node 會包含上一個與下一個 Node 的指標</li><li>從頭部 head 開始，依序往下讀取至尾部 tail，頭尾指標彼此會再接在一起，形成一個循環</li><li>head prev 會指向 tail，tail next 會指向 head</li></ul><h2 id="JavaScript-實作"><a href="#JavaScript-實作" class="headerlink" title="JavaScript 實作"></a>JavaScript 實作</h2><p>在 JavaScript 中，並沒有內建的 Linked List，所以必須透過 Object 來實作，其中包含節點 Node、Linked List 與其所提供的方法 methods</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node 會包含其所代表的資料與指標</p><ul><li><code>value</code>: 資料</li><li><code>next</code>: 指向下一個 Node 的指標</li><li><code>prev</code>: 指向上一個 Node 的指標(Singly Linked List 並未包含)</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  value: <span class="built_in">any</span>;</span><br><span class="line">  next: Node | <span class="literal">null</span>;</span><br><span class="line">  prev: Node | <span class="literal">null</span>; <span class="comment">// Doubly only</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h3><p>Linked List 會提供幾項基本屬性與方法供使用者進行操作</p><h4 id="屬性-Property"><a href="#屬性-Property" class="headerlink" title="屬性 Property"></a>屬性 Property</h4><ul><li><code>length</code>: Linked List 的長度</li><li><code>head</code>: 指向第一個 Node，如果 <code>length</code> 為 0，則為 null;如果 <code>length</code> 為 1 則和 <code>tail</code> 指向同一個 Node</li><li><code>tail</code>: 指向最後一個 Node，如果 <code>length</code> 為 0，則為 null;如果 <code>length</code> 為 1 則和 <code>head</code> 指向同一個 Node</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  head: Node | <span class="literal">null</span>;</span><br><span class="line">  tail: Node | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-Method"><a href="#方法-Method" class="headerlink" title="方法 Method"></a>方法 Method</h4><ul><li><p><code>append</code>: 在 <code>tail</code> 插入一個 Node</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">append</span>(<span class="params">value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Linked List is empty</span></span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newNode.prev = <span class="built_in">this</span>.tail;  <span class="comment">// Doubly only</span></span><br><span class="line">    <span class="built_in">this</span>.tail!.next = newNode;</span><br><span class="line">    <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>preppend</code>: 在 <code>head</code> 插入一個 Node</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">preppend</span>(<span class="params">value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Linked List is empty</span></span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">    <span class="built_in">this</span>.tail = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="built_in">this</span>.head!.prev = newNode;  <span class="comment">// Doubly only</span></span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getNode</code>: 因為 Linked List 不像 Array 可以直接透過 index 到達指定位置，所以需先根據 index 遍歷取得指定位置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getNode</span>(<span class="params">index: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">this</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// search Node from head</span></span><br><span class="line">  <span class="keyword">let</span> tempNode = <span class="built_in">this</span>.head;</span><br><span class="line">  <span class="keyword">let</span> tempIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (tempIdx &lt; index) &#123;</span><br><span class="line">    tempNode = tempNode!.next;</span><br><span class="line">    tempIdx++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tempNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>insert</code>: 於指定位置插入一個 Node</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">insert</span>(<span class="params">index: <span class="built_in">number</span>, value: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="built_in">this</span>.length) &#123;</span><br><span class="line">    <span class="built_in">this</span>.append(value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    newNode.next = <span class="built_in">this</span>.head;</span><br><span class="line">    <span class="built_in">this</span>.head = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prevNode = <span class="built_in">this</span>.getNode(index - <span class="number">1</span>) <span class="keyword">as</span> Node;</span><br><span class="line">    <span class="keyword">const</span> currNode = prevNode.next <span class="keyword">as</span> Node;</span><br><span class="line">    prevNode.next = newNode;</span><br><span class="line">    newNode.prev = prevNode; <span class="comment">// Doubly only</span></span><br><span class="line">    newNode.next = currNode;</span><br><span class="line">    currNode.prev = newNode; <span class="comment">// Doubly only</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>remove</code>: 刪除指定 Node</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">remove</span>(<span class="params">index: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">this</span>.length || <span class="built_in">this</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="built_in">this</span>.head!.next;</span><br><span class="line">    <span class="built_in">this</span>.head!.prev = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> prevNode = <span class="built_in">this</span>.getNode(index - <span class="number">1</span>) <span class="keyword">as</span> Node;</span><br><span class="line">    <span class="keyword">const</span> nextNode = <span class="built_in">this</span>.getNode(index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    prevNode.next = nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextNode) &#123;</span><br><span class="line">      <span class="built_in">this</span>.tail = prevNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextNode.prev = prevNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>print</code>: 按照 Linked List 印出所有 Node value</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(): <span class="built_in">any</span>[] &#123;</span><br><span class="line">  <span class="keyword">let</span> array: <span class="built_in">any</span>[] = [];</span><br><span class="line">  <span class="keyword">let</span> tempNode = <span class="built_in">this</span>.head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="時間複雜度"><a href="#時間複雜度" class="headerlink" title="時間複雜度"></a>時間複雜度</h2><p>在取得節點的情況下，插入與刪除為 O(1)，但如果沒有取得節點就會是 O(n)，而因為不如 Array 有明確的 index，所以搜尋為 O(n)</p><ul><li>插入 insert、刪除 delete: O(1) or O(n)</li><li>新增/刪除頭部 prepend、新增/刪除尾部 append: O(1)</li><li>存取 &amp; 搜尋 lookup: O(n)</li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://crackingthecodinginterview.com/">Cracking the Coding Interview</a><br><a href="https://pjchender.dev/dsa/dsa-array-linked-list/">[資料結構] Array and Linked List</a><br><a href="https://en.wikipedia.org/wiki/Linked_list">Linked List Wiki</a><br><a href="https://chupai.github.io/posts/200427_ds_linkedlist/">JavaScript 學演算法（五）- 鏈結串列 Linked list</a></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cracking the Coding Interview </tag>
            
            <tag> Linked List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash Table</title>
      <link href="/data-structure/20230227/65261/"/>
      <url>/data-structure/20230227/65261/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>想像一下有一個非常大的資料庫如全國總人口，如果只是單純使用一個 Array 來儲存，每次查找的時間複雜度就會是 O(n)，如果希望降低這些功能的時間複雜度到 O(1)，就可以透過 hsah table 來達到;Hash Table 其實就是透過 hash function 將 key 轉換成索引，並以 key-value 的方式來儲存資料。</p><span id="more"></span><p>在 JavaScript 中，會透過 Object (包含 Array)來進行 Hash Table 的實作</p><h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p><img src="Hash-Table.png"></p><ul><li>Hash Table 為一個 Array，其中每一筆資料都是 key-value pairs，稱為 <code>Bucket</code></li><li>透過自定義的 hash function 將資料的 key 轉化成一個 hash code，藉此決定資料要存在 Hash Table 中的哪一個位置</li><li>無論透過什麼方式來實作 hash function，都有可能在不同的資料 input 下，產生相同的 output (hash code)，史的資料儲存在相同的記憶體位置上，導致查找資料的時間複雜度由 O(1) -&gt; O(n)，這種情況就稱為 <code>Collision</code></li><li>當產生 <code>Collision</code> 的情況時，就會透過 Linked List 的方式將資料串聯在一起</li></ul><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><p>一個 Hash Table 會包含以下幾種功能需求:</p><ul><li>hash function: 將資料提供的 key 產生特定的 hash code 儲存在 Hash Table 中，一般會將 key 所轉化的數字透過除以 Array 長度所得的餘數 (% array.length)，藉此儲存在有限長度 Array 的 <code>Bucket</code></li><li>memory: 儲存資料，時間複雜度為 O(n)</li><li>insert: 新增資料，時間複雜度為 O(1)</li><li>delete: 刪除資料，時間複雜度為 O(1)</li><li>search: 查找資料，時間複雜度為 O(1)，如果發生 <code>Collision</code> 的狀況，時間複雜度就是 O(n)</li><li>keys: 取得所有 key，時間複雜度為 O(n^2)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  storage: any[];</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size: number</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.storage = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private <span class="function"><span class="title">hash</span>(<span class="params">key: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; key.length; i++) &#123;</span><br><span class="line">      hash += key.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash % <span class="built_in">this</span>.storage.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.storage);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key: string, value: any</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> address = <span class="built_in">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[address];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bucket) &#123;</span><br><span class="line">      <span class="built_in">this</span>.storage[address] = [</span><br><span class="line">        [key, value]</span><br><span class="line">      ];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> inserted = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[i][<span class="number">0</span>] === key) &#123;</span><br><span class="line">          bucket[i][<span class="number">1</span>] = value;</span><br><span class="line">          inserted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!inserted) &#123;</span><br><span class="line">        bucket.push([key, value]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.storage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  search(key: string): any &#123;</span><br><span class="line">    <span class="keyword">const</span> address = <span class="built_in">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[address];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> [_key, value] = bucket[i];</span><br><span class="line">        <span class="keyword">if</span> (_key === key) &#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">delete</span>(<span class="params">key: string</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> address = <span class="built_in">this</span>.hash(key);</span><br><span class="line">    <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[address];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucket[<span class="number">0</span>][<span class="number">0</span>] === key &amp;&amp; bucket.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">this</span>.storage[address];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucket.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[i][<span class="number">0</span>] === key) &#123;</span><br><span class="line">          <span class="keyword">delete</span> bucket[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">keys</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keys: any[] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.storage.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> bucket = <span class="built_in">this</span>.storage[i];</span><br><span class="line">      <span class="keyword">if</span> (bucket) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">          <span class="keyword">const</span> [key] = bucket[j];</span><br><span class="line">          keys.push(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keys;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myHashTable = <span class="keyword">new</span> HashTable(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">myHashTable.insert(<span class="string">&#x27;grapes&#x27;</span>, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://crackingthecodinginterview.com/">Cracking the Coding Interview</a><br><a href="https://github.com/Jerry-Yeh/CtCI-6th-Edition-JavaScript/blob/master/data-structure/hash-table.ts">Github</a><br><a href="https://codeburst.io/objects-and-hash-tables-in-javascript-a472ad1940d9">Objects and Hash Tables in Javascript</a><br><a href="https://pjchender.dev/dsa/dsa-hash-table/">[資料結構] Hash Table</a><br><a href="https://www.youtube.com/watch?v=F95z5Wxd9ks&t=306s">Hash Tables - Beau teaches JavaScript</a></p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cracking the Coding Interview </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Strict Mode</title>
      <link href="/react/20221015/65126/"/>
      <url>/react/20221015/65126/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在 React 18 中，如果開啟 Strict Mode，每當 component mounts 後，就會立即 unmount 再 remount 一次，這麼做的目的是提醒非必要的行為有被正確的清除，不過也不用擔心效能問題，因為這個行為只會發生在 development 模式下，所以非常建議在開發中啟動 Strict Mode，而非關閉它</p><span id="more"></span><h2 id="Turn-on-Strict-Mode"><a href="#Turn-on-Strict-Mode" class="headerlink" title="Turn on Strict Mode"></a>Turn on Strict Mode</h2><p>在 React 18 的專案中要開啟 Strict Mode 也非常容易，只要在進入點 index.tsx 透過 react 取得 <code>StrictMode</code>，並將其包覆根元件，這麼一來整個專案的元件就會啟動 Strict Mode 了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; StrictMode &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RouterProvider &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>) <span class="keyword">as</span> HTMLElement</span><br><span class="line">);</span><br><span class="line">root.render(</span><br><span class="line">  &lt;StrictMode&gt;</span><br><span class="line">    &lt;RouterProvider router=&#123;router&#125; /&gt;</span><br><span class="line">  &lt;/StrictMode&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="How-to-handle-the-Effect-firing-twice-in-development"><a href="#How-to-handle-the-Effect-firing-twice-in-development" class="headerlink" title="How to handle the Effect firing twice in development?"></a>How to handle the Effect firing twice in development?</h2><p>開啟 Strict Mode 後，useEffect 中的行為就會在開始時，被連續觸發兩次，而我們要思考的不是怎麼讓它只觸發一次，而是怎麼解決在 remount 後所發生的事情。</p><p>在大部分的情況中，可以透過正確的使用 cleanup 來解決這個問題，以下是大部分開發中會出現的情境:</p><h3 id="Controlling-non-React-widgets"><a href="#Controlling-non-React-widgets" class="headerlink" title="Controlling non-React widgets"></a>Controlling non-React widgets</h3><p>如果是一個與 React 沒有綁定 UI 元件，寫法其實就和一般寫法相同;舉個例子，這裡我們透過 <code>setZoomLevel</code> method 新增了一個 map component，因為直接使用 <code>zoomLevel</code> state，所以並不需要特別處理，反正在 production 也只會執行一次</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = mapRef.current;</span><br><span class="line">  map.setZoomLevel(zoomLevel);</span><br><span class="line">&#125;, [zoomLevel]);</span><br></pre></td></tr></table></figure><p>但有些 API 即使在 development 可能也不希望呼叫兩次，例如一個 dialog 元件顯示，這種情況就可以在 cleanup 來立即關閉它，這麼一來顯示上就會如 production 只顯示一次</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dialog = dialogRef.current;</span><br><span class="line">  dialog.showModal();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> dialog.close(); <span class="comment">// close dialog</span></span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="Subscribing-to-events"><a href="#Subscribing-to-events" class="headerlink" title="Subscribing to events"></a>Subscribing to events</h3><p>如果是透過事件監聽 <code>addEventListener()</code> 註冊一個事件，就可以在 cleanup 使用 <code>removeEventListener()</code> 來取消監聽</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleScroll</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.clientX, e.clientY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>, handleScroll);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">&quot;scroll&quot;</span>, handleScroll); <span class="comment">// remove listener</span></span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="Triggering-animations"><a href="#Triggering-animations" class="headerlink" title="Triggering animations"></a>Triggering animations</h3><p>如果是透過調整 css 參數來影響畫面呈現的情況，就可以在 cleanup 將參數條回預設值，例如 opacity 由 0 -&gt; 1 的變化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = ref.current;</span><br><span class="line">  node.style.opacity = <span class="number">1</span>; <span class="comment">// Trigger the animation</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    node.style.opacity = <span class="number">0</span>; <span class="comment">// Reset to the initial value</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="Fetching-data"><a href="#Fetching-data" class="headerlink" title="Fetching data"></a>Fetching data</h3><p>而如果是非同步的網路請求，就無法在送出後還要求撤回，因此需要透過一個變數來阻止重複更新資料，並在第一次呼叫後，於 cleanup 更改狀態，這麼一來更新資料的動作就只會執行一次，這麼做的目的是測試避免有任何相關聯的行為影響到資料</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">startFetching</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> fetchTodos(userId);</span><br><span class="line">    <span class="keyword">if</span> (!ignore) &#123;</span><br><span class="line">      setTodos(json);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  startFetching();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ignore = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [userId]);</span><br></pre></td></tr></table></figure><p>在 development 環境可以透過 Devtool Network 發現，網路請求確實執行了兩次，但同樣的，在 production 環境只會被執行一次</p><h2 id="Sending-analytics"><a href="#Sending-analytics" class="headerlink" title="Sending analytics"></a>Sending analytics</h2><p>有些行為執行一次或兩次在使用者眼中並沒有差別，例如畫面的切換，在這種情況下就建議維持原有寫法即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  logVisit(url); <span class="comment">// Sends a POST request</span></span><br><span class="line">&#125;, [url]);</span><br></pre></td></tr></table></figure><h2 id="Not-an-Effect-Initializing-the-application"><a href="#Not-an-Effect-Initializing-the-application" class="headerlink" title="Not an Effect: Initializing the application"></a>Not an Effect: Initializing the application</h2><p>而有些邏輯只會在整個應用程式啟動時執行一次，這種功能就可以將其獨立於 component 之外，不隨著 component 更新而觸發</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// Check if we&#x27;re running in the browser.</span></span><br><span class="line">  checkAuthToken();</span><br><span class="line">  loadDataFromLocalStorage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Not-an-Effect-Buying-a-product"><a href="#Not-an-Effect-Buying-a-product" class="headerlink" title="Not an Effect: Buying a product"></a>Not an Effect: Buying a product</h2><p>而有些行為同樣也不希望被執行兩次，例如送出購買的需求，如果按返回鈕就被重複執行，這種情況想必不太樂見</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.</span></span><br><span class="line">  fetch(<span class="string">&quot;/api/buy&quot;</span>, &#123; <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span> &#125;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>所以也不該寫在 Effect 之中，而是透過實際使用者主動的操作行為來觸發</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ✅ Buying is an event because it is caused by a particular interaction.</span></span><br><span class="line">  fetch(<span class="string">&quot;/api/buy&quot;</span>, &#123; <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><ul><li>有別於事件，Effects 觸發於 component render 的時機，而不是特定的使用者交互作用</li><li>Effects 提供外部的系統(如: 第三方 API 或網路請求行為) 與 component 同步</li><li>預設的情況下，Effect 會在每次的 component render 都被執行</li><li>你無法自行決定 dependencies，它來自於 Effect 中所引用的參數</li><li>空的 dependency array <code>[]</code> 代表 component mounting 的行為</li><li>如果為 React 專案加上 Strict Mode，就會在 development mount component 的階段執行兩次 Effects 中的行為以利壓力測試</li><li>如果 Effect 行為終止於 remounting 階段，就需要使用 cleanup function</li><li>React 會在下一次 Effect 執行之前，呼叫 cleanup function，也就是 unmount 階段</li></ul><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://beta.reactjs.org/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development">How to handle data fetching happening twice?</a><br><a href="https://stackoverflow.com/questions/72238175/useeffect-is-running-twice-on-mount-in-react">[stackoverflow] useEffect is running twice on mount in React</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React Project with TypeScript</title>
      <link href="/react/20220904/50067/"/>
      <url>/react/20220904/50067/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>雖然 React 預設是沒有使用 TypeScript 的，但 React 提供了非常簡易的方式來建立 TypeScript 專案，接下來將在 React 專案中導入 TypeScript</p><span id="more"></span><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><ol><li>透過 create-create-app 建立 React 專案</li></ol><p>在<a href="https://create-react-app.dev/docs/adding-typescript/">官方的文件中</a>，就可以很輕易的直接透過 npm or yarn 來建立包含 TypeScript 的 React 專案中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npx create-react-app my-app --template typescript</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">$ yarn create react-app my-app --template typescript</span><br></pre></td></tr></table></figure><p>安裝後，開啟專案會看到出現副檔名為 .tsx 的檔案，其實這和 .ts 一樣都是 TypeScript 檔案，只是因為 React 使用了 JSX 導致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">| App.tsx</span><br><span class="line">| inex.tsx</span><br></pre></td></tr></table></figure><p>打開 package.json 後，會看到除了 React 預設的 library react、react-dom 與 typescript 之外，還會有前方包含 @types/ 的 dependencies，會有這些 dependencies 是因為這些 libraries 預設並沒有包含 TypeScript，所以需要為這些 libraries 額外加上 Type 以在 TypeScript 專案中運行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@types/jest&quot;</span>: <span class="string">&quot;^27.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@types/node&quot;</span>: <span class="string">&quot;^16.7.13&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span>: <span class="string">&quot;^18.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@types/react-dom&quot;</span>: <span class="string">&quot;^18.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react&quot;</span>: <span class="string">&quot;^18.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-dom&quot;</span>: <span class="string">&quot;^18.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;react-scripts&quot;</span>: <span class="string">&quot;5.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typescript&quot;</span>: <span class="string">&quot;^4.4.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;web-vitals&quot;</span>: <span class="string">&quot;^2.1.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>透過 tsconfig.json 定義 TyepScript</li></ol><p>可以參考<a href="https://www.sitepoint.com/react-with-typescript-best-practices/">這篇文章</a>的基礎設定，如果對其他選項有興趣可以進一步從<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#handbook-content">官網</a>了解</p><ol start="3"><li>透過 .eslintrc.json 定義 ESLint</li></ol><p>執行以下指令後，就會有一連串的設定問題出現，接下來只要依照專案需求回復，就會自動在專案下建立符合的設定檔</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npx exlint --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 為避免與 create-react-app 中的 ESLint 衝突，可執行以下指令刪除並重新安裝</span></span><br><span class="line">$ rm package-lock.json</span><br><span class="line">$ rm -rf node_modules</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><ol start="4"><li>透過 .prettierrc.json 定義 prettier</li></ol><p>同樣可以透過<a href="https://www.sitepoint.com/react-with-typescript-best-practices/">這篇文章</a>為 prettier 做基本的設定，額外需求可以到<a href="https://prettier.io/docs/en/install.html">官網</a>進一步了解</p><h2 id="Working-with-Props"><a href="#Working-with-Props" class="headerlink" title="Working with Props"></a>Working with Props</h2><p>一個簡單的 component 如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Todos.tsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todos = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Todos;</span><br></pre></td></tr></table></figure><p>透過 props 傳進來的資料顯示於 JSX 上，一般的 React 專案就寫到這裡了，但當我們導入 TypeScript 後，props 就會出現錯誤提示，如下:</p><p><img src="props-any-type.png"></p><p>原因是 TypeScript 不知道 props 內的資料型別，那很簡單，直接在 props 加入預期的資料型別</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Todos = <span class="function">(<span class="params">props: &#123; items: <span class="built_in">string</span>[] &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這麼一來錯誤提示就消失了</p><h3 id="props-children-amp-React-FC"><a href="#props-children-amp-React-FC" class="headerlink" title="props.children &amp; React.FC"></a>props.children &amp; React.FC</h3><p>但不要忘了，props 除了我們自定義的資料外，還有一個預設的 key - children，但 <code>props.children</code> 是 component 在使用時動態加入 JSX，所以無法在一開始就確認型別</p><p>為了解決這個問題，React 18 以前提供了一組 generic type - <code>React.FC</code> (Functional Component)，可以直接透過 react 取得，但其實是安裝 TypeScript 後，@types/react 所提供的型別，這組 type 就包含了 key children，如果在額外加入自定義的 key，就會自動幫我們 merge children &amp; custom key</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Todos: React.FC&lt;&#123; <span class="attr">items</span>: <span class="built_in">string</span>[] &#125;&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但在 React 18 開始，<code>React.FC</code> 預設就不會提供 children key 了，取而代之的是，需要透過 React 提供的另一個 type - <code>React.ReactNode</code> 來定義 children</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">  items: <span class="built_in">string</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todos: React.FC&lt;Props&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 component 的使用不一定有 children，就需要在 <code>Props</code> type children 加上 <code>?</code> 代表可有可無</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other component</span></span><br><span class="line"><span class="keyword">const</span> OtherComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Todos /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">❌</span><br><span class="line"><span class="comment">// Todos.tsx</span></span><br><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  children: React.ReactNode;</span><br><span class="line">  items: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line"><span class="comment">// Todos.tsx</span></span><br><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  children?: React.ReactNode;</span><br><span class="line">  items: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Adding-a-Data-Model"><a href="#Adding-a-Data-Model" class="headerlink" title="Adding a Data Model"></a>Adding a Data Model</h2><p>我們還可以將資料更進一步抽離出來;首先，新增一個資料夾 models(可自定義)，並在其中新增資料同名檔案 ex: Todo.ts，並在檔案中透過 JS class 定義資料與型別</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  text: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">todoText: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.text = todoText;</span><br><span class="line">    <span class="built_in">this</span>.id = <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Todo;</span><br></pre></td></tr></table></figure><p>這麼做的好處是我們可以在同一個檔案管理資料與其型別，不需要個別在資料來源與資料使用處個別定義型別</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// other component</span></span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&quot;../models/Todo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OtherComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todos = [<span class="keyword">new</span> Todo(<span class="string">&quot;Learn React&quot;</span>), <span class="keyword">new</span> Todo(<span class="string">&quot;Learn TypeScript&quot;</span>)];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Todo items=&#123;todos&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Todos.ts</span></span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&quot;../models/Todo&quot;</span>;</span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">  children?: React.ReactNode,</span><br><span class="line">  items: Todo[],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todos: React.FC&lt;Props&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Child-Component"><a href="#Child-Component" class="headerlink" title="Child Component"></a>Child Component</h2><p>如果進一步將 <code>&lt;li&gt;</code> 抽離成為一個 child component，還是可以透過指定 class key 的方式取得單獨資料屬性的型別</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Todos.ts</span></span><br><span class="line"><span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">&quot;./TodoItem&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Todos: React.FC&lt;Props&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        &lt;Todo key=&#123;item.id&#125; text=&#123;item.text&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TodoItem.ts</span></span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&quot;../models/todo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  text: Todo[<span class="string">&quot;text&quot;</span>]; <span class="comment">// get key type</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TodoItem = <span class="function">(<span class="params">props: Props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Event-Type"><a href="#Event-Type" class="headerlink" title="Event Type"></a>Event Type</h2><p>JavaScript 中包含多種 user event，React 提供了各種 event type 以滿足 event 呼叫時所需的預設型別定義，只要輸入 <code>React.Event</code> 就會出現許多 event type，如下範例是一個 form submit event，type 就是 <code>React.FormEvent</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NewTodo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event: React.FormEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;text&quot;</span>&gt;&lt;/label&gt;</span><br><span class="line">      &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;text&quot;</span> /&gt;</span><br><span class="line">      &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="react-event-type.png"></p><h2 id="refs-amp-useRef"><a href="#refs-amp-useRef" class="headerlink" title="refs &amp; useRef"></a>refs &amp; useRef</h2><p>在 React 表單中，可以透過 <code>useRef()</code> hook 來綁定欄位已取得資料</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NewTodo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todoTextInputRef = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event: React.FormEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;text&quot;</span>&gt;&lt;/label&gt;</span><br><span class="line">      &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;text&quot;</span> ref=&#123;todoTextInputRef&#125; /&gt;</span><br><span class="line">      &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但在 TypeScript 專案中寫到這裡會在 input ref 的地方出現一大串錯誤提示，原因是 TypeScript 並不知道 ref 所綁定的是什麼 HTML object，而在 HTML 中的每一個 tag 都有預設的 type object，input 就是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement">HTMLInputElement</a>，所以可以在 <code>useRef()</code> hook 上定義型別</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoTextInputRef = useRef&lt;HTMLInputElement&gt;();</span><br></pre></td></tr></table></figure><p>但仍會發現 input ref 的錯誤提示並未消失，原因是缺少預設值，這裡可以直接給定 null 作為初始值，錯誤提示就會消失了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoTextInputRef = useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>接著在 form submit 時取用欄位中的值會再次出現錯誤提示，原因是雖然我們確定在 submit event 的當下，這個 ref 一定會綁定到指定欄位，但 TypeScript 並不會進一步分析我們的程式碼，所以對它來說有可能出現 null</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event: React.FormEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> enteredText = todoTextInputRef.current.value; <span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="value-possibly-null.png"></p><p>為了解決這個問題，可以在 current 加上確認符號</p><ul><li>?: 有可能不存在，null or undefined</li><li>!: 確定存在，不會是 null or undefined</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enteredText = todoTextInputRef.current!.value;</span><br><span class="line"><span class="keyword">const</span> enteredText = todoTextInputRef.current?.value;</span><br></pre></td></tr></table></figure><h2 id="Managing-State"><a href="#Managing-State" class="headerlink" title="Managing State"></a>Managing State</h2><p>當然實際上，todo list 不會是一筆靜態的資料，而是動態改變的 state，所以是由 child component - NewTodo 透過 props event function 來改變上層的 state;當 props 是一個 function 時，可以透過 empty arrow function 作為型別來定義，就如 object 之於 {} 和 array 之於 []，其中還可以包含參數和回傳值的型別定義</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTodo</span></span><br><span class="line"><span class="keyword">type</span> Props = &#123;</span><br><span class="line">  onAddTodo: <span class="function">(<span class="params">text: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NewTodo: React.FC&lt;Props&gt; = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> enteredText = todoTextInputRef.current!.value;</span><br><span class="line"></span><br><span class="line">    props.onAddTodo(enteredText);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而在資料層就可以透過 props function 所傳回來的值對 state 進行更新，<code>useState()</code> 也是一個 generic type function，所以一樣可以針對不同 state 定義型別</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Todos <span class="keyword">from</span> <span class="string">&quot;./components/Todos&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Todo <span class="keyword">from</span> <span class="string">&quot;./models/todo&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> NewTodo <span class="keyword">from</span> <span class="string">&quot;./components/NewTodo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [todos, setTodos] = useState&lt;Todo[]&gt;([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addTodoHandler = (todoText: Todo[<span class="string">&quot;text&quot;</span>]): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    setTodos(<span class="function">(<span class="params">prevTodos: Todo[]</span>) =&gt;</span> [...prevTodos, <span class="keyword">new</span> Todo(todoText)]);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;NewTodo onAddTodo=&#123;addTodoHandler&#125; /&gt;</span><br><span class="line">      &lt;Todos items=&#123;todos&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.sitepoint.com/react-with-typescript-best-practices/">React with TypeScript: Best Practices</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generics Type</title>
      <link href="/typescript/20220904/36157/"/>
      <url>/typescript/20220904/36157/</url>
      
        <content type="html"><![CDATA[<p>在 TypeScript 的專案中，有些 function 會提供多種 type 以供不同的情境使用，但有時會因為這樣導致回傳的資料 type 不明確，所以 TypeScript 提供了一種方式來解決這個問題 </p><span id="more"></span><h2 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h2><p>一個簡單的變數如下，如果一開始就有賦值，TypeScript 就會以這個值的 type 作為這個變數的 type，這就稱為 Inference</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jerry&#x27;</span>;   <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">name = <span class="number">123</span>;   ❌</span><br></pre></td></tr></table></figure><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><p>有一個 function 的功能是任何 type array 和另一個變數整合成一個新的 array 回傳，如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAtBegining</span>(<span class="params">array: <span class="built_in">any</span>[], value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = [value, ...array];</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果給定一組 number array 和另外一個 number，理所當然的回傳一組新的 number array，但因為 inference 的原因，不論帶入的參數是什麼 type，回傳的 newArray 都會被視為 <code>any[]</code>，所以即便使用 string method <code>split</code> 也不會抱錯，這麼一來就失去使用 TypeScript 的目的了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updatedArray = insertAtBegining([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">updatedArray[<span class="number">0</span>].split(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="any-type.png"></p><p>但不用擔心，TypeScript 為了解決這種問題提供了 Generic Type 的方式為每一次使用個別判斷 Type，只需要在 function name 後加上 <code>&lt;T&gt;</code>(T 只是慣用的 Type 簡稱)，並將參數也改成這個 type，這麼一來在 number 使用 string method 就會抱錯了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertAtBegining</span>&lt;<span class="title">T</span>&gt;(<span class="params">array: T[], value: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = [value, ...array];</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updatedArray = insertAtBegining([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">updatedArray[<span class="number">0</span>].split(<span class="string">&#x27;&#x27;</span>);   ❌</span><br></pre></td></tr></table></figure><p><img src="type-error.png"></p><p>generics type 不只可以在定義時使用，在執行時也可以直接定義確保 TypeScript inference 不會有任何錯誤，也可以在資料帶入時就直接檢查</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updatedArray = insertAtBegining&lt;<span class="built_in">string</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="type-error-2.png"></p><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>另外，我們在定義任何 array type 時，透過 <code>$&#123;type&#125;[]</code> 這種寫法是一種 syntactic sugar，Array 本身就是一種 Generics Type，所以原來的寫法其實是 <code>Array&lt;$&#123;type&#125;&gt;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberArray: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// same as</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberArray: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#handbook-content">TypeScript</a></p>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Units Tests</title>
      <link href="/react/20220903/39499/"/>
      <url>/react/20220903/39499/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>單元測試是最常見的前端測試，接下來將針對 React 專案進行單元測試的開發</p><span id="more"></span><h2 id="Required-Tools-amp-Setup"><a href="#Required-Tools-amp-Setup" class="headerlink" title="Required Tools &amp; Setup"></a>Required Tools &amp; Setup</h2><p>在開始專寫測試之前，有 2 個環境條件需要滿足:</p><ul><li>執行測試並回傳測試結果 (Jest)</li></ul><p>首先，測試本身也是一段程式碼，所以當然需要有人去執行並回傳結果，在 React 專案中，目前最常見的就是 jest 這個 3rd library</p><ul><li>模擬 React</li></ul><p>Jest 並非 React 專屬的 library，他適用於所有前端專案，所以我們還需要 React 對應的 library 來模擬 React 的運作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@testing-library/jest-dom&quot;</span>: <span class="string">&quot;^5.11.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@testing-library/react&quot;</span>: <span class="string">&quot;^11.2.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;@testing-library/user-event&quot;</span>: <span class="string">&quot;^12.5.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="First-Test"><a href="#First-Test" class="headerlink" title="First Test"></a>First Test</h2><p>在 Units Tests 中，通常會將測試檔案以目標檔案命名，例如測試的目標檔案是 App.js，測試檔案就是 App.test.js，並先直接放在該檔案同一層資料夾中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">- App.js</span><br><span class="line">- App.test.js</span><br><span class="line">- setupTests.js</span><br></pre></td></tr></table></figure><p>另外，還會有一支 setupTests.js 檔案來載入 Tests library</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setupTests.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@testing-library/jest-dom&quot;</span>;</span><br></pre></td></tr></table></figure><p>當然實際上不會直接對 App.js 做測試，而是將內容封裝成不同的 component 再加以測試;這裡我們就先新增一個 Greeting.js component，當然測試檔案的名稱就是 Greeting.test.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">- components</span><br><span class="line">  | Greeting.js</span><br><span class="line">  | Greeting.test.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Greeting.js</span></span><br><span class="line"><span class="keyword">const</span> Greeting = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">      &lt;p&gt;It<span class="string">&#x27;s good to see you!&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Greeting;</span></span><br></pre></td></tr></table></figure><p>接著就是要針對這個 component 寫測試了，在測試檔案中，會包含 3 個流程，簡稱 3A:</p><ul><li>Arrange: 測試的目標檔案與環境，這個範例指的就是 Greeting.js 這個 component</li><li>Act: 預期測試的使用者行為，例如按鈕點擊，當然也可以沒有</li><li>Assert: 最後一步當然就是驗證測試的結果了</li></ul><p>在這個測試範例中，我們希望先來簡單測試 component 中是否有 Hello World 這段文字</p><h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>首先，在載入測試用的 3rd library 後，會有一個 global function <code>test</code>，其中包含兩個參數</p><ul><li>第一個參數 string: 描述這段測試</li><li>第二個參數 funcion: 測試流程</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Greeting.test.js</span></span><br><span class="line">test(<span class="string">&quot;renders Hello World as a text&quot;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="Arrange-render"><a href="#Arrange-render" class="headerlink" title="Arrange (render())"></a>Arrange (render())</h3><p>接著就是透過 <code>render()</code> function 指定 Arrange 測試的目標檔案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">&quot;@testing-library/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Greeting <span class="keyword">from</span> <span class="string">&quot;./Greeting&quot;</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;renders Hello World as a text&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Arrange</span></span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Act"><a href="#Act" class="headerlink" title="Act"></a>Act</h3><p>使用者操作行為，這裡沒有所有可以直接忽略</p><h3 id="Assert-screen"><a href="#Assert-screen" class="headerlink" title="Assert (screen)"></a>Assert (screen)</h3><p>最後是驗證的邏輯，首先，透過 <code>screen</code> 可以取得許多 function，詳情考已參考<a href="https://testing-library.com/docs/queries/about/#screen">官網</a>說明，這裡只是單純要取得文字，所以可以使用 <code>getByText()</code>，其中包含兩個參數</p><ul><li>第一個參數: 目標文字，可以單純 hardcode string 或是使用更彈性的 regular expression</li><li>第二個參數: 一個 object，可以設定搜尋條件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, screen &#125; <span class="keyword">from</span> <span class="string">&quot;@testing-library/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Greeting <span class="keyword">from</span> <span class="string">&quot;./Greeting&quot;</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;renders Hello World as a text&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Arrange</span></span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Act</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assert</span></span><br><span class="line">  screen.getByText(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="expect"><a href="#expect" class="headerlink" title="expect()"></a>expect()</h4><p>最後會透過 <code>expect()</code> 指定測試的條件，也就是上方透過 <code>screen.getByText()</code> 所指定的文字，最後再透過 <code>toBeInTheDocument()</code> 表示須出現在目標測試檔案中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;renders Hello World as a text&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Arrange</span></span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Act</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assert</span></span><br><span class="line">  <span class="keyword">const</span> helloWorldElement = screen.getByText(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  expect(helloWorldElement).toBeInTheDocument();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Run-Test"><a href="#Run-Test" class="headerlink" title="Run Test"></a>Run Test</h3><p>在撰寫完測試檔案後，就是要來實際執行這段測試了，在 package.json 中，會因為安裝了 test 3rd libraries 而新增了一個指令 test</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 cmd 執行後會出現以下畫面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="run-test.png"></p><p>包含測試的目標檔案、測試的描述(test function 第一個參數)和測試的結過，如果如上的結果是失敗的，就會包含失敗的原因</p><p>那麼為什麼結果會失敗呢? 原因是 <code>getByText()</code> 預設是完全符合才算成功，這裡多了一個驚嘆號所以就不完全符合了，可以改成 regular expression、加上驚嘆號或是在後方的測試條件改成不須完全符合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更改測試條件不須完全符合</span></span><br><span class="line"><span class="keyword">const</span> helloWorldElement = screen.getByText(<span class="string">&quot;Hello World&quot;</span>, &#123; <span class="attr">exact</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure><p>而在測試執行後，會持續監聽測試內容，所以只要修改測試條件後，結果也會即時顯示</p><p><img src="run-test-success.png"></p><h2 id="Grouping-Tests-Together-With-Test-Suits"><a href="#Grouping-Tests-Together-With-Test-Suits" class="headerlink" title="Grouping Tests Together With Test Suits"></a>Grouping Tests Together With Test Suits</h2><p>在上方的測試結果中，會發現包含兩個狀態 Tests &amp; Tests Suits，Tests 單純是這個測試的結果，Tests Suits 的出現是為了解決的一個專案中，可能會有許多 Units Tests，所以如果是出自同一個 component 或是功能，可以透過 Tests Suits 將之設定為群組</p><h3 id="describe"><a href="#describe" class="headerlink" title="describe()"></a>describe()</h3><p>將多個 Test 群組就需要透過 <code>describe()</code> 將欲群組的測試包起來</p><ul><li>第一個參數: 同樣是測試的描述</li><li>第二個參數: 將測試包起來的 function</li></ul><p>經 Tests Suits 改寫後結果如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Greeting.test.js</span></span><br><span class="line">describe(<span class="string">&quot;Greeting Component&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;renders Hello World as a text&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Arrage</span></span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    <span class="keyword">const</span> helloWorldElement = screen.getByText(<span class="string">&quot;Hello World&quot;</span>, &#123; <span class="attr">exact</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    expect(helloWorldElement).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Testing-User-Ineraction-amp-State"><a href="#Testing-User-Ineraction-amp-State" class="headerlink" title="Testing User Ineraction &amp; State"></a>Testing User Ineraction &amp; State</h2><p>當然實際測試不會只是這麼單純的內容，通常還會加入使用者操作以涵蓋更多使用情境，這裡我們先將 component 改寫成當 button 點擊後，會改變顯示的內容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Greeting.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Greeting = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [changedText, setChangedText] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeTextHanlder = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setChangedText(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">      &#123;!changedText &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It&#x27;s good to see you!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">      &#123;changedText &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Changed<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;button onClick=&#123;changeTextHanlder&#125;&gt;Change Text!&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>測試情境就可以區分成按鈕點擊前與點擊後，第一種情境是在點擊前，很單純的不需要使用者操作行為，直接判斷點擊錢是否出現預期文字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Greeting.test.js</span></span><br><span class="line">describe(<span class="string">&quot;Greeting component&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&#x27;renders &quot;good to see you&quot; if button was NOT clicked&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Arrenge</span></span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    <span class="keyword">const</span> outputElement = screen.getByText(<span class="string">&quot;good to see you&quot;</span>, &#123; <span class="attr">exact</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    expect(outputElement).toBeInTheDocument();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第二種就需要判斷使用者在操作後所顯示的內容了，所以需要 import 另外一個 object <code>useEvent</code>，其中包含許多 user event，在這次的範例就是 button click，可以透過另一個 function <code>getByRole()</code> 指定 HTML element</p><p>Assert 的部分因為在點擊後，這個 element 就會消失，因此可以改使用 <code>queryByText()</code>，在這個 element 不在時會回傳 null，<code>toBeInTheDocument()</code> 也可以改成 <code>toBeNull()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;does not renders &quot;good to see you&quot; if the button was clicked&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Arrange</span></span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Act</span></span><br><span class="line">  <span class="keyword">const</span> buttonElement = screen.getByRole(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">  userEvent.click(buttonElement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assert</span></span><br><span class="line">  <span class="keyword">const</span> outputElement = screen.queryByText(<span class="string">&quot;good to see you&quot;</span>, &#123; <span class="attr">exact</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  expect(outputElement).toBeNull();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Testing-Connected-Components"><a href="#Testing-Connected-Components" class="headerlink" title="Testing Connected Components"></a>Testing Connected Components</h2><p>隨著專案功能不斷擴大，component 會因應需求不斷切分，所以常見的 component 不會只有一層，如果上方動態顯示的文字改由一層 component 如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output.js</span></span><br><span class="line"><span class="keyword">const</span> Output = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Greeting.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Output <span class="keyword">from</span> <span class="string">&quot;./Output&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Greeting = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [changedText, setChangedText] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeTextHanlder = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setChangedText(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">      &#123;!changedText &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Output</span>&gt;</span>It&#x27;s good to see you!<span class="tag">&lt;/<span class="name">Output</span>&gt;</span></span>&#125;</span><br><span class="line">      &#123;changedText &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Output</span>&gt;</span>Changed<span class="tag">&lt;/<span class="name">Output</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;button onClick=&#123;changeTextHanlder&#125;&gt;Change Text!&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果只是單純的顯示應用，上方所寫的測試內容可以完全不需要更改，但如果 component 邏輯變得更加複雜，就會將 component 的測試在抽離出去，如 Output.test.js</p><h2 id="Testing-Asynchronous-Code"><a href="#Testing-Asynchronous-Code" class="headerlink" title="Testing Asynchronous Code"></a>Testing Asynchronous Code</h2><p>在前端開發中，多數資料並非靜態，而是透過非同步的方式由 server 傳送再進一步顯示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Async.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Async = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [posts, setPosts] = useState([]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>)</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">      .then(<span class="function">(<span class="params">data</span>) =&gt;</span> setPosts(data));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;posts.map(<span class="function">(<span class="params">post</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; render, screen &#125; <span class="keyword">from</span> <span class="string">&quot;@testing-library/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Async <span class="keyword">from</span> <span class="string">&quot;./Async&quot;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;Async component&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;renders posts if request succeeds&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Async</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> listItemElements = screen.getAllByRole(<span class="string">&quot;listitem&quot;</span>);</span><br><span class="line">    expect(listItemElements).not.toHaveLength(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在撰寫測試時，如果以非同步資料顯示作為測試的結果就會出錯，因為測試程式碼並不知道這筆資料是會延遲一段時間後才送達，所以這裡的 <code>getAllByRole()</code> 需要改成 <code>findAllRole()</code>，差別在於 <code>findAllRole()</code> 會回傳一個 promise，期待二個參數同樣為測試條件，第三個參數為延遲秒數，預設為 1 秒;而 test function 也需要改成 async function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&quot;Async component&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;renders posts if request succeeds&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Async</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> listItemElements = <span class="keyword">await</span> screen.findAllByRole(<span class="string">&quot;listitem&quot;</span>);</span><br><span class="line">    expect(listItemElements).not.toHaveLength(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Working-with-Mocks"><a href="#Working-with-Mocks" class="headerlink" title="Working with Mocks"></a>Working with Mocks</h2><p>上述對於非同步事件的測試看似一切正常了，但這裡有一個問題是，在執行測試時，其時會反覆執行 component 中的 function，當遇到非同步事件時，除了會不斷產生 request 之外，更重要的是如果這個 request 是對資料進行新增或刪除等動作，測試的過程就不會斷更改資料庫的資料</p><p>很顯然的，這不是我們期待的行為，Units Tests 的目的是測試 component 行為，而不是測試 Web API (fetch) 或其他 server API;Jest 為了解決這個問題，提供了在執行測試時，取代這些行為與資料的 mocks</p><p>首先，將 <code>window.fetch()</code> 取代為 <code>ject.fn()</code>，並呼叫 <code>mockResolvedValueOnce()</code> 定義 resolved 後所接收到的資料，透過 <code>fetch</code> API 所接收到的資料會先以 async function <code>json()</code> 將資料轉為 JS object，其中所回傳的資料就是我們可以自由定義的 mock data</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Async.test.js</span></span><br><span class="line">describe(<span class="string">&quot;Async component&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;renders posts if request succeeds&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="built_in">window</span>.fetch = jest.fn();</span><br><span class="line">    <span class="built_in">window</span>.fetch.mockResolvedValueOnce(&#123;</span><br><span class="line">      json: <span class="keyword">async</span> () =&gt; [&#123; <span class="attr">id</span>: <span class="string">&quot;p1&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;First post&quot;</span> &#125;],</span><br><span class="line">    &#125;);</span><br><span class="line">    render(<span class="xml"><span class="tag">&lt;<span class="name">Async</span> /&gt;</span></span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> listItemElements = <span class="keyword">await</span> screen.findAllByRole(<span class="string">&quot;listitem&quot;</span>);</span><br><span class="line">    expect(listItemElements).not.toHaveLength(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>透過這樣的改寫後，在執行測試時，就不會真的送出 request，而且還可以準備多組假資料以模擬不同的情境</p><h3 id="Initialize-Test-Environment"><a href="#Initialize-Test-Environment" class="headerlink" title="Initialize Test Environment"></a><a href="https://create-react-app.dev/docs/running-tests/#initializing-test-environment">Initialize Test Environment</a></h3><p>上述不希望在執行測試時被出發的事件，可以在根目錄上建立一個 src/setupTests.js 的檔案，這支檔案會在執行所有<strong>測時前先被執行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/setupTests.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> localStorageMock = &#123;</span><br><span class="line">  getItem: jest.fn(),</span><br><span class="line">  setItem: jest.fn(),</span><br><span class="line">  removeItem: jest.fn(),</span><br><span class="line">  clear: jest.fn(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">global</span>.localStorage = localStorageMock;</span><br></pre></td></tr></table></figure><p>而如果在新增 src/setupTests.js 檔案前就執行 <code>eject</code> (scripts in package.json)，package.json 就不會建立任何關聯到這支檔案上，那麼就需要手動補上以下設定:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&quot;jest&quot;: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &quot;setupTestFrameworkScriptFile&quot;: &quot;&lt;rootDir&gt;/src/setupTests.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://testing-library.com/docs/queries/about/#screen">@testing-library/react</a><br><a href="https://jestjs.io/">jest</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Units Tests </tag>
            
            <tag> Jest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Testing</title>
      <link href="/react/20220903/40383/"/>
      <url>/react/20220903/40383/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>對於測試，一開始可能會有個疑問是，在程式碼開發時，不是就同時一時在測試了嗎 ? 為什麼還會需要特別測試 ?</p><p>前端測試其實是透過撰寫一段程式碼，透過他來”自動”測試實際開發所需的程式碼，接下來進一步了解何謂前端測試</p><span id="more"></span><h2 id="What-amp-Why"><a href="#What-amp-Why" class="headerlink" title="What &amp; Why?"></a>What &amp; Why?</h2><p>在一般傳統開發時，其實在撰寫程式碼的當下就已經同步在做測試了，但這種測試方式其實是開發者以使用者的角度去做測試，往往會忽略其他的操作情境，尤其是如果有其他功能的調整，可能也只針對當下的區塊測試，一時之間也難以涵蓋所有系統關聯</p><p>為了解決這種開發者片面的測試方式，前端自動化測試因應而生，做事是透過額外撰寫一段程式碼，這段程式碼會自動測試實際產品的程式碼，並在每一次都會對流程做完整的測試，以涵蓋所有操作情境</p><h2 id="Understanding-Defferent-Kinds-of-Tests"><a href="#Understanding-Defferent-Kinds-of-Tests" class="headerlink" title="Understanding Defferent Kinds of Tests"></a>Understanding Defferent Kinds of Tests</h2><p>前端自動化測試 Automated Tests 又根據測試的幅度分成以下 3 種:</p><h3 id="Uints-Tests-單元測試"><a href="#Uints-Tests-單元測試" class="headerlink" title="Uints Tests 單元測試"></a>Uints Tests 單元測試</h3><p>單元測試 Units Tests 顧名思義就是以最小單位來對程式碼進行測試，涵蓋的範圍通常也只侷限於單一的獨立功能，也是最常見的自動化測試，一個專案可能因應功能需求包含許多 Units Tests</p><h3 id="Integration-Tests-整合測試"><a href="#Integration-Tests-整合測試" class="headerlink" title="Integration Tests 整合測試"></a>Integration Tests 整合測試</h3><p>整合測試 Integration Tests 相對於單元測試所涵蓋的範圍就會在大一些，會組合多個單一的獨立功能，對整體的連動功能進行測試，所以相對單元測試在專案中的數量也會比較少一些</p><h3 id="End-to-End-E2E-Tests"><a href="#End-to-End-E2E-Tests" class="headerlink" title="End-to-End (E2E) Tests"></a>End-to-End (E2E) Tests</h3><p>所謂的 End-to-End (E2E) Tests 指的就是端點(使用者)到端點(系統)的測試，實際上就是模擬使用者的操作流程做自動化測試，所以 QA 直接透過滑鼠操作的測試就是人工的 E2E Tests</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deploying React Apps</title>
      <link href="/react/20220821/61941/"/>
      <url>/react/20220821/61941/</url>
      
        <content type="html"><![CDATA[<p>在過去的課程中，我們都是透過 Node.js 啟動一個 local server，對專案進行即時的開發，實際上大部的開發時間也都是如此，但最後我們終究是是要將開發的專案部屬到真正的 server 以供其他使用者使用，接下來將探討 React Apps 從開發到部屬得流程</p><span id="more"></span><h2 id="Deploying-Steps"><a href="#Deploying-Steps" class="headerlink" title="Deploying Steps"></a>Deploying Steps</h2><p>在功能開發完成後，會進行以下步驟以完成正式上線:</p><ul><li><p>Test Code: 對功能進行測試，不管是人為測試又或是撰寫的測試，確保功能正盛運作</p></li><li><p>Optimize Code: 程式碼的優化，其中包含 lazy loading 提高使用者體驗與網站效能</p></li><li><p>Build App for Production: 不管使用的開發工具或框架是什麼，瀏覽器終究只看得懂 HTML、CSS &amp; JavaScript，所以需要將程式碼打包成這些格式</p></li><li><p>Upload Production Code to Server: 上傳這些打包後的程式碼到實際的 server</p></li><li><p>Configure Server: 符合需求的 server 相關設定</p></li></ul><h2 id="Adding-Lazying-Loading"><a href="#Adding-Lazying-Loading" class="headerlink" title="Adding Lazying Loading"></a>Adding Lazying Loading</h2><p>React.lazy(() =&gt; import(<code>$&#123;path&#125;</code>))</p><p>lazying loading 所要優化的重點就是，當使用者開啟網頁時，只載入頁面必要的程式碼，藉此提高網站效能，因為如果沒有特別作這方面的優化，通常是取得所有的程式碼後，再根據 route 決定要顯示的頁面需要取用哪一段程式碼</p><p>一段基本的 Rotuer 寫法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch, Redirect &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AllQuotes <span class="keyword">from</span> <span class="string">&quot;./pages/AllQuotes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> NewQuotes <span class="keyword">from</span> <span class="string">&quot;./pages/NewQuotes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> QuotesDetail <span class="keyword">from</span> <span class="string">&quot;./pages/QuotesDetail&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&quot;./pages/NotFound&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&quot;./components/layout/Layout&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> LoadingSpinner <span class="keyword">from</span> <span class="string">&quot;./components/UI/LoadingSpinner&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/&quot;</span> exact&gt;</span><br><span class="line">          &lt;Redirect to=<span class="string">&quot;/quotes&quot;</span> /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/quotes&quot;</span> exact&gt;</span><br><span class="line">          &lt;AllQuotes /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/quotes/:quoteId&quot;</span>&gt;</span><br><span class="line">          &lt;QuotesDetail /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/new-quote&quot;</span>&gt;</span><br><span class="line">          &lt;NewQuotes /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;*&quot;</span>&gt;</span><br><span class="line">          &lt;NotFound /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h3 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy()"></a>React.lazy()</h3><p>而在 React Router 的專案中要加入 lazy loading 也非常容易，React 提供了一個 function <code>lazy()</code>，其中的參數為 callback function，回傳透過 JavaScript <code>import</code> 取得路徑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before lazy loading</span></span><br><span class="line"><span class="keyword">import</span> AllQuotes <span class="keyword">from</span> <span class="string">&#x27;./pages/AllQuotes&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy loading</span></span><br><span class="line"><span class="keyword">const</span> AllQuotes = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./pages/AllQuotes&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="Suspense-Component"><a href="#Suspense-Component" class="headerlink" title="Suspense Component"></a>Suspense Component</h3><p>但如果只做到這一步，會發現在切換 route 後畫面沒有顯示，開啟 devtools 會看到以下 error log</p><p><img src="without-Suspense.png"></p><p>原因是加入 lazying loading 後，畫面所需的程式碼都是在切換 route 後才取得，所以需要有暫時的畫面來填補這段取得資料的空窗期，React 提供了 <code>Suspense</code> component，來解決這個問題，其中的 <code>fallback</code> attribute 可議值大入暫定頁面的 JSX，就會在這段取得資料的空窗期渲染出來</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;Suspense</span><br><span class="line">        fallback=&#123;</span><br><span class="line">          &lt;div className=<span class="string">&quot;centered&quot;</span>&gt;</span><br><span class="line">            &lt;LoadingSpinner /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/&quot;</span> exact&gt;</span><br><span class="line">          &lt;Redirect to=<span class="string">&quot;/quotes&quot;</span> /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">        ...some routes <span class="keyword">else</span></span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">加入 `</span>Suspense<span class="string">` 後，頁面就可以正常呈現了，打開 devtools Network 會發現，每當切換 route 取得當下所需的程式碼時，會取得一個 chunk.js 的檔案，這就是加入 lazy loading 後，我們的程式碼會被分割成許多區塊，只在必要時載入</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![](chunk.png)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Building The Code For Production</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">不論是原生專案、Vue 或是其他框架，有透過 npm 管理過專案的開發者就不會對 package.json scripts 太陌生，create-react-app 同樣基於這樣的環境基礎來建立，開啟 package.json 就會有幾組預設指令，如下:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>json</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>start</code> 指令已經在每次啟動 local server 時反覆執行過了，<code>build</code> 就是將 React project打包成 HTML、CSS &amp; JavaScript 所需的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm build</span><br></pre></td></tr></table></figure><p>執行後，會發現專案中出現了 build 資料夾，打開後會有許多原生檔案，這些就是 React project 打包後的產物，也是最後要放到實際 server 的檔案;另外，在打包後，就不要再對這些檔案進行修改了，因為每次執行打包指令後，這些檔案都會被再次編譯並覆蓋，所以如果有要調整的部分只能回到原有檔案些改後再次編譯</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://reactrouter.com/docs/en/v6/upgrading/v5">React Router</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Upgrading to React Router v6</title>
      <link href="/react/20220817/188/"/>
      <url>/react/20220817/188/</url>
      
        <content type="html"><![CDATA[<p>在先前的課程中，都是以 React Router v5 作為範例，但在這篇筆記紀錄的當下，React Router 已經推出 v6 了，所以接下來將升級 v5 的專案至 v6，並說明其所帶來的好處</p><span id="more"></span><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>不論是否已經安裝 v5 的專案，要升級到 v6 同樣非常簡單，只要執行下列指令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i react-router-dom@6</span><br></pre></td></tr></table></figure><h2 id="v5-Switch-gt-v6-Routes"><a href="#v5-Switch-gt-v6-Routes" class="headerlink" title="v5 Switch =&gt; v6 Routes"></a>v5 Switch =&gt; v6 Routes</h2><p>在 v5 中，會透過 <code>Switch</code> Component 包覆所有 <code>Route</code> 以解決渲染出其中所有符合條件的 <code>Route</code>，v6 中則改以 <code>Routes</code> 取代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// v5</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;Route/&gt;</span><br><span class="line">        &lt;Route&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;Route/&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v6</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Routes&gt;</span><br><span class="line">        &lt;Route&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;Route/&gt;</span><br><span class="line">        &lt;Route&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;Route/&gt;</span><br><span class="line">      &lt;/Routes&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Route-child-component-gt-element-JSX-component"><a href="#Route-child-component-gt-element-JSX-component" class="headerlink" title="Route child component -&gt; element={JSX component}"></a>Route child component -&gt; element={JSX component}</h2><p>在 v5 <code>Route</code> 中，會將欲在這個路徑下顯示的 Component 作為 child component，v6 則改以 <code>element</code> attribute 取代，但這裡要特別注意的是，不是單純放入 component，而是放入 component JSX</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v5</span></span><br><span class="line">&lt;Route to=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">  &lt;Welcome /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v6</span></span><br><span class="line">&lt;Route to=<span class="string">&quot;/welcome&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> /&gt;</span></span>&#125;&gt;</span><br></pre></td></tr></table></figure><h2 id="remove-exact"><a href="#remove-exact" class="headerlink" title="remove exact"></a>remove exact</h2><p><code>exact</code> attribute 則被移除了，取而代之的是，v6 中有更好的演算法來判斷最佳路徑，所以如果有以下路徑，在進到 <code>/products/p1</code> 時，也不會渲染 <code>/products</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/products&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Products</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/products/:productId&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">ProductDetail</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>但如果希望同時被渲染，可以在後方加上 <code>/*</code>，就會出現和 v5 不加 <code>exact</code> 同樣的結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/products/*&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Products</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/products/:productId&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">ProductDetail</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>另外，v6 中更好的演算法也讓我們不用擔心 <code>Route</code> 的放置順序，如果出現下列寫法，並選擇到 <code>/products/edit</code>，也不會因為由上而下的緣故選擇 <code>/products/:productId</code>，而是選擇最符合結果的選項</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/products/:productId&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">ProductDetail</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/products/edit&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">ProductEdit</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="Link-amp-NavLink"><a href="#Link-amp-NavLink" class="headerlink" title="Link &amp; NavLink"></a>Link &amp; NavLink</h2><p>在 <code>Link</code> component 的使用上並沒有差異，但在 NavLink 的使用上有些許的差異是，當我們使用客製 class 時，在 v5 使用的是 <code>activeClassName</code>，但在 v6 被移除了，取而代之的是使用一般的 <code>className</code>，但其中的值為 function，function 第一個參數為 React Router 所提供的 <code>navData</code>(名稱自訂)，其中的 <code>isActive</code> 如果在路徑有被正常指向就會是 <code>true</code>，所以寫法差異如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v5</span></span><br><span class="line">&lt;NavLink activeClassName=&#123;classes.active&#125; to=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">  Welcome</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v6</span></span><br><span class="line">&lt;NavLink className=&#123;<span class="function">(<span class="params">navData</span>) =&gt;</span> nvaData.isActive ? classes.active : <span class="string">&#x27;&#x27;</span>&#125; to=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">  Welcome</span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><h2 id="Redirect-gt-Navigate"><a href="#Redirect-gt-Navigate" class="headerlink" title="Redirect -&gt; Navigate"></a>Redirect -&gt; Navigate</h2><p>v5 中，可以透過 <code>Redirect</code> 將網址重新導向期待的頁面，在 v6 中則由 <code>Navigate</code> 所取代，但仍然需要改寫到 element attribute 之中，完整的寫法可以再補上 <code>replace</code> attribute</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v5</span></span><br><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">  &lt;Redirect to=<span class="string">&quot;/welcome&quot;</span> /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v6</span></span><br><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">replace</span> <span class="attr">to</span>=<span class="string">&quot;/welcome&quot;</span> /&gt;</span></span>&#125;/&gt;</span><br></pre></td></tr></table></figure><h2 id="Nested-Route"><a href="#Nested-Route" class="headerlink" title="Nested Route"></a>Nested Route</h2><p>在 v5 Nested Route 的寫法就是直接在 Component 中加上一組 <code>Route</code>，但在 v6 中，<code>Route</code> 無法在沒有 <code>Routes</code> 的情況下單獨出現</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v5</span></span><br><span class="line">&lt;Route path=<span class="string">&quot;/welcome/new-user&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Welcome, <span class="keyword">new</span> user!&lt;/p&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v6</span></span><br><span class="line">&lt;Routes&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/welcome/new-user&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome, new user!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line">&lt;/Routes&gt;</span><br></pre></td></tr></table></figure><p>另外，在 v6 中，外層 <code>Route</code> 如果還有內層 <code>Route</code>，就需要在 url 後方加上 <code>/*</code>，好處是內層的 url 就不用再重複外層的 url，只要寫上附加的 url 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Routes&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/welcome/*&quot;</span>&gt;</span><br><span class="line">    &lt;/Routes&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v5</span></span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Link to=<span class="string">&quot;/welcome/new-user&quot;</span>&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/welcome/new-user&quot;</span>&gt;</span><br><span class="line">      &lt;p&gt;Welcome, <span class="keyword">new</span> user!&lt;/p&gt;</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v5</span></span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Link to=<span class="string">&quot;/new-user&quot;</span>&gt;</span><br><span class="line">    &lt;Routes&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/new-user&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome, new user!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line">    &lt;/Routes&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="改寫"><a href="#改寫" class="headerlink" title="改寫"></a>改寫</h3><p>v6 還提供了另一種 Nested Route 的寫法，可以將所有 Nested Route 寫在一起</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Routes&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/welcome/*&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> /&gt;</span></span>&#125;&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;new-user&quot;</span> element=&#123;<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome, new user!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Routes&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這裡還有一個問題是，Child Route element 不知道應該要放在哪裡，所以 React Router 提供了另一個 component - <code>Outlet</code> 來指定放置的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Welcome = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h1&gt;The Welcome Page&lt;/h1&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;new-user&quot;</span>&gt;New User&lt;/Link&gt;</span><br><span class="line">      &lt;Outlet /&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這兩種寫法完全由個人喜好自行決定</p><h2 id="useHistory-gt-useNavigate"><a href="#useHistory-gt-useNavigate" class="headerlink" title="useHistory() -&gt; useNavigate()"></a>useHistory() -&gt; useNavigate()</h2><p>在 v5 中，如果是依賴程式在滿足某種條件下自動切換 route，可以透過 <code>useHistory()</code> hook 來改變 route，v6 中則由 <code>useNavigate()</code> 取代，而且不需要 <code>push</code> function，可以直接於回傳的 function 所執行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v5</span></span><br><span class="line"><span class="keyword">const</span> history = useHistory();</span><br><span class="line">history.push(<span class="string">&#x27;/welcome&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// v6</span></span><br><span class="line"><span class="keyword">const</span> navigate = useNavigate();</span><br><span class="line">navigate(<span class="string">&#x27;welcome&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="Prompt-gt-❌"><a href="#Prompt-gt-❌" class="headerlink" title="Prompt -&gt; ❌"></a>Prompt -&gt; ❌</h2><p>在 v5 中，<code>Prompt</code> component 提供了一層確認 alert 作為使用者操作行為的防呆機制，但在 v6 中被移除了，只能自行撰寫 component 來維持這個機制，在未來可能會被重新加回來也說不定</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://reactrouter.com/docs/en/v6/upgrading/v5">React Router</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> React Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>More flexible routing code</title>
      <link href="/react/20220814/33177/"/>
      <url>/react/20220814/33177/</url>
      
        <content type="html"><![CDATA[<p>在某些需求下，除了一層 route 切換主頁面之外，可能還會再有內層 route 切換內部元件，形成 Nested Route，但為了避免改動上層路徑名稱就要接連改動下層的名稱，React Router 提供了更彈性的方式取得當前路徑參數，避免 hard code 的情況發生</p><span id="more"></span><h2 id="useRouteMatch"><a href="#useRouteMatch" class="headerlink" title="useRouteMatch()"></a><a href="https://github.com/Jerry-Yeh/-React-The-Complete-Guide-Section20-2/commit/3baec000822ab97ea9955aed0b572cf723dcd0a9">useRouteMatch()</a></h2><p>React Router 提供了另一了 hook - <code>useRouteMatch()</code>，這個 hook 所回傳的 object 包含以下 key-value pair</p><ul><li>isExact: 是否為 <code>exact</code> 路徑完全符合的條件</li><li>params: 以 object 列出所有 param</li><li>path: 可直接提供 <code>Route path</code> 的路徑，ex: /route/:id</li><li>url: 將 path param 轉成取得的值，可直接提供 <code>Link to</code> 路徑，ex: /route/q1</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouteMatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someChildRoute = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> match = useRouteMatch();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Route path=&#123;match.path&#125; exact&gt;</span><br><span class="line">        &lt;Link to=&#123;<span class="string">`<span class="subst">$&#123;match.url&#125;</span>/comments`</span>&#125;&gt;</span><br><span class="line">          Load Comments</span><br><span class="line">        &lt;/Link&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.path&#125;</span>/comments`</span>&#125;&gt;</span><br><span class="line">        &lt;Comments /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="useRouteMatch-vs-useLocation"><a href="#useRouteMatch-vs-useLocation" class="headerlink" title="useRouteMatch() vs useLocation()"></a>useRouteMatch() vs useLocation()</h2><p>相較於 <code>useRouteMatch()</code>，<code>useLocation()</code> 提供了當下的完整路徑和 query params，適用於需要完整路徑或附帶參數的時候;<code>useRouteMatch()</code> 則較常用於 Nested Route，因為回傳的是最接近的匹配路徑或其 Parent Route</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://reactrouter.com/">React Router</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> React Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Route Params</title>
      <link href="/react/20220813/46531/"/>
      <url>/react/20220813/46531/</url>
      
        <content type="html"><![CDATA[<p>在實際專案的需求中，通常不會那麼單純一個路徑就顯示一種 component 樣式，常見的情況會由相同的 component 帶入不同的資料來顯示不同的內容，因此，在同一個 route 就需要透過 param 來判斷資料的來源</p><span id="more"></span><h2 id="Adding-Dynamic-Rotues-with-Params"><a href="#Adding-Dynamic-Rotues-with-Params" class="headerlink" title="Adding Dynamic Rotues with Params"></a>Adding Dynamic Rotues with Params</h2><p>首先，建立一個顯示不同產品的 component，並註冊於 route</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/product-detail&quot;</span>&gt;</span><br><span class="line">        &lt;ProductDetail /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這裡會出現一個問題是，當切換到 product-detail 時，沒有提供其他方式以辨別傳入的資料，這時候就可以在 <code>path</code> 後方加入讓一參數，並透過冒號<code>:</code> 已作區別</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/product-detail/:productId&quot;</span>&gt;</span><br><span class="line">        &lt;ProductDetail /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Extracting-Route-Params"><a href="#Extracting-Route-Params" class="headerlink" title="Extracting Route Params"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section20/commit/7317eb5f573ebaea9f8874f98c03c6b1ed3009ec">Extracting Route Params</a></h2><p>有了參數定義後，接下來就是要在 component 內取得參數，只要透過 <code>useParams()</code> hook，就可以取得定義在 url 上的參數，其回傳的是一個 object，key 就是我們自定義的名稱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ProductDetail = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> params = useParams();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;params.productId&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Using-“Switch”-and-“exact”-For-Configuring-Routes"><a href="#Using-“Switch”-and-“exact”-For-Configuring-Routes" class="headerlink" title="Using “Switch” and “exact” For Configuring Routes"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section20/commit/7317eb5f573ebaea9f8874f98c03c6b1ed3009ec">Using “Switch” and “exact” For Configuring Routes</a></h2><p>在程式中設計路徑時，如果有類似這種多層結構的 UI 操作，可以仿照資料結構路徑的方式，沿用上一層的名稱，並在後方加上對應參數，所以 products 與 product-detail 的路徑就可以改成以下命名方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">          &lt;Welcome /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/products&quot;</span>&gt;</span><br><span class="line">          &lt;Products /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">        &lt;Route path=<span class="string">&quot;/products/:productId&quot;</span>&gt;</span><br><span class="line">          &lt;ProductDetail /&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但轉換到畫面一看會發現，當我們點擊切換到子路徑 <code>/products/prodcutId</code> ，Products 和 ProdcutDetail component 都被渲染出來了，原因為 React 的規則是只要包含在內就算符合，不需要完全相同</p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>為了解決這個問題，react-router 提供了另外一個 component - <code>Switch</code>，只要將這個 component 包覆所有目標 <code>Route</code>，就只會渲染最先符合的 component</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch &#125; <span class="keyword">from</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">            &lt;Welcome /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/products&quot;</span>&gt;   <span class="comment">// 我先符合的</span></span><br><span class="line">            &lt;Products /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/products/:productId&quot;</span>&gt;   <span class="comment">// 其實我才完全符合</span></span><br><span class="line">            &lt;ProductDetail /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h3><p>但很顯然的這還是沒有完全符合我們的需求，因為不論切換到哪個 <code>/products/:productId</code>，因為由上而下判斷的緣故，<code>/products</code> 都會優先符合，最直覺的作法是把 <code>/products/:produdctId</code> 提升到上方</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">            &lt;Welcome /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/products/:productId&quot;</span>&gt;   <span class="comment">// 我被提升了</span></span><br><span class="line">            &lt;ProductDetail /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/products&quot;</span>&gt;</span><br><span class="line">            &lt;Products /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 react-router 有一個更好的方法是在 component 加上 <code>exact</code>，代表需要完全符合該路徑才算通過，因為實際在開發時可能會有更多種路徑，如果還要明確地由上而下判斷排列可能容易搞混</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">            &lt;Welcome /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/products&quot;</span> exact&gt;   <span class="comment">// 我加在這裡</span></span><br><span class="line">            &lt;Products /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/products/:productId&quot;</span>&gt;</span><br><span class="line">            &lt;ProductDetail /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Working-with-Nested-Routes"><a href="#Working-with-Nested-Routes" class="headerlink" title="Working with Nested Routes"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section20/commit/5cb219a92ae2d62cd4d3ef69938cb5da521c0fca">Working with Nested Routes</a></h2><p><code>Route</code> 除了可以用整個主頁面的切換上，還可以判斷不同的情況在頁面之中切換子頁面</p><p>本來就有一個 Welcome 頁面了，這裡我們希望如果是第一次拜訪網頁的使用者可以額外顯示其他文案，這時候就可以透過加上一層 child route 滿足這個需求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">      &lt;h1&gt;The Welcome Page&lt;/h1&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/welcome/new-user&quot;</span>&gt;</span><br><span class="line">        &lt;p&gt;Welcome, <span class="keyword">new</span> user!&lt;/p&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Redirecting-The-User"><a href="#Redirecting-The-User" class="headerlink" title="Redirecting The User"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section20/commit/a299785cbce6323a937e697d53b6c5f9a94f759f">Redirecting The User</a></h2><p>雖然我們定義了許多路徑，但使用者可能會沒有輸入路徑導致沒有畫面顯示，而為了避免這種情況發生，我們可以定義一個預設頁面，凡是沒有輸入路徑就會將路徑自動導向這裡</p><p>react-router 提供了另一個 component <code>Redirect</code>，可以透過它指向預設頁面，但這裡需要特別注意的是，根路徑因為滿足任何路徑的條件，所以如果沒有加上 <code>exact</code>，無論 url 違和都會導向預設頁面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route, Switch, Redirect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/&quot;</span> exact&gt;</span><br><span class="line">            &lt;Redirect to=<span class="string">&quot;/welcome&quot;</span>&gt;&lt;/Redirect&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          &lt;Route path=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">            &lt;Welcome /&gt;</span><br><span class="line">          &lt;/Route&gt;</span><br><span class="line">          ...</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Preventing-Possibly-Unwanted-Route-Transition-with-the-“Prompt”-Component"><a href="#Preventing-Possibly-Unwanted-Route-Transition-with-the-“Prompt”-Component" class="headerlink" title="Preventing Possibly Unwanted Route Transition with the “Prompt” Component"></a>Preventing Possibly Unwanted Route Transition with the “Prompt” Component</h2><p>在許多頁面跳轉上的操作時，為了避免使用者不小心觸發跳轉機制導致當前頁面的資料遺失，通常會在 UI 加上基本的防呆確認機制，React Router 就提供了一個 component - <code>Prompt</code> 讓使用者再次確認是否真的要執行頁面的跳轉已放棄當前頁面的資料</p><p>首先，在一表單 <code>form</code> 上，新增一個 event <code>onFocus</code> 確認使用者是否使用過表單欄位，接著 import <code>Prompt</code> component，其中有兩個參數，如下:</p><ul><li>when: 判斷何時顯示這個 component</li><li>message: component 中所顯示的文案，其中的質為 function，第一個參數為 <code>location</code> object，可以透過它取得當下路徑資訊</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, Fragment &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isEntering, setIsEntering] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitFormHandler = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formFocusedHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setIsEntering(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Prompt</span><br><span class="line">        when=&#123;isEntering&#125;</span><br><span class="line">        message=&#123;<span class="function">(<span class="params">location</span>) =&gt;</span></span><br><span class="line">          <span class="string">&quot;Are you sure you want to leave? All your entered data will be lost!!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;form onFocus=&#123;formFocusedHandler&#125; onSubmit=&#123;submitFormHandler&#125;&gt;</span><br><span class="line">        ...some input</span><br><span class="line">        &lt;button&gt;&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>當表單使用過 (isEntering == true)，觸發任何會跳轉的動作後，就會出現一個 alert，其中的文字就是 <code>message</code> 所回傳的文字</p><p><img src="Prompt.png"></p><p>點選 “確定” 就會照常跳轉，反之點選 “取消” 則留在原頁面</p><p>但有另一個情況是，點選表單送出欄位的按鈕時，沒有必要顯示這個再次確認的按鈕，因為如果表單沒有問題就會送出，表單有問題也會是透過欄位驗證機制來阻止這個動作，所以在 form submit click event 上，可以直接將判斷是否顯示 <code>Prompt</code> 的參數設為 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isEntering, setIsEntering] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitFormHandler = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formFocusedHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setIsEntering(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> finishEnteringHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setIsEntering(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ( </span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Prompt</span><br><span class="line">        when=&#123;isEntering&#125;</span><br><span class="line">        message=&#123;<span class="function">(<span class="params">location</span>) =&gt;</span></span><br><span class="line">          <span class="string">&quot;Are you sure you want to leave? All your entered data will be lost!!&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;form onFocus=&#123;formFocusedHandler&#125; onSubmit=&#123;submitFormHandler&#125;&gt;</span><br><span class="line">        ...some input</span><br><span class="line">        &lt;button onClick=&#123;finishEnteringHandler&#125;&gt;&lt;<span class="regexp">/button&gt;   /</span><span class="regexp">/ 我取消顯示 Prompt</span></span><br><span class="line"><span class="regexp">      &lt;/</span>form&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Query-Paramters"><a href="#Query-Paramters" class="headerlink" title="Query Paramters"></a><a href="https://github.com/Jerry-Yeh/-React-The-Complete-Guide-Section20-2/commit/b878edd71104fd22908de9287a3a40ac333fb205">Query Paramters</a></h2><p>在 url 中，除了可以判斷路徑顯示對應的頁面與資料外，還可以額外透過 <code>?</code> 作為分隔，加入更多參數來做為頁面顯示的條件，接下來的範例將透過參數判斷資料列表的排序為升冪(ascending)或降冪(descending)</p><h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation()"></a>useLocation()</h3><p>首先，透過一個變數判斷 url 參數紀錄是否為升冪排列，透過 <code>useLocation()</code> 取得當前 route 資料後，可以使用原生 Web API <code>URLSearchParams</code> 來整理參數，只要傳入 search params 就會自動整理以供使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> location = useLocation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queryParams = <span class="keyword">new</span> URLSearchParams(location.search);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isSortingAcending = queryParams.get(<span class="string">&#x27;sort&#x27;</span>) === <span class="string">&#x27;asc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Switch-sorting"><a href="#Switch-sorting" class="headerlink" title="Switch sorting"></a>Switch sorting</h3><p>接著新增一個按鈕來切換排序順序，再，並把這個參數動態新增到 url 上的參數，這時候就會需要用到 <code>useHistory()</code> 來切換路徑，這裡需要特別注意的是，即便是相同路徑，透過 <code>history.push</code> 仍然會重新渲染頁面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someList = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> history = useHistory();</span><br><span class="line">  <span class="keyword">const</span> location = useLocation();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> queryParams = <span class="keyword">new</span> URLSearchParams(location.search);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isSortingAcending = queryParams.get(<span class="string">&#x27;sort&#x27;</span>) === <span class="string">&#x27;asc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sortedQuotes = sortQuotes(props.quotes, isSortingAcending);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> changeSortingHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    history.push(<span class="string">`/quotes?sort=<span class="subst">$&#123;isSortingAcending ? <span class="string">&#x27;desc&#x27;</span> : <span class="string">&#x27;asc&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;button onClick=&#123;changeSortingHandler&#125;&gt;&lt;/button&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;props.list.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">          ...</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最後新增一個 sorting function 透過參數排列 list</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortList = <span class="function">(<span class="params">list, ascending</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> list.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ascending) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.id &gt; b.id ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a.id &lt; b.id ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someList = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isSortingAcending = queryParams.get(<span class="string">&#x27;sort&#x27;</span>) === <span class="string">&#x27;asc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sortedList = sortList(props.list, isSortingAcending);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;changeSortingHandler&#125;&gt;</span><br><span class="line">        Sort &#123;isSortingAcending ? <span class="string">&#x27;Descending&#x27;</span> : <span class="string">&#x27;Ascending&#x27;</span>&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;sortedList.map(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">        ...</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://reactrouter.com/">React Router</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> React Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Router</title>
      <link href="/react/20220813/36407/"/>
      <url>/react/20220813/36407/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>React 是一個 single-page application，顧名思義就是不論如何切換頁面，都是在單一個 html 檔案內替換其中的內容，而非傳統網頁在切換頁面時，都會透過對 server 發出 request 取得新的 html 檔案再渲染到 browser 上，這麼做得好的不外乎就是為了避免頻繁的在切換頁面時送出 request 以提高網站效能，在 React 社群中，有一個很好用的 3rd-part library - React Rotuer 替我們解決了這個問題。</p><span id="more"></span><h2 id="What-is-Routing-amp-Why"><a href="#What-is-Routing-amp-Why" class="headerlink" title="What is Routing &amp; Why ?"></a>What is Routing &amp; Why ?</h2><p>在 React 這種 client-side render 的 single-page application 中，即便如何切換頁面，其實都是在同一個 html 檔案內並共用同一個 url，只是再透過 url 上的後綴以辨別當下頁面，傳統 server-side render 的網站的每一個頁面都是一個 html 檔案，所以當使用者切換頁面時，都需要送出 reqeust 向 server 取得 html 再渲染於網頁上，這麼做有一個很明顯的問題就是頻繁的送出 reqeust 可能會造成效能上的消耗已影響使用者體驗。</p><p>而 client-side render 則是透過 JavaScript 在 browser 中處理頁面切換的邏輯，向後端發出的 request 則改為單純的資料交換與操作，因此只會有一個 html 檔案與一個實際上的 url，只是透過 client routing 加上後綴以辨別頁面。</p><h2 id="Installing-React-Router"><a href="#Installing-React-Router" class="headerlink" title="Installing React Router"></a><a href="https://www.npmjs.com/package/react-router">Installing React Router</a></h2><p>在安裝 React Router 時，比較特別的是，並非直接安裝 react-router，而是安裝 react-router-dom or react-router-native，雖然這篇筆記紀錄的當下已經有了 v6，但接下來的範例會先以 v5 來操作，最後會再分享升級到 v6 的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i react-router-dom@5</span><br></pre></td></tr></table></figure><h2 id="Defining-amp-Using-Routes"><a href="#Defining-amp-Using-Routes" class="headerlink" title="Defining &amp; Using Routes"></a>Defining &amp; Using Routes</h2><p>透過 Route 來控制 component 顯示的情況就會是每個 url 會有對應的 component，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// our-domain.com/welcome =&gt; Welcome Component</span></span><br><span class="line"><span class="comment">// our-domain.com/products =&gt; Products Component</span></span><br></pre></td></tr></table></figure><p>首先，需要在根元件 App.js 中，註冊每個 component 所在的 route;這裡需要特別注意的是，所有 React Router function 的使用都是來自先前所安裝的 react-router-dom 而不是 react-router。</p><p>import <code>Route</code> JSX 後，其中的 <code>path</code> attribute 就是自定義的 route 名稱，內部則放置當切換到這個 route 時，預期顯示的 component</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Route &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Products <span class="keyword">from</span> <span class="string">&quot;./components/pages/Products&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Welcome <span class="keyword">from</span> <span class="string">&quot;./components/pages/Welcome&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">        &lt;Welcome /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/products&quot;</span>&gt;</span><br><span class="line">        &lt;Products /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在完成 route &amp; component 的對應關係後，還需要到 index.js 中完成最後一個動作上述的註冊才會生效，那就是 import <code>BrowserRotuer</code> JSX 包覆 App</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.render(</span><br><span class="line">  &lt;BrowserRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/BrowserRouter&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Working-with-Links"><a href="#Working-with-Links" class="headerlink" title="Working with Links"></a><a href="https://reactrouter.com/docs/en/v6/components/link">Working with Links</a></h2><p>a tag href will leave one single-page and create a new page, it will lose state in our page</p><p>有了 route &amp; component 的定義後，接下來當然就是要嘗試切換 route 來顯示不同的 component，使用原生 html 的 <code>a</code> element 就可以切換頁面的目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainHeader.js</span></span><br><span class="line"><span class="keyword">const</span> MainHeader = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">&quot;/welcome&quot;</span>&gt;Welcome&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;a href=<span class="string">&quot;/products&quot;</span>&gt;Products&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MainHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">        &lt;Welcome /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/products&quot;</span>&gt;</span><br><span class="line">        &lt;Products /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>點擊這兩個 <code>a</code> link 後，確實會如我們所預期的切換頁面，但這裡有一個很大的問題是，當我們點擊 <code>a</code> link 後，他預設的行為其實是送出 reqeust 取得新的 html 渲染於網頁上，這明顯違背了 single-page 的設計初衷，進而導致 state 資料的遺失，所以畫面才會閃了一下，這裡可以進一步打開 devtools Network 來確認聳出了 reqeust</p><p>為了解決這個問題，React Router 提供了另一個 JSX <code>Link</code> 這個問題，只要透過 <code>Link</code> 來取代 <code>a</code> element 切換 route，再透過 <code>to</code> 指定目標 route，就可以達到在 single-page 內切換 route 的目的了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MainHeader = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">&quot;/welcome&quot;</span>&gt;Welcome&lt;/Link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;Link to=<span class="string">&quot;/products&quot;</span>&gt;Products&lt;/Link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MainHeader;</span><br></pre></td></tr></table></figure><h2 id="Using-NavLinks"><a href="#Using-NavLinks" class="headerlink" title="Using NavLinks"></a><a href="https://reactrouter.com/docs/en/v6/components/nav-link">Using NavLinks</a></h2><p>許多 UI 為了讓使用者更明確知道當下所在頁面，會對該切換頁籤加上特別的樣式以做區分，React Router 就提供了另一個 JSX <code>NavLink</code> 來附加客製化的 CSS，只要將 <code>Link</code> 由 <code>NavLink</code> 取代，並透過 <code>activeClassName</code> 就可以加上 CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MainHeader.module.css */</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">a</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainHeader.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&quot;./MainHeader.module.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MainHeader = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header className=&#123;classes.header&#125;&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;NavLink activeClassName=&#123;classes.active&#125; to=<span class="string">&quot;/welcome&quot;</span>&gt;</span><br><span class="line">            Welcome</span><br><span class="line">          &lt;/NavLink&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">          &lt;NavLink activeClassName=&#123;classes.active&#125; to=<span class="string">&quot;/products&quot;</span>&gt;</span><br><span class="line">            Products</span><br><span class="line">          &lt;/NavLink&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MainHeader;</span><br></pre></td></tr></table></figure><h2 id="A-Not-Found-Page"><a href="#A-Not-Found-Page" class="headerlink" title="A Not Found Page"></a><a href="https://github.com/Jerry-Yeh/-React-The-Complete-Guide-Section20-2/commit/7460b91ee6bf8b8fe3505f84c6fa18c45516f31d">A Not Found Page</a></h2><p>當使用者瀏覽網頁時，可能因為網址輸入錯誤或其他原因導致沒有對應的頁面已顯示，在 React Router 中，<code>Route</code> 中的 <code>path</code> 可以使用 <code>*</code> 代表所有其他的路徑，只要是沒有對應頁面的路徑預設都會被導到此頁面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/&quot;</span> exact&gt;</span><br><span class="line">        &lt;Redirect to=<span class="string">&quot;/quotes&quot;</span> /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/quotes&quot;</span> exact&gt;</span><br><span class="line">        &lt;AllQuotes /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/quotes/:quoteId&quot;</span>&gt;</span><br><span class="line">        &lt;QuotesDetail /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;/new-quote&quot;</span>&gt;</span><br><span class="line">        &lt;NewQuotes /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">      &lt;Route path=<span class="string">&quot;*&quot;</span>&gt;</span><br><span class="line">        &#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">        <span class="comment">// 我代表所有其他頁面</span></span><br><span class="line">        &lt;NotFound /&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Implementing-Programmatic-Mavigation"><a href="#Implementing-Programmatic-Mavigation" class="headerlink" title="Implementing Programmatic Mavigation"></a><a href="https://github.com/Jerry-Yeh/-React-The-Complete-Guide-Section20-2/commit/de68c0b5e2f2a4c485968396b3ef52ce1408af35">Implementing Programmatic Mavigation</a></h2><p>在很多使用情境中，頁面的跳轉並非使用者動作執行的當下就發生，而是在觸發條件後，需要完成特定的程式邏輯，如送出資料，才會進行頁面的跳轉，所以頁面跳轉的行為就不直接附加在按鈕上</p><p>React Router 提供了另一個 hook - <code>useHistory()</code> 來解決這個問題，其所回傳的 object 中，有一個 <code>push</code> method 可以指定目標的路徑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> QuoteForm <span class="keyword">from</span> <span class="string">&quot;../components/quotes/QuoteForm&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NewQuotes = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> history = useHistory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addQuoteHandler = <span class="function">(<span class="params">quoteData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;addQuoteHandler&quot;</span>, quoteData); <span class="comment">// 我是 http request</span></span><br><span class="line"></span><br><span class="line">    history.push(<span class="string">&quot;/quotes&quot;</span>); <span class="comment">// 送出資料後我才跳轉</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">QuoteForm</span> <span class="attr">onAddQuote</span>=<span class="string">&#123;addQuoteHandler&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://reactrouter.com/">React Router</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> React Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM config</title>
      <link href="/npm/20220809/40501/"/>
      <url>/npm/20220809/40501/</url>
      
        <content type="html"><![CDATA[<p>通常在工作上，為了顧及資安問題，通常會透過使用內網以保護公司內部的開發資源與訊息，但也因為這個原因導致許多網站與開發資源被拒於防火牆外，這次在工作上遇到一個非常直接也很困擾的問題是無法直接在內網安裝 npm 相關套件，還好 npm 提供了設定方式以一次性的解決 http/https 與 proxy 的連線問題</p><span id="more"></span><p>在公司內部，通常會連線至內網處理所有工作，再由 proxy server 連線至 internet，這次遇到一個很困擾的問題是所有 JavaScript 在開發時必定會使用到的 npm 套件庫，在對 npm 進行設定前，只能偷偷連線到外網以下載對應的資源，但其實 npm 提供了幾個連線設定以解決這個問題</p><ul><li><p>查看 npm 設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config list</span><br></pre></td></tr></table></figure></li><li><p>設定 npm proxy，這裡比較特別的是，http 的指令為 proxy，https 則為 https-proxy，後方同樣帶入 proxy server url</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> proxy http://company.proxy.com:8080</span><br><span class="line">$ npm config <span class="built_in">set</span> https-proxy http://company.proxy.com:8080</span><br></pre></td></tr></table></figure></li><li><p>如果公司內還需要帳號密碼以連線至 proxy，只要將帳號密碼加在 proxy url 前方即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> proxy http://<span class="variable">$&#123;name&#125;</span>:<span class="variable">$&#123;password&#125;</span>@company.proxy.com:8080</span><br></pre></td></tr></table></figure></li><li><p>而如果不希望密碼被直接透過 npm config get 顯示出來，可以將密碼透過 base64 轉譯，仍能成功連線</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config get &lt;key&gt;</span><br></pre></td></tr></table></figure></li></ul><p>其他相關指令可以參考 <a href="https://doc.codingdict.com/npm-ref/cli/config.html">NPM 官網</a></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://doc.codingdict.com/npm-ref/cli/config.html">npm-config</a></p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redux DevTools</title>
      <link href="/react/20220809/50757/"/>
      <url>/react/20220809/50757/</url>
      
        <content type="html"><![CDATA[<p>在 React 章節初期，就有介紹過 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools</a> 這著個 Chrome Extension 來提高開發效率，在 Redux 也有另一個 Chrome Extension - <a href="https://chrome.google.com/webstore/detail/lmhkpmbekcpmknklioeibfkpmmfibljd">Redux DevTools</a> 協助開發</p><span id="more"></span><p>同樣地，只要在 <a href="https://chrome.google.com/webstore/category/extensions">Chrome Extension Store</a> 就可以直接下載這個 Chrome Extension</p><p>開啟 React 專案後，打開 DevTools，就會看到以下畫面</p><p><img src="Redux-DevTools.png"></p><p>其中左側代表的操作過程中所執行的 Reducer Function，只要把游標指到上方，就會出現 Jump &amp; Skip 的按紐，點選 Jump 就會將畫面跳到該步驟，並在右方顯示這步驟所操作的 state;反之點選 Skip 就會跳過該步驟</p><p>其實整個 UI 設計的相當直覺，即使是第一次使用只要隨意點選就可以很容易上手相關功能</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd">Redux DevTools</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Redux </tag>
            
            <tag> Chrome Extension </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux &amp; Async Code</title>
      <link href="/react/20220807/51228/"/>
      <url>/react/20220807/51228/</url>
      
        <content type="html"><![CDATA[<p>在 Redux 中，無法直接處理 async function，這可能會導致某些無法預期的資料遺漏，但資料的來源與更新往往是來自於後端 server，所以必須透過 async http request 取得;接下來，將介紹兩種如何在使用 Redux 時，處理 async function 的方式</p><span id="more"></span><h2 id="Using-useEffect-with-Redux"><a href="#Using-useEffect-with-Redux" class="headerlink" title="Using useEffect() with Redux"></a><a href="https://github.com/Jerry-Yeh/-React-The-Complete-Guide-Section19/commit/639e0f8fd06fc0d1f1dd843ff5e84c75c1e5ac4e">Using useEffect() with Redux</a></h2><p>因為 Redux 無法接受 async function，因此如果要在更新 Redux 資料時同步更新 Server 資料，就可以透過 <code>useEffect()</code> hook 來監聽在 Redux 資料變更時，呼叫 API 更新 Server 資料，在這裡的範例中，Server 只是簡易的使用 firebase Database 示範，因此可以直接使用 PUT method 來取代其中的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cart = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.cart.cartItems);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com/cart.json&quot;</span>, &#123;</span><br><span class="line">      method: <span class="string">&quot;PUT&quot;</span>,</span><br><span class="line">      body: <span class="built_in">JSON</span>.stringify(cart),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, [cart]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Using-an-Action-Creator-Thunk"><a href="#Using-an-Action-Creator-Thunk" class="headerlink" title="Using an Action Creator Thunk"></a>Using an Action Creator Thunk</h2><p>Redux Slice 本身無法處理 async function，但如果希望與 store 資料相關的 async 邏輯可以一同放置在 slice 檔案中管理，就可以使用到 Action Creator 這個方法</p><p>Action Creator 是位在 Slice 檔案內的 function，比較特別的是，其本身並非 async function，而是回傳 async function，async function 的第一個參數就是 dispatch。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Fragment, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; sendCartData &#125; <span class="keyword">from</span> <span class="string">&quot;./store/cart-slice&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="keyword">const</span> cart = useSelector(<span class="function"><span class="params">state</span> =&gt;</span> state.cart.cartItems);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dispatch(sendCartData(cart));</span><br><span class="line">  &#125;, [cart, dispatch]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cart-slice.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> cartData = <span class="function">(<span class="params">cart</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (dispatch) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> sendRequest = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Sending cart data failed!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> sendRequet()</span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">      .catch(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Working with Multiple Slices</title>
      <link href="/react/20220804/64624/"/>
      <url>/react/20220804/64624/</url>
      
        <content type="html"><![CDATA[<p>在一般的專案開發中，功能當然不會只有一個 counter 這麼簡單，一個基本的網站可能就包含登入、列表等功能，而登入的狀態是很典型會被應用在許多不同 component 的資料 (app-wide state)，接下來就會探討如何在 Redux 中管理多項不同的功能</p><span id="more"></span><h2 id="Multiple-Slices"><a href="#Multiple-Slices" class="headerlink" title="Multiple Slices"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/fce4f16b393e719b8b81292e143f7dbf2f66b6b7">Multiple Slices</a></h2><p>延續上一章的 Counter 功能，接著要在專案中加入登入的功能，可能會有一組新的 component 如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">&quot;./components/Counter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Auth <span class="keyword">from</span> <span class="string">&quot;./components/Auth&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&quot;./components/Header&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;Auth /&gt;</span><br><span class="line">      &lt;Counter /&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>接著在 Redux store 中加入登入的功能，以技術上來說，我們完全可以在已存在的 counterSlice 中加入登入相關的 state &amp; action，但在開發時，為了更好的維護專案，我們盡可能還是將不同的功能加以區分，因此額外建立一個 authSlice 是更好的解決方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterSlice = createSlice(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialAuthState = &#123;</span><br><span class="line">  isAuthenticated: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> authSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&#x27;auth&#x27;</span>,</span><br><span class="line">  initialState: initialAuthState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">login</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.isAuthenticated = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">logout</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.isAuthenticated = <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但這裡要注意的是，無論我們因應功能需求增加了多少 slice,仍舊只會有一個 store，store 有只會有一個 reducer，因此如果出現多個 slice 的情況，就要將 reducer 改成 object，其中每一個 key-value 就代表一組 slice</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;</span><br><span class="line">  <span class="comment">// reducer: counterSlice.reducer,</span></span><br><span class="line">  reducer: &#123; <span class="attr">counter</span>: counterSlice.reducer, <span class="attr">auth</span>: authSlice.reducer &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>actions 則可以個別 export</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterActions = counterSlice.actions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> authActions = authSlice.actions;</span><br></pre></td></tr></table></figure><p>而在 component 的使用上有需要些許的調整，在使用 state 時，需要特別指明是哪一組 slice，名稱就來自 store reducer 中自定義的 key</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="keyword">const</span> counter = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.counter.counter);</span><br><span class="line">  <span class="keyword">const</span> show = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.counter.showCounter);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Splitting-Our-Code"><a href="#Splitting-Our-Code" class="headerlink" title="Splitting Our Code"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/d493f258f093b93bbebf141bb705fedc0fe00e96">Splitting Our Code</a></h2><p>隨著開發的功能越來越豐富，如果都將所有 Slice 寫在 store/index.js 內，這個檔案就會變得肥大難以維護，所以在開發時通常會將每個 Slice 以單一檔案個別管理，再統一匯入  store/index.js 建立 store</p><p>在建立 store 時，其實只需要 Slice.reducer，所以每個 Slice export 可以只提供 Slice.reducer;另外，Actions 則由每個 Slice 檔案個別 export</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  counter: <span class="number">0</span>,</span><br><span class="line">  showCounter: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterActions = counterSlice.actions;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.reducer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&quot;./counter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> authReducer <span class="keyword">from</span> <span class="string">&quot;./auth&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = configureStore(&#123;</span><br><span class="line">  reducer: &#123; <span class="attr">counter</span>: counterReducer, <span class="attr">auth</span>: authReducer &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><h3 id="Component-Import"><a href="#Component-Import" class="headerlink" title="Component Import"></a>Component Import</h3><p>在 Component 的使用上，因為 Actions 改由個別 Slice export，所以當然也需要改從 Slice 檔案 import</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/Counter.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; counterActions &#125; <span class="keyword">from</span> <span class="string">&#x27;../store/counter&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adding State Slices</title>
      <link href="/react/20220731/37510/"/>
      <url>/react/20220731/37510/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>接下來將介紹另一個 libray - Redux Toolkit 使我們在使用 Redux 時更加簡潔</p><span id="more"></span><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>由 <a href="https://redux-toolkit.js.org/introduction/getting-started">Redux Toolkit 官網</a> 可以看到，直接透過 <code>npm install</code> 安裝了，而且因為 Redux Toolkit 預設已經安裝 Redux 了，所以如果已經安裝 Redux 就可已將其解除安裝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install @reduxjs/toolkit</span><br><span class="line"></span><br><span class="line">npm uninstall redux</span><br></pre></td></tr></table></figure><h2 id="Adding-State-Slices"><a href="#Adding-State-Slices" class="headerlink" title="Adding State Slices"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/3f67e11a9328825018f0d9b6c6af6fda169cb6ab">Adding State Slices</a></h2><p>首先，透過 <code>createSlice</code> 建立 store，其中第一個參數為 object，分別包含以下屬性</p><ul><li>name: 自定義名稱</li><li>initialState: state 初始值，同樣為一個 object，各個 state 以其屬性定義</li><li>reducers: 其值同樣為一個 object，action 所對應的 reducer function 可以直接被定義在其中</li></ul><p>一段 Redux 基本寫法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  counter: <span class="number">0</span>,</span><br><span class="line">  showCounter: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increment&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter + <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increase&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter + action.amount,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;decrement&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;toggle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        showCounter: !state.showCounter,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下來透過 Redux Toolkit 改寫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line">createSlice(&#123;</span><br><span class="line">  name: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter--;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      state.counter += action.amount;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">toogleCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.showCounter = !state.showCounter;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這裡可能會有個疑問是，在 reducer function 中不是有提到現有 state 不應該直接被更改，而是需要透過新的 state 來覆蓋原有的值嗎 ?</p><p>這裡可以直接修改的原因是當我們使用 Redux Toolkit 的時候，底層有一個名為 imgur 的工具，會自動偵測我們修改了哪一個 state，保留沒有動到的 state 並複製一組新的 object 來取代所有 state，所以其實更新 state 的方式還是一樣的</p><h2 id="Connecting-Redux-Toolkit-State"><a href="#Connecting-Redux-Toolkit-State" class="headerlink" title="Connecting Redux Toolkit State"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/17665f54e27892a8b261e728ede443f9f760397a">Connecting Redux Toolkit State</a></h2><p>透過 <code>createSlice()</code> 建立 reducer function 後，還需要讓它可以被取得，這時候就會需要另一個 function - <code>configureStore()</code>;首先，將剛才透過 <code>createSlice()</code> 所建立的 object 透過一個參數儲存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice, configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter--;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      state.counter += action.amount;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">toogleCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.showCounter = !state.showCounter;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>接下來呼叫 <code>configureStore()</code>，其參數為一個 object，其中的 key reducer 可以直接將剛才的變數 <code>counterSlice.reducer</code> 作為其 value</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;</span><br><span class="line">  reducer: counterSlice.reduer,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>問題來了，counter 可能只是一個專案裡的其中一個功能而已，如果有更多的 reducer，該如何定義 store 呢 ?</p><p>這裡只要將 <code>configureStore</code> 中的 reduer 改成一個 object，其中的 key 可以自行定義，如: counter，value 同樣為 <code>counterSlice.reducer</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = configureStore(&#123;</span><br><span class="line">  reducer: &#123;</span><br><span class="line">    counter: counterSlice.reducer,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Migrating-Everything-to-Redux-Toolkit"><a href="#Migrating-Everything-to-Redux-Toolkit" class="headerlink" title="Migrating Everything to Redux Toolkit"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/b651d24fc9ef14163db16f670c3d656cd844dc43">Migrating Everything to Redux Toolkit</a></h2><p>有了這些定義後，接下來的問題就是如何讓其他 component 使用其中的資料了，當我們透過 <code>createSlice()</code> 建立 reducer function 時，可以透過其回傳的 object key - actions 取得其中所有 reducer action，所以只要將這些 actions export 出去便可以供其他 component 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterActions = counterSlice.actions;</span><br></pre></td></tr></table></figure><p>而 component 要使用也很簡單，只要透過 import 取得 actions，就可以在 dispatch 中呼叫 action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; counterActions &#125; <span class="keyword">from</span> <span class="string">&quot;../store/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleCounterHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dispatch(&#123; type: &#x27;toggle&#x27; &#125;);</span></span><br><span class="line">    dispatch(counterActions.toggleCounter());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比較是如果需要帶入相關參數，可以直接帶入 primitive type 或 object，store 中的 action 則會以 <code>payload</code> 取得這個參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counter.js</span></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> increaseHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dispatch(&#123; type: &#x27;increase&#x27;, amount: 5 &#125;);</span></span><br><span class="line">    dispatch(counterActions.increase(<span class="number">5</span>)); <span class="comment">// &#123; type: SOME_UNIQUE_IDENTIFIER, payload: 5 &#125;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> counterSlice = createSlice(&#123;</span><br><span class="line">  name: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="function"><span class="title">increase</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      state.counter += action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux in React</title>
      <link href="/react/20220731/39070/"/>
      <url>/react/20220731/39070/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>Redux 其實並不限於 React 專案之中，它可以被使用在任何 JavaScript 專案，接下來將介紹如何在 React 專案之中使用 Redux</p><span id="more"></span><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>其實 Redux 並不在乎 React，它是一個可以被單獨使用於 JavaScript 專案中的 library，而為了與 React 專案有更好的整合性，React 提供了另一個 library - react-redux 使得兩者在開發上有更好的兼融性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux react-redux</span><br></pre></td></tr></table></figure><h2 id="Create-Store"><a href="#Create-Store" class="headerlink" title="Create Store"></a>Create Store</h2><p>在 React 專案中，習慣透過建立一個名為 store 的資料夾管理 Redux 資料;首先，可以在 store 中建立一個 index.js 檔案，並在其中建立最基本的 Redux store，最後將 store export 供其他 component 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = &#123; counter: <span class="number">0</span> &#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">&quot;increment&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: state.counter + <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">&quot;decrement&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: state.counter - <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><h2 id="Providing-the-Store"><a href="#Providing-the-Store" class="headerlink" title="Providing the Store"></a>Providing the Store</h2><p>在過去使用 context hook 統一管理資料時，會在根目錄進入點 index.js 中，透過 provider 包覆根元件 App，使其內部所有子元件都可以使用到 context 中的資料</p><p>同樣的，Redux 的使用方式也很類似，唯一比較特別的是，Provider 來自先前所額外安裝的 react-redux，在透過其 store 指定我們所建立的 store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Using-Redux-Data-in-React-Components"><a href="#Using-Redux-Data-in-React-Components" class="headerlink" title="Using Redux Data in React Components"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/a883be5cf7de5b83b66425b19c881380d3502f5f">Using Redux Data in React Components</a></h2><p>會放在 Redux 中的資料其目的不過是可以同事被多個 component 所使用，在 React functional component 專案中，可以透過 react-redux 中的 <code>useSelector()</code> hook 來取得 store state，其中的 callback function 第一個參數就是 state，可以直接指定 state 中的任一參數作為回傳的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useSelector(<span class="function">(<span class="params">state</span>) =&gt;</span> state.counter);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Dispatching-Actions-From-Inside-Components"><a href="#Dispatching-Actions-From-Inside-Components" class="headerlink" title="Dispatching Actions From Inside Components"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/4d02f501a62b78e445a412a0457e6e5da527866d">Dispatching Actions From Inside Components</a></h2><p>如果要對調整 store state 的值，就必須透過 dispatch 來操作，dispatch 中的參數代表預期的行為，行為所對應的操作邏輯則是會寫在 store dispatch function 之中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> incrementHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decrementHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;decrement&quot;</span> &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;incrementHandler&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;decrementHandler&#125;&gt;Decrement&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure><h2 id="Redux-with-Classed-based-Components"><a href="#Redux-with-Classed-based-Components" class="headerlink" title="Redux with Classed-based Components"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/15a15ff143c13409f9907365a818c283e86c5db0">Redux with Classed-based Components</a></h2><p>當然，Redux 也可以應用在 classed-based component 當中，只是使用方法有些微的不同</p><p>首先，透過 react-redux 取得 <code>connect</code> function，比較特別的是，class component 並非直接作為 <code>connect</code> 的參數呼叫，而是作為 <code>connect</code> 呼叫所回傳函式的參數;同樣地，class 中的 function 在 JSX 中呼叫時，需要透過 <code>bind(this)</code> 將 this 指向 class 本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">incrementHandler</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">decrementHandler</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.incrementHandler.bind(<span class="built_in">this</span>)&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.decrementHandler.bind(<span class="built_in">this</span>)&#125;&gt;Decrement&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="title">connect</span>(<span class="params"></span>)</span>&#123;Counter&#125;;</span><br></pre></td></tr></table></figure><p>接著，<code>connect()</code> function 中有兩個參數，都是 function，當然名稱可以自行定義，分別為以下兩者:</p><ul><li>mapStateToProps: 參數為 store state，回傳 component 所需 state</li><li>mapActionToProps: 參數為 dispatch，回傳所需 dispatch function</li></ul><p>兩者所回傳的值，可以直接成為 class props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">incrementHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.incrementHandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">decrementHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.decrementHandler();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      ...</span><br><span class="line">      &lt;div className=&#123;classes.value&#125;&gt;&#123;<span class="built_in">this</span>.props.counter&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.incrementHandler.bind(<span class="built_in">this</span>)&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.decrementHandler.bind(<span class="built_in">this</span>)&#125;&gt;Decrement&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: state.counter,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapActionToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    incrementHandler: <span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;increment&#x27;</span>&#125;),</span><br><span class="line">    decrementHandler: <span class="function">() =&gt;</span> dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;decrement&#x27;</span>&#125;),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="title">connect</span>(<span class="params">mapStateToProps, mapActionToProps</span>)</span>&#123;Counter&#125;;</span><br></pre></td></tr></table></figure><h2 id="Attaching-Payloads-to-Actions"><a href="#Attaching-Payloads-to-Actions" class="headerlink" title="Attaching Payloads to Actions"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/7fd7abe95693cb1762eab8ae4250d49e122e9a3a">Attaching Payloads to Actions</a></h2><p>如果突然多了一個需求是要新增一個點一下可以加 5 的按鈕，直接的做法是在 reducer 中直接新增一個加 5 的情境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state: &#123; counter: <span class="number">0</span> &#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increment&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: state.counter + <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increaseBy5&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: state.counter + <span class="number">5</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;decrement&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: state.counter - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這麼做有一個很大的缺點是，5 這個變數因為 hard code 缺乏彈性，如果往後有其他數字的需求，勢必就是不斷複製相同程式碼，所以比較好的做法就是讓 5 成為一個可彈性帶入的變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increase&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: state.counter + action.amount,</span><br><span class="line">      &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Counter</span></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> increase = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;<span class="attr">type</span>: <span class="string">&#x27;increase&#x27;</span>, <span class="attr">amount</span>: <span class="number">5</span>&#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;increaseHandler&#125;&gt;Increase by <span class="number">5</span>&lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="How-To-Work-With-Redux-State-Correctly"><a href="#How-To-Work-With-Redux-State-Correctly" class="headerlink" title="How To Work With Redux State Correctly"></a><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section18/commit/a171cb396f8a45f835611f7a4f813abea3c41910">How To Work With Redux State Correctly</a></h2><p>在過去的範例中會發現，所有 reducer 在編輯 state 的值後，都會回傳一個全新的 object 來覆蓋原有的 state，而不是單純調整 state 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// correct</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increase&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: state.counter + action.amount,</span><br><span class="line">      &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increase&quot;</span>:</span><br><span class="line">      state.counter += action.amount;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因為在 Redux 中，State 的值是不能直接被 mutate 的，即使在基礎的應用上看似功能一切正常，也可能發生無法預期的 bug，如果有多項 state，但 action 只打算改變一項 state，可以透過 spread 的方式沿用其他不變的 state，再覆蓋欲更改的 State</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = initialState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increase&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        counter: state.counter + action.amount</span><br><span class="line">      &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Core Redux Concepts</title>
      <link href="/react/20220731/30803/"/>
      <url>/react/20220731/30803/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>Redux 基礎應用流程</p><span id="more"></span><p>在透過一個最單純的範例來了解 Redux 應用流程時，甚至不需要 create-react-app 來建立專案，只需要單純透過 Node.js 讓 JavaScript 可以在非瀏覽器環境中執行就可以了;首先，開啟一個新的專案資料夾，再透過以下指令安裝 Node.js 與 Redux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line">npm install redux</span><br></pre></td></tr></table></figure><p>安裝後，因為是在 Node.js 環境，所以 import library 的方式有些微的差異:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redux = <span class="built_in">require</span>(<span class="string">&quot;redux&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="crateStore"><a href="#crateStore" class="headerlink" title="crateStore()"></a>crateStore()</h3><p>接著可以透過 <code>redux.createStore()</code> 來建立 store，其中第一個參數就是 reducer callback function，在這裡只需要帶入，不需要即時呼叫它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = redux.createStore(counterReducer);</span><br></pre></td></tr></table></figure><h3 id="reducer-callback-function"><a href="#reducer-callback-function" class="headerlink" title="reducer callback function"></a>reducer callback function</h3><p>而 reducer function 只是一個 general JavaScript function，其中兩個參數分別為:</p><ul><li>Old State: 舊的 state 值</li><li>Dispatched Action: 修改 state 值的指令 Action</li></ul><p>最後會回傳最新的 State，State 為 object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: state.counter + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="store-getState"><a href="#store-getState" class="headerlink" title="store.getState()"></a>store.getState()</h3><p>如果要取得 state 的值，可以透過 <code>state.getState()</code> 取得，但如果直接執行 <code>node $&#123;js file name&#125;</code> 會出現以下 error log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Cannot read properties of undefined (reading &#39;counter&#39;)</span><br></pre></td></tr></table></figure><p>原因是沒有給定 state 初始值，最簡地的做法就是在 reducer function 中直接給定初始值，只有第一次會使用到，之後的 state 就會依照 return object 的值更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = &#123;counter: <span class="number">0</span>&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: state.counter + <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><p>而一班的使用情境其實是會透過 component subscribe store 來取得 store 的值，作法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterSubscriber = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> latestState = store.getState();</span><br><span class="line">  <span class="built_in">console</span>.log(latestState);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.subscribe(counterSubscriber);</span><br></pre></td></tr></table></figure><p>結果會發現，並沒有顯示 subscriber 中的預期會顯示的值，原因是 subscribe 需要透過 dispatch 來觸發</p><h3 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h3><p>當我們透過 <code>store.dispatch()</code> 觸發 state 更新時，可以在其中帶入辨別行為的參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>最終結果會得到 counterReducer 執行”兩次”的 <code>counter: 2</code>，原因是在 store 建立時，就先呼叫一次 reducer，如果執行 dispatch 就會再次被呼叫</p><h2 id="Look-Into-Action"><a href="#Look-Into-Action" class="headerlink" title="Look Into Action"></a>Look Into Action</h2><p>當然有了 aciton 所指定的行為後，就可以在 reducer function 中藉由判斷 action 的指示對 state 做出對應的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counterReducer = <span class="function">(<span class="params">state = &#123; counter: <span class="number">0</span> &#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increment&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: state.counter + <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;decrement&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: state.counter - <span class="number">1</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = redux.createStore(counterReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counterSubscriber = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> latestState = store.getState();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;latestState&quot;</span>, latestState);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.subscribe(counterSubscriber);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span> &#125;); <span class="comment">// &#123; counter: 1 &#125;</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;decrement&quot;</span> &#125;); <span class="comment">// &#123; counter: 0 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux</title>
      <link href="/react/20220727/28096/"/>
      <url>/react/20220727/28096/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>接下來的章節將介紹一個 React 生態圈中很重要的 library - Redux</p><span id="more"></span><h2 id="What-is-“Redux”"><a href="#What-is-“Redux”" class="headerlink" title="What is “Redux”?"></a>What is “Redux”?</h2><p>首先，第一個問題一定是 Redux 是什麼 ? 在問這個問題之前，先來談談在過去的章節中不斷被使用到的 state，state 的使用情境不外乎就是以下 3 種:</p><ul><li><p>Local State: 最單純的 state 使用，只在單一 component 透過 <code>useState()</code> 與 <code>useReducer()</code> 來建立並操作 state，常見的使用情境就是輸入欄位操作</p></li><li><p>Cross-Component State: 其次是稍微複雜的使用情境，在打開一個 modal 時傳遞資料，就會需要透過 <code>props</code> 來傳遞 state</p></li><li><p>App-Wide State: 而有些情況如使用者登入，其資料可能會影響到許多不同功能 component 的資料，這時候如果還透過 props 層層傳遞，就會顯得非常麻煩，因此管理共用 state 的需求就這麼誕生了</p></li></ul><h2 id="Redux-vs-React-Context"><a href="#Redux-vs-React-Context" class="headerlink" title="Redux vs React Context"></a>Redux vs React Context</h2><p>那麼問題來了，在先前遇到 App-Wide State 的需求時，已經有了 context &amp; provider 來解決這個問題了，為什麼我們還會需要 Redux ?</p><p>原因是 context 有幾個潛在的問題:</p><h3 id="複雜且龐大的專案"><a href="#複雜且龐大的專案" class="headerlink" title="複雜且龐大的專案"></a>複雜且龐大的專案</h3><p>在中小型的專案中，很多需求可以透過 context 輕易的解決，但當專案不但擴大時，context 不外乎會出現兩種情況</p><ul><li><p>多層 provider: 如果維持每個 provider 維護特定功能，就會出現多層 provider nested JSX 的結構</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;AuthConextProvider&gt;</span><br><span class="line">    &lt;ThemeContextProvider&gt;</span><br><span class="line">      ...many provider</span><br><span class="line">      &lt;UserRegistration /&gt;</span><br><span class="line">    &lt;/ThemeContextProvider&gt;</span><br><span class="line">  &lt;/AuthConextProvider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>一個 provider 太多功能: 如果要避免上述情況，勢必得把許多不同功能寫在一個 provider，這也會造成另一個功能難以區分的問題</p></li></ul><h3 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h3><p>官方有特別提到，如果是更新頻率高的 state 應用，在 context 中會非常消耗效能，雖然所謂的高頻率並沒有一個明確的定義，但當出現這種情境時，Redux 會是一個更好的解決方案</p><h2 id="How-Redux-Works"><a href="#How-Redux-Works" class="headerlink" title="How Redux Works"></a>How Redux Works</h2><p>Redux 會由 store 來管理所有 state，store 又可以依照功能將之拆分成許多 moduels，避免所有資料混在一起的情況 ; 任何 component 都可以透過 Subscription 的方式來取得 store 中的資料，並透過 Disptach 呼叫 Action，Action 會執行 Reducer Function Mutates 更新 store 中的資料，需要注意的是，這裡的 Reducer Function 並非先前所提到的 <code>useReducer()</code> hook，而是更新 store 資料的一種概念</p><p><img src="redux.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fetching Data via Http</title>
      <link href="/react/20220721/1097/"/>
      <url>/react/20220721/1097/</url>
      
        <content type="html"><![CDATA[<p>這章節將透過 firebase 所提供的簡易資料庫與 API 來實際在 React 專案中串接應用</p><span id="more"></span><p>一筆簡單的陣列資料，並透過這筆資料產生 JSX，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AvailableMeals = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> meals = [...];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> mealsList = meals.map(<span class="function">(<span class="params">meal</span>) =&gt;</span> (</span><br><span class="line">    &lt;MealItem</span><br><span class="line">      key=&#123;meals.id&#125;</span><br><span class="line">      id=&#123;meals.id&#125;</span><br><span class="line">      name=&#123;meal.name&#125;</span><br><span class="line">      description=&#123;meal.description&#125;</span><br><span class="line">      price=&#123;meal.price&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  ));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;section className=&#123;classes.meals&#125;&gt;</span><br><span class="line">      &lt;Card&gt;</span><br><span class="line">        &lt;ul&gt;&#123;mealsList&#125;&lt;/ul&gt;</span><br><span class="line">      &lt;/Card&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Fetching-Data"><a href="#Fetching-Data" class="headerlink" title="Fetching Data"></a>Fetching Data</h2><p>在串接 firebase 所提供的 API 時，需使用 http 或是 在 url 最後方加上 .json，否則會出現 CORS error，而因為 http request 是一個 async event，所以須透過 State 來存取資料 ; 而像是這種在頁面載入時，就會自動送出 request 取得資料的情況，就可以使用 <code>useEffect()</code>，並使 dependency array 為 empty array，這麼一來就只有在 component first render 時會觸發</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [meals, setMeals] = useState([]);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">    <span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com/meals.json&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">  <span class="keyword">const</span> loadedMeals = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    loadedMeals.push(&#123;</span><br><span class="line">      id: key,</span><br><span class="line">      name: data[key].name,</span><br><span class="line">      description: data[key].description,</span><br><span class="line">      price: data[key].price,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMeals(loadedMeals);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>但這裡要特別注意的是，<code>useEffect()</code> 的 callback function 只能是一個 sync funcion，如果要在其中做到 async event，就必須透過另一層 async function 來封裝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [meals, setMeals] = useState([]);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fetchMeals = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">      <span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com/meals.json&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="keyword">const</span> loadedMeals = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      loadedMeals.push(&#123;</span><br><span class="line">        id: key,</span><br><span class="line">        name: data[key].name,</span><br><span class="line">        description: data[key].description,</span><br><span class="line">        price: data[key].price,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setMeals(loadedMeals);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetchMeals();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>而如果這個 async function 其實只有在 <code>useEffect()</code> 中呼叫一次，也可以改寫成 IIFE</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">      <span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com/meals.json&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="keyword">const</span> loadedMeals = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      loadedMeals.push(&#123;</span><br><span class="line">        id: key,</span><br><span class="line">        name: data[key].name,</span><br><span class="line">        description: data[key].description,</span><br><span class="line">        price: data[key].price,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setMeals(loadedMeals);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dealing with Form Submission &amp; Getting User Input Values</title>
      <link href="/react/20220717/16490/"/>
      <url>/react/20220717/16490/</url>
      
        <content type="html"><![CDATA[<p>在先前的章節中，許多使用者操作都是透過表單來互動，接下來將進一步介紹表單的開發方式與驗證</p><span id="more"></span><h2 id="Getting-Input-Values"><a href="#Getting-Input-Values" class="headerlink" title="Getting Input Values"></a>Getting Input Values</h2><p>經歷了先前的課程，我們知道有兩種方式可以取得表單欄位資料</p><h3 id="useState-amp-onChange"><a href="#useState-amp-onChange" class="headerlink" title="useState() &amp; onChange"></a>useState() &amp; onChange</h3><p>第一種是透過監聽每次欄位的變動來更新 State 的值，這種方式的好處是可以隨時得到最新 State，但缺點也顯而易見，那就是持續監聽所帶來的效能消耗</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleInput = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredName, setEnteredName] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nameInputChangeHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    setEnteredName(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;form-control&quot;</span>&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">&quot;name&quot;</span>&gt;Your Name&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> onChange=&#123;nameInputChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="useRef-amp-onSubmit"><a href="#useRef-amp-onSubmit" class="headerlink" title="useRef() &amp; onSubmit"></a>useRef() &amp; onSubmit</h3><p>另一種則是透過 <code>useRef()</code> 取得 input element，在送出表單時，一次性地取得欄位資料 ; 比較特別的是，HTML form submit 預設會送出 http request 給 server，並重新載入頁面，如果要避免這種情況就得透過原生 <code>event.preventDefault()</code> 來取消預設事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleInput = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> nameInputRef = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formSubmissionHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(nameInputRef.current.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formSubmissionHandler&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;form-control&quot;</span>&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">&quot;name&quot;</span>&gt;Your Name&lt;/label&gt;</span><br><span class="line">        &lt;input ref=&#123;nameInputRef&#125; type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> onChange=&#123;nameInputChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這種方式有一個不適合的使用時機是，如果要在送出表單後，清空欄位資料(改變欄位資料)，就只能直接透過原生方法賦予欄位新的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formSubmissionHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line"></span><br><span class="line">  nameInputRef.current.value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這種作法在技術上可行，但實際上並不建議這麼做，原因是當專案已經透過 React 開發時，我們會希望完全交由 React 來操作 DOM，如果直接對操作 DOM 可能會導致無法預期的問題發生。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adjusting the Custom Hook Logic</title>
      <link href="/react/20220716/14104/"/>
      <url>/react/20220716/14104/</url>
      
        <content type="html"><![CDATA[<p>這章節將進一步調整並優化 Custom Hook 的使用邏輯</p><span id="more"></span><h2 id="Custom-Http-Hook"><a href="#Custom-Http-Hook" class="headerlink" title="Custom Http Hook"></a>Custom Http Hook</h2><p>有兩個送出 http request 至 server 的 component 如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [tasks, setTasks] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchTasks = <span class="keyword">async</span> (taskText) =&gt; &#123;</span><br><span class="line">    setIsLoading(<span class="literal">true</span>);</span><br><span class="line">    setError(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">        <span class="string">&#x27;$&#123;server_url&#125;/tasks.json&#x27;</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Request failed!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> loadedTasks = [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> taskKey <span class="keyword">in</span> data) &#123;</span><br><span class="line">        loadedTasks.push(&#123; <span class="attr">id</span>: taskKey, <span class="attr">text</span>: data[taskKey].text &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setTasks(loadedTasks);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      setError(err.message || <span class="string">&#x27;Something went wrong!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setIsLoading(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetchTasks();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> taskAddHandler = <span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">    setTasks(<span class="function">(<span class="params">prevTasks</span>) =&gt;</span> prevTasks.concat(task));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;NewTask onAddTask=&#123;taskAddHandler&#125; /&gt;</span><br><span class="line">      &lt;Tasks</span><br><span class="line">        items=&#123;tasks&#125;</span><br><span class="line">        loading=&#123;isLoading&#125;</span><br><span class="line">        error=&#123;error&#125;</span><br><span class="line">        onFetch=&#123;fetchTasks&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTask.js</span></span><br><span class="line"><span class="keyword">const</span> NewTask = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> enterTaskHandler = <span class="keyword">async</span> (taskText) =&gt; &#123;</span><br><span class="line">    setIsLoading(<span class="literal">true</span>);</span><br><span class="line">    setError(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">        <span class="string">&#x27;$&#123;server_url&#125;/tasks.json&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">          body: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">text</span>: taskText &#125;),</span><br><span class="line">          headers: &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Request failed!&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> generatedId = data.name; <span class="comment">// firebase-specific =&gt; &quot;name&quot; contains generated id</span></span><br><span class="line">      <span class="keyword">const</span> createdTask = &#123; <span class="attr">id</span>: generatedId, <span class="attr">text</span>: taskText &#125;;</span><br><span class="line"></span><br><span class="line">      props.onAddTask(createdTask);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      setError(err.message || <span class="string">&#x27;Something went wrong!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setIsLoading(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Section&gt;</span><br><span class="line">      &lt;TaskForm onEnterTask=&#123;enterTaskHandler&#125; loading=&#123;isLoading&#125; /&gt;</span><br><span class="line">      &#123;error &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;error&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">    &lt;/Section&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很顯然地，因其中 http request 格式與 error handler 都非常相似，所以可以透過 custom hook 的方式來封裝這段程式碼</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use-http.js</span></span><br><span class="line"><span class="keyword">const</span> useHttp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sendRequest = <span class="keyword">async</span> (requestConfig, applyData) =&gt; &#123;</span><br><span class="line">    setIsLoading(<span class="literal">true</span>);</span><br><span class="line">    setError(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(requestConfig.url, &#123;</span><br><span class="line">        method: requestConfig.method ? requestConfig.method : <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">        headers: requestConfig.headers ? requestConfig.headers : &#123;&#125;,</span><br><span class="line">        body: requestConfig.body ? <span class="built_in">JSON</span>.stringify(requestConfig.body) : <span class="literal">null</span>,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Request failed!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">      applyData(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      setError(err.message || <span class="string">&quot;Something went wrong!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setIsLoading(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    isLoading,</span><br><span class="line">    error,</span><br><span class="line">    sendRequest,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下來便可以在 App 中使用這個 custom hook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [tasks, setTasks] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> transformTasks = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loadedTasks = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> taskKey <span class="keyword">in</span> data) &#123;</span><br><span class="line">      loadedTasks.push(&#123; <span class="attr">id</span>: taskKey, <span class="attr">text</span>: data[taskKey].text &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTasks(loadedTasks);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; isLoading, error, <span class="attr">sendRequest</span>: fetchTasks &#125; = useHttp(</span><br><span class="line">    &#123;</span><br><span class="line">      url: <span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com//tasks.json&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    transformTasks</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetchTasks();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> taskAddHandler = <span class="function">(<span class="params">task</span>) =&gt;</span> &#123;</span><br><span class="line">    setTasks(<span class="function">(<span class="params">prevTasks</span>) =&gt;</span> prevTasks.concat(task));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但目前為止，功能看似正常了，但在 <code>useEffect()</code> 會出現一個提示，因為凡是在其中所使用到的 component 內 function ，都需要加到 dependency array 之中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetchTasks();</span><br><span class="line">&#125;, [fetchTasks]);</span><br></pre></td></tr></table></figure><p>但這麼一來，就會出現 infinite loop 的情況，因為當 <code>fetchTasks</code> invoked，因其中改變 State，就會導致 component re-render，接著其中的 function 包含 <code>fetchTasks</code> 都會被重新產生，即便功能完全相同，因 function 也是 object，所以會在記憶體中另一個位置被新增，進而導致被判斷為不同 object 而使的這段程式碼被不斷重複執行。</p><p>為了解決這個問題，可以將 function 在 custom hook <code>useHttp</code> 中透過 <code>useCallback()</code> 來包裝它，藉此告訴 React 如果內容不變就可以不必重新生成這段 fucntion</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useHttp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> sendRequest = useCallback(<span class="keyword">async</span> (requestConfig, applyData) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Adjusting-the-Custom-Hook-Logic"><a href="#Adjusting-the-Custom-Hook-Logic" class="headerlink" title="Adjusting the Custom Hook Logic"></a>Adjusting the Custom Hook Logic</h2><p>到這裡其實就已經完成預期的功能了，但我們還可以進一步優化這段程式碼 ; 在前面的程式碼中，參數都透過 custom hook 直接帶入，但其實都只有在一個地方被使用，所以其實可以在 costom hook 所回傳的 fucntion 中帶入即可 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isLoading, error, <span class="attr">sendRequest</span>: fetchTasks &#125; = useHttp();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> transformTasks = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> loadedTasks = [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> taskKey <span class="keyword">in</span> data) &#123;</span><br><span class="line">        loadedTasks.push(&#123; <span class="attr">id</span>: taskKey, <span class="attr">text</span>: data[taskKey].text &#125;);      &#125;</span><br><span class="line"></span><br><span class="line">      setTasks(loadedTasks);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchTasks(</span><br><span class="line">      &#123;</span><br><span class="line">        url: <span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com//tasks.json&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      transformTasks</span><br><span class="line">    );</span><br><span class="line">  &#125;, [fetchTasks]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useHttp = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sendRequest = useCallback(<span class="keyword">async</span> (requestConfig, applyData) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Using-The-Custom-Hook-in-More-Components"><a href="#Using-The-Custom-Hook-in-More-Components" class="headerlink" title="Using The Custom Hook in More Components"></a>Using The Custom Hook in More Components</h2><p>接著這個 custom hook 使用到另外一個 component 之中，但這個 component 送出 http request 的方式不太一樣，需透過使用者手動出發，而非在 <code>useEffect()</code> 自動送出，而且後面對於資料的應用需要多一個傳入的參數 <code>teskText</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NewTask = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isLoading, error, <span class="attr">sendRequest</span>: sendTaskRequest &#125; = useHttp();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> createTask = <span class="keyword">async</span> (taskData) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> generatedId = taskData.name; <span class="comment">// firebase-specific =&gt; &quot;name&quot; contains generated id</span></span><br><span class="line">    <span class="keyword">const</span> createdTask = &#123; <span class="attr">id</span>: generatedId, <span class="attr">text</span>: taskText &#125;;</span><br><span class="line">    props.onAddTask(createdTask);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> enterTaskHandler = <span class="keyword">async</span> (taskText) =&gt; &#123;</span><br><span class="line">    sendTaskRequest(</span><br><span class="line">      &#123;</span><br><span class="line">        url: <span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com//tasks.json&quot;</span>,</span><br><span class="line">        method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        body: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">text</span>: taskText &#125;),</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      createTask</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這種情況就可以透過原生 JavaScript 的 <code>bind()</code> 來帶入額外的參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NewTask = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; isLoading, error, <span class="attr">sendRequest</span>: sendTaskRequest &#125; = useHttp();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> createTask = <span class="keyword">async</span> (taskText, taskData) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> generatedId = taskData.name;</span><br><span class="line">    <span class="keyword">const</span> createdTask = &#123; <span class="attr">id</span>: generatedId, <span class="attr">text</span>: taskText &#125;;</span><br><span class="line">    props.onAddTask(createdTask);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> enterTaskHandler = <span class="keyword">async</span> (taskText) =&gt; &#123;</span><br><span class="line">    sendTaskRequest(</span><br><span class="line">      &#123;</span><br><span class="line">        url: <span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com//tasks.json&quot;</span>,</span><br><span class="line">        method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        body: <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">text</span>: taskText &#125;),</span><br><span class="line">        headers: &#123;</span><br><span class="line">          <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      createTask.bind(<span class="literal">null</span>, taskText)   <span class="comment">// bind parameter</span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Custom Hooks</title>
      <link href="/react/20220712/3141/"/>
      <url>/react/20220712/3141/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在前面的章節中，介紹了不少 React hooks，這章節將介紹另一個 React 核心觀念，那就是我們其實也可以客製化 hooks!</p><span id="more"></span><h2 id="What-are-Custom-Hooks"><a href="#What-are-Custom-Hooks" class="headerlink" title="What are Custom Hooks ?"></a>What are Custom Hooks ?</h2><p>Custom Hooks 其實就是一般的 function，只是差別在於，它是一個 stateful 的 reusable function，而且可以在其中使用其他的 React hooks，不同於 component function 在使用 hooks 時，只能於最外層直接使用，無法使用於 scope 內，如 function、for…</p><h2 id="Creating-a-Custom-React-Hook-function"><a href="#Creating-a-Custom-React-Hook-function" class="headerlink" title="Creating a Custom React Hook function"></a>Creating a Custom React Hook function</h2><p>那麼在什麼時候會需要用到 custom hook 呢 ? 這個需求其實和一般開發時的思維一樣，凡是遇到相同需求的程式碼，都會盡可能的封裝它，使它可以被重複使用，也避免同一份程式碼反覆出現在不同的地方 ; 同理，custom hook 其實就是提供了一種方式，使我們可以封裝包含 React hook 的程式碼，使其在避免破壞 hook 使用規則下達到封裝的目的。</p><p>兩個非常類似的 component，一個是遞增的 counter，一個則是遞減，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ForwardCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCounter(<span class="function">(<span class="params">prevCounter</span>) =&gt;</span> prevCounter + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Card</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BackwardCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCounter(<span class="function">(<span class="params">prevCounter</span>) =&gt;</span> prevCounter - <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Card</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而如果直接封裝 component 中的程式碼，就會違背 hook 的使用守則，那就是只能在 top level 中使用，因此需要將其封裝成 custom hook，其使用方式就是透過 <code>use</code> 開頭的 function，以便讓 React 知道它是一個 hook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCounter(<span class="function">(<span class="params">prevCounter</span>) =&gt;</span> prevCounter - <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Using-Custom-Hook"><a href="#Using-Custom-Hook" class="headerlink" title="Using Custom Hook"></a>Using Custom Hook</h3><p>有了 custom hook 之後，就可以透過它來取代原先的程式碼，和一般 hook 一樣，可以直接呼叫使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&quot;../hooks/use-counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ForwardCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  useCounter();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Card</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但很顯然的，如果只有做到這一步，就無法取得 custom hooks 其中的資料如 State，所以必須回傳期待在外部可以接收到的資料，回傳的格式可以是任何型別，如 object、array…，而這裡要特別注意的是，如果在多處使用同一個 custom hooks，彼此的資料是”不會共享”的，每次呼叫一次 custom hooks，就會重新產生一組新的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCounter(<span class="function">(<span class="params">prevCounter</span>) =&gt;</span> prevCounter + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ForwardCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useCounter();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Card</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Configuring-Custom-Hooks"><a href="#Configuring-Custom-Hooks" class="headerlink" title="Configuring Custom Hooks"></a>Configuring Custom Hooks</h3><p>延續上方的範例，在 ForwardCounter &amp; BackwardCounter 中其實有些微的差異，導致它們為一加一減 counter，custom hooks 其實就是一個 function，所以可以透過帶入參數來作為判斷的條件，上述的範例只要透過一個參數就可以判斷是否為遞增的 counter 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useCounter = <span class="function">(<span class="params">forwards = <span class="literal">true</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (forwards) &#123;</span><br><span class="line">        setCounter(<span class="function">(<span class="params">prevCounter</span>) =&gt;</span> prevCounter + <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setCounter(<span class="function">(<span class="params">prevCounter</span>) =&gt;</span> prevCounter - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">  &#125;, [forwards]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ForwardCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useCounter(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Card</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BackCounter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useCounter(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Card</span>&gt;</span>&#123;counter&#125;<span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fetch in React</title>
      <link href="/react/20220711/20001/"/>
      <url>/react/20220711/20001/</url>
      
        <content type="html"><![CDATA[<p>這章節將透過原生 JavaScript 最簡單的方式 - <code>fetch</code> 在 React 專案中送出 request，並 handle API 所回傳錯誤訊息</p><span id="more"></span><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section14/commit/c4b73b1fd8a91040decd223517efe7fb50669006">Code</a></p><p>首先，如果是透過 <code>fetch</code> 送出 request，第一個參數就是 API url，第二個參數則是 header 相關參數，如果沒有特別設定 header，預設就會送出 GET method</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [movies, setMovies] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fetchMoviesHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">&quot;https://swapi.dev/api/film&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;section&gt;</span><br><span class="line">        &lt;button onClick=&#123;fetchMoviesHandler&#125;&gt;Fetch Movies&lt;/button&gt;</span><br><span class="line">      &lt;/section&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>fetch</code> 本身是一個 async Promise，所以我們可以透過 <code>then</code> 接收回傳內容，而如果格式為 json，需要透過 <code>response.json()</code> 取得回傳資料，一個最簡單取得 GET request 的方式就完成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchMoviesHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">&quot;https://swapi.dev/api/film&quot;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> setMovies(data));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Using-async-await"><a href="#Using-async-await" class="headerlink" title="Using async/await"></a>Using async/await</h2><p>既然 <code>fetch</code> 是一個 async Promise，就可以透過原生 async/await 來改寫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchMoviesHandler = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://swapi.dev/api/film&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line"></span><br><span class="line">  setMovies(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Handing-Loading-amp-Data-States"><a href="#Handing-Loading-amp-Data-States" class="headerlink" title="Handing Loading &amp; Data States"></a>Handing Loading &amp; Data States</h2><p><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section14/commit/9c3ad7e3aabd799e4d6e1e39cc03b7ef26e810a7">Code</a></p><p>在實際的情況。透過 HTTP request 取得資料時，會因為網路速度或後端 Server 運作等因素，造成在資料取得的過程中，會有一段時間不等的空檔，在 UI 加上 loading 狀態是提升 UX 的常見作法之一。</p><p>在 React 中，一個最單純的方式就是透過一個 State 來管理 loading 狀態，並在送出 HTTP request 時，開啟狀態，並在收到 response 時，無論結果為何，一併關閉狀態</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchMoviesHandler = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  setLoading(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://swapi.dev/api/film&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line"></span><br><span class="line">  setMovies(data);</span><br><span class="line">  setLoading(<span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Handling-Http-Errors"><a href="#Handling-Http-Errors" class="headerlink" title="Handling Http Errors"></a>Handling Http Errors</h2><p><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section14/commit/7255fabc8620a2673ad18c0b88bd8f2baae8f0c1">Code</a></p><p>在送出 Http reqeust 後，可能因為參數錯誤等問題，Http response 會回傳 status code 4XX 或 5XX 來表示這類型的錯誤，而特別要注意的是，有回傳這類型的錯誤代表 Http request 還是有正常送出，並成功取得回饋</p><p>而在 <code>fetch</code> API 中，發生這種情況不會回傳於 promise reject，而是同樣回傳於 resolve，只是會將 <code>response.ok</code> 設為 <code>false</code>，所以無法透過串接 <code>catch</code> 取得這個錯誤，如果我們希望在接受到這個錯誤後，拋出對應的錯誤訊息於 UI 上以讓使用者辨別當下狀態，可以透過 <code>try catch</code> 方式包覆這段程式碼，並在 <code>response.ok</code> 為 <code>false</code> 的情況下，使用 <code>new Error</code> 建立對應訊息於 <code>catch</code> 中接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [error, setError] = useState(<span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchMoviesHandler = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    setLoading(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://swapi.dev/api/film&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Something went wrong!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line"></span><br><span class="line">    setMovies(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    setError(error.message);</span><br><span class="line">  &#125;</span><br><span class="line">  setLoading(<span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Using-useEffect-For-Requests"><a href="#Using-useEffect-For-Requests" class="headerlink" title="Using useEffect() For Requests"></a>Using useEffect() For Requests</h2><p>在實際的應用中，其實不會等到使用者觸發點擊的行為才會送出 request 來取得資料，通常是在使用者一進到這個頁面就自動為它取得對應的資料，這時候就可以透過 <code>useEffect()</code>，而如果 dependency array 為空，就只有 component 第一次 render 時會觸發</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchMoviesHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetchMoviesHandler();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>但有時候會因為其他的狀態條件而使的我們必續持續監聽 dependency 來確保持續取得對應的資料，這時候就要把其中對應的 State 或 function 加到 dependency array 之中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetchMoviesHandler();</span><br><span class="line">&#125;, [fetchMoviesHandler]);</span><br></pre></td></tr></table></figure><p>但如果只要做到這一步，就會造成每次 component re-render 都會觸發，所以需要在該 funciton 建立時，透過 <code>useCallback()</code> 來避免不必要的 invoke</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchMoviesHandler = useCallback(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="Sending-a-POST-Request"><a href="#Sending-a-POST-Request" class="headerlink" title="Sending a POST Request"></a>Sending a POST Request</h2><p><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section14/commit/b0cffff946655ca3a85102c2ace79c03fadc2801">Code</a></p><p>為了單純學習 React，但又希望可以實際串接 API 模擬真實開發狀況，可以使用一個 Google 的服務 - firebase，這個服務可以很簡單的透過 Google 帳號註冊並免費使用 ; 註冊後，可以直接新增專案，而 firebase 提供 2 種資料庫選擇，如果是簡單的應用，可以直接使用 Realtime Database，反之則可使用 Firestore Database。</p><p>於 firebase 中新增專案後，每個專案都會提供一個網址，這就是 API 執行的目標對象 ; 同樣地，也可以透過原生語法 <code>fetch</code> 來串接，這次的範例希望透過 POST 動態新增資料，並透過 GET 取得資料庫中的資料。</p><p>firebase API 可以自行在它提供的網址後方加上名稱，就會自動建立在資料庫中，而 <code>fetch</code> 第二個參數可以提入 http 格式，前面的範例因為是使用預設的 GET 所以可以忽略不填，這次則是要將 method 改為 POST，body 則是要送出的資料，但要轉成 JSON 格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addMovieHandler = <span class="keyword">async</span> (movie) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;https://react-http-77951-default-rtdb.firebaseio.com/movies.json&quot;</span>, &#123;</span><br><span class="line">    method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(movie),</span><br><span class="line">    header: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> data = response.json();</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>送出 request 後，會得到一組亂數產生的 ID key，value 則為我們送出的資料</p><p><img src="response-data.png"></p><p>而取得的方式，可以將上方 GET 得範例網址改為與 POST 相同，即可得到對應的資料</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Fetch_API/Using_Fetch">Using Fetch</a><br><a href="https://console.firebase.google.com/u/0/project/react-http-77951/database/react-http-77951-default-rtdb/data/~2F">Firebase</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Error Boundaries</title>
      <link href="/react/20220710/12258/"/>
      <url>/react/20220710/12258/</url>
      
        <content type="html"><![CDATA[<p>有時候在操作網頁時，難免會遇到一些錯誤，這裡的錯誤指的不是程式碼中的 bug，而是可能會有搜尋沒有結果、網路連線或資料取得上出了問題，這時候就會需要有對應的回饋來讓使用者有一個比較完整的使用體驗。</p><span id="more"></span><p>在原生的 JavaScript 中，可以使用 <code>try catch</code> 來 handle 錯誤訊息，但在 React 中，這只適用於單一元件內，如果需要將錯誤訊息在父子元件中傳遞，就會需要 Error Boundary 來處理，而在 Class-based 中，有一個 Lifecycle - <code>componentDidCatch()</code> 可以處理這個問題 ; 但這裡要注意的是，在 functional component 中沒有完全對應的方法。</p><p>首先，新增一個錯誤情境在子元件中，判斷資料在特定條件下，會拋出錯誤訊息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChildrencomponentDidUpdate() &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state.users.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;No users provided!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著，會建立一個 Class-based component 來 handle 這些錯誤，它的基礎結構其實就和一般的 Class-based component 完全相同，並有一個 State 判斷是否有錯誤，如果有就回傳錯誤提示，如果沒有就照常回傳 JSX</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      hasError: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Something went wrong!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比較特別的是，會有一個 Lifecycle - <code>componentDidCatch()</code> 來取得錯誤訊息，如果有錯誤，就更改判斷錯誤的 State</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      hasError: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidCatch</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">hasError</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Something went wrong!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式其實也很單純，就是把 ErrorBoundary 直接包住要 handle 的 component 即可，這麼一來，<code>componentDidCatch()</code> 所取得的 error 就會是其包覆的 comopnent 所傳遞的錯誤訊息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent</span></span><br><span class="line"><span class="keyword">import</span> Users <span class="keyword">from</span> <span class="string">&quot;./Users&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ErrorBoundary <span class="keyword">from</span> <span class="string">&quot;./ErrorBoundary&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFinder</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ErrorBoundary&gt;</span><br><span class="line">        &lt;Users /&gt;</span><br><span class="line">      &lt;/ErrorBoundary&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Class-based </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class-based component &amp; Context</title>
      <link href="/react/20220707/62283/"/>
      <url>/react/20220707/62283/</url>
      
        <content type="html"><![CDATA[<p>這章節將會介紹如何在 Class-based component 中使用 Context</p><span id="more"></span><p>因為 Class-based &amp; Funcitonal component 可以在同一個專案中共存，所以在 Context 的建立上完全相同，只有在使用的方式不一樣，一個簡單的 Context 如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users-context.js</span></span><br><span class="line"><span class="keyword">const</span> UsersContext = React.createContext(&#123;</span><br><span class="line">  users: []</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> DUMMY_USERS = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;u1&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;u2&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Manuel&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;u3&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Julie&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> usersContext = &#123;</span><br><span class="line">    users: DUMMY_USERS</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;UsersContext.Provider value=&#123;usersContext&#125;&gt;</span><br><span class="line">      &lt;UserFinder /&gt;</span><br><span class="line">    &lt;/UsersContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在使用上，其實沒有和 <code>Context.Comsumer</code> 完全對等的使用方式，而是要透過 <code>static</code> 定義 context，而且每個 Class-based component 只能有一組 context，如果需要多組 context 就需要另外找其他方式來實現 ，雖然大部分情況我們不會需要在一個 comopnent 內使用到多組 context</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UsersContext <span class="keyword">from</span> <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFinder</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = UsersContext;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>使用上則可以直接透過 <code>this.context</code> 指向對應的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFinder</span> <span class="keyword">extends</span> <span class="title">Comopnent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Send http reqeust...</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;<span class="attr">filteredUsers</span>: <span class="built_in">this</span>.context.users&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Class-based </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class-based Component Lifecycle</title>
      <link href="/react/20220706/50342/"/>
      <url>/react/20220706/50342/</url>
      
        <content type="html"><![CDATA[<p>因為在 Class-based 中無法使用任何 React hook，所以勢必有其他方式來取代 hook 所解決的問題，接下來接介紹取代 <code>useEffect()</code> 的方式 - Lifecycle</p><span id="more"></span><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>在 Class-based 中，取代 <code>useEffect()</code> 的方式就稱為 Lifecycle，其中有 3 組 function 分別表示 3 種 <code>useEffect()</code> 觸發的時機</p><ul><li><code>componentDidMount()</code>: component 生成時觸發，等同於 <code>useEffect(..., [])</code> 在 dependency array 為空的情況</li><li><code>componentDidUpdate</code>: component dependency 發生異動時觸發，等同於 <code>useEffect(..., [someValue])</code> dependency array 中的值改變時機</li><li><code>componentWillUnmount</code>: 在 component 從 DOM 移除時觸發，等同於 <code>useEffect()</code> cleanup function <code>useEffect(() =&gt; &#123;return () =&gt; &#123;...&#125;, [])</code>  </li></ul><h2 id="Lifecycle-Methods-in-Action"><a href="#Lifecycle-Methods-in-Action" class="headerlink" title="Lifecycle Methods in Action"></a>Lifecycle Methods in Action</h2><p>直接透過一個範例來了解 Class-based Lifecycle 可能會更加清楚，一個包含 <code>useEffect()</code> 的範例如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserFinder = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [filteredUsers, setFilteredUsers] = useState(DUMMY_USERS);</span><br><span class="line">  <span class="keyword">const</span> [searchTerm, setSearchTerm] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setFilteredUsers(</span><br><span class="line">      DUMMY_USERS.filter(<span class="function">(<span class="params">user</span>) =&gt;</span> user.name.includes(searchTerm))</span><br><span class="line">    );</span><br><span class="line">  &#125;, [searchTerm]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> searchChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setSearchTerm(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;input type=<span class="string">&#x27;search&#x27;</span> onChange=&#123;searchChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;Users users=&#123;filteredUsers&#125; /&gt;</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>useEffect()</code> 以外的改寫在上一章節中都提到過了，所有 State 會由 <code>this.state</code> object 在 <code>constructor</code> 內定義，event 可以直接在 <code>class</code> 內定義，但在 JSX 上呼叫時需透過 <code>bind(this)</code> 使其指向 class 本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserFinder</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      filteredUsers: DUMMY_USERS,</span><br><span class="line">      searchTerm: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">searchChangeHandler</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      searchTerm: event.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;search&quot;</span> onChange=&#123;<span class="built_in">this</span>.searchChangeHandler.bind(<span class="built_in">this</span>)&#125; /&gt;</span><br><span class="line">        &lt;Users users=&#123;<span class="built_in">this</span>.state.filteredUsers&#125; /&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><p>而 <code>useEffect()</code> 就需要透過 Lifecycle 來改寫了，因為這組 <code>useEffect()</code> 有一個 dependency searchTerm，所以使用的 Lifecycle 是 <code>componentDidUpdate</code>，其中兩個參數如下</p><ul><li>prevProps: Props snapshot</li><li>prevState: State snpashot</li></ul><p>如果需要透過 State 作為 dependency，就會需要判斷 State 前後的值是否相等，否則當 State 異動時，就會造成 infinite loop 的情況</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.searchTerm !== <span class="built_in">this</span>.state.searchTerm) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      filteredUsers: DUMMY_USERS.filter(<span class="function">(<span class="params">user</span>) =&gt;</span></span><br><span class="line">        user.name.includes(<span class="built_in">this</span>.state.searchTerm)</span><br><span class="line">      ),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>而 <code>componentDidMount()</code> 則是在 component 生成時，只會執行一次，使用情境常會在許多一次性的行為，如http 驗證登入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// Send http request</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    filteredUsers: DUMMY_USERS</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p>則是在 component 被移除時觸發，如上範例因為 DUMMY_USERS 內有三筆資料，透過 <code>map()</code> 在 JSX 中生成 3 組 User component，如果切換移除 User component， <code>componentWillUnmount</code> 這個 Lifecycle 也就會分別執行 3 次</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Class-based </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class-based Component</title>
      <link href="/react/20220706/10203/"/>
      <url>/react/20220706/10203/</url>
      
        <content type="html"><![CDATA[<p>目前為止 React 所有章節的內容，都是由 function 來建立 component，function 中有參數 props 來傳遞父子元件的資料，並回傳 JSX 渲染頁面 ; 而在 React 中，透過 function 建立 component 其實不是唯一的方式，React 還可以透過 class 來建立 component，但這完全是選擇性的，即便沒有學會這種方式，還是完全可以開發 React ; 這種方式可能會在一些比較早期的 React 專案或 third-party libary 中見到。  </p><span id="more"></span><h2 id="What-amp-Why"><a href="#What-amp-Why" class="headerlink" title="What &amp; Why"></a>What &amp; Why</h2><p>在 React 16.8 以前，只能透過 Class-based component 來處理 State 資料，而從 React 16.8 開始，新增了許多過去章節所提到的 React hooks，這使的我們可以完全透過 Functional component 來開發 React，而這裡要特別注意的是，這些 React hooks 無法在 Class-based component 中使用 ; 想當然爾，會有其他的方法來取代諸如 <code>useEffect()</code>、<code>useState()</code> 等 React hooks 所解決的問題。</p><h2 id="Adding-a-First-Class-based-Component"><a href="#Adding-a-First-Class-based-Component" class="headerlink" title="Adding a First Class-based Component"></a>Adding a First Class-based Component</h2><p>一個最基本的 Funcitonal component 範例如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&#123;classes.user&#125;</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要將其透過 Class-based 改寫，首先，其實和原生的 JavaScript 語法一樣，透過 <code>class</code> 建立，只是這裡比較特別的是，不會透過 <code>construcor</code> 建立初始值，而是透過一個 render function 回傳 JSX </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&#123;classes.user&#125;</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接著可能會問到，那麼該如何取得 <code>props</code> 呢 ? 不同於 functional 直接在第一個參數取得，這裡需要透過 react import Component，再透過原生 JavaScript 語法 <code>extends</code> 來繼承，這麼一來就可以透過 <code>this.props</code> 來取得 <code>props</code> 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&#123;classes.user&#125;</span>&gt;</span>&#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="共存"><a href="#共存" class="headerlink" title="共存"></a>共存</h3><p>還有一個很重要的觀念是，在 React 16.8 以前，只有 Class-based component 可以處理 State，這也表示這兩種建立 React component 的方式是可以在同一個專案中共存的! </p><p>當然一般如果是從頭開始一個專案，還是會比較建議從一而終選擇一種方式開發，而從上面簡單的範例中就可以看出，Functional component 明顯更簡潔一點，這也就是它在新的 React 中更受歡迎的原因了。</p><h2 id="Work-with-State-and-Event"><a href="#Work-with-State-and-Event" class="headerlink" title="Work with State and Event"></a>Work with State and Event</h2><p>接著看到一個稍微複雜一點的 component，看完可能會更堅信 Functional 是更簡潔的方式 ; 這個 component 包含了 State &amp; Event，先來看到原始 Functional 的版本，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&quot;./User&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DUMMY_USERS = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;u1&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;u2&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Manuel&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;u3&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Julie&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Users = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [showUsers, setShowUsers] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleUsersHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setShowUsers(<span class="function">(<span class="params">curState</span>) =&gt;</span> !curState);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usersList = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;DUMMY_USERS.map(<span class="function">(<span class="params">user</span>) =&gt;</span> (</span><br><span class="line">        &lt;User key=&#123;user.id&#125; name=&#123;user.name&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;classes.users&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;toggleUsersHandler&#125;&gt;</span><br><span class="line">        &#123;showUsers ? <span class="string">&#x27;Hide&#x27;</span> : <span class="string">&#x27;Show&#x27;</span>&#125; Users</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &#123;showUsers &amp;&amp; usersList&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Users;</span><br></pre></td></tr></table></figure><p>透過 Class 來改寫的話，首先，一樣透過 extends Component 來建立 component，並透過 render function 回傳 JSX</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> usersList = (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;DUMMY_USERS.map(<span class="function">(<span class="params">user</span>) =&gt;</span> (</span><br><span class="line">          &lt;User key=&#123;user.id&#125; name=&#123;user.name&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;classes.users&#125;&gt;</span><br><span class="line">        &lt;button onClick=&#123;toggleUsersHandler&#125;&gt;</span><br><span class="line">          &#123;showUsers ? <span class="string">&#x27;Hide&#x27;</span> : <span class="string">&#x27;Show&#x27;</span>&#125; Users</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &#123;showUsers &amp;&amp; usersList&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>在 Class-based 中，並沒有 React hooks 來建立 State，如果要建立 State，必須透過原生語法 <code>construcor</code> 建立，而且名稱規定就是 <code>this.state</code>，值只能是一個 object，其中的每一個 key 就是一個 State 的值，value 就可以是任意型別了; 如果要使用 State，就必須在前方加上 <code>this.state</code> 指定目標 key</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      showUsers: <span class="literal">true</span>,</span><br><span class="line">      more: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> usersList = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;classes.users&#125;&gt;</span><br><span class="line">        &lt;button onClick=&#123;toggleUsersHandler&#125;&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.state.showUsers ? <span class="string">&#x27;Hide&#x27;</span> : <span class="string">&#x27;Show&#x27;</span>&#125; Users</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.showUsers &amp;&amp; usersList&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>如果要建立 Event，可以直接在 Class 中建立 function，改變 State 則需透過呼叫 <code>this.setState</code>，這個方法就是來自於繼承 Component，其中的值如果單純以新的值覆蓋，就帶入一個 object，其中只要帶入想更改的 key，其餘沒有帶入的 key 則會以 merge 的方式維持不變，最後一樣透過 <code>this.toggleUsersHandler</code> 來呼叫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      showUsers: <span class="literal">true</span>,</span><br><span class="line">      more: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toggleUsersHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      showUsers: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> usersList = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;classes.users&#125;&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.toggleUsersHandler&#125;&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.state.showUsers ? <span class="string">&#x27;Hide&#x27;</span> : <span class="string">&#x27;Show&#x27;</span>&#125; Users</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.showUsers &amp;&amp; usersList&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果需要依賴舊的值來產生新的值，則和 <code>useState()</code> 一樣帶入 function，第一個參數就是舊的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">toggleUsersHandler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function">(<span class="params">curState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">showUsers</span>: !curState.showUsers&#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>到目前為止看似一切正常，但當我們按下按鈕呼叫這個 Event 後，會出現以下 error log</p><p><img src="this.png"></p><p>原因其實不在於 React，而在於原生 JavaScript <code>this</code> 的關係，為了避免呼叫 function 時，<code>this</code> 沒有指向 class 的問題，在呼叫 function 時可以透過 <code>bind(this)</code> 即時將 <code>this</code> 指向 class</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> usersList = ...;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;classes.users&#125;&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="built_in">this</span>.toggleUsersHandler.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.state.showUsers ? <span class="string">&#x27;Hide&#x27;</span> : <span class="string">&#x27;Show&#x27;</span>&#125; Users</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &#123;<span class="built_in">this</span>.state.showUsers &amp;&amp; usersList&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h3><p>以為結束了嗎 ? 修正上一個 <code>this</code> 的 error log 後，發現又出現另外一個 error log，這個問題一樣也是原生 JavaScript 的關係，在 React Class-based component 中，我們透過 <code>extends Component</code> 繼承了許多 React 的方法，所以在使用前，需要在 <code>constructor</code> 中呼叫 <code>super()</code></p><p><img src="super.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>();</span><br><span class="line">  <span class="built_in">this</span>.state = &#123;</span><br><span class="line">    showUsers: <span class="literal">true</span>,</span><br><span class="line">    more: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
            <tag> Class-based </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optimizing with useMemo()</title>
      <link href="/react/20220705/38306/"/>
      <url>/react/20220705/38306/</url>
      
        <content type="html"><![CDATA[<p>在先前的章節中，介紹了透過 <code>React.memo()</code> 和 <code>useCallback()</code> 來解決父子元件資料傳遞上，非必要 re-render 的問題，而這章節將介紹另一個 hook - <code>useMemo()</code> 來對子元件本身效能上的優化</p><span id="more"></span><p><code>useMemoe()</code> 與 <code>React.memo()</code> 的差異在於 <code>useMemo()</code> 著重於避免元件內複雜的邏輯被非必要的重複執行</p><p>一組簡單的範例如下，一個 component DemoList 有一個數字陣列，透過一個 sort function 將其中的值依大小排列，接著在父元件導入這個 component</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DemoList.js</span></span><br><span class="line"><span class="keyword">const</span> DemoList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [listItems, setListItems] = useState([<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> sortedList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Items sorted&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> listItems.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;DEMOLIST RUNNING&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;sortedList.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">      &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">    ))&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [allowToggle, setAllowToggle] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allowToggleHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setAllowToggle(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;DemoList /&gt;</span><br><span class="line">    &lt;Button onClick=&#123;allowToggleHandler&#125;&gt;Allow Toggling&lt;/Button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果沒有別處理，在點擊 Allow Toggling 按鈕時，因為 State 改變，所以 DemoList 也會 re-render，自然會再次執行 sort function;如果要避免這種情況，就可以透過 <code>useMemo()</code> 將 sort function 寫入，並在第二個參數 dependency array 中放入 State listItems，這麼一來就只有在 dependency 發生變動時才會再次執行 sort function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedList = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Items sorted&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> listItems.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;, [listItems]);</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/Jerry-Yeh-React-The-Complete-Guide-Section12/commit/4d7332f6e034ad8ec7f4bfbe94a9b3cb17d02eaa">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>State Scheduling &amp; Batching</title>
      <link href="/react/20220705/60466/"/>
      <url>/react/20220705/60466/</url>
      
        <content type="html"><![CDATA[<p>這章節將進一步套討 React State 更新與 Batch 策略 </p><span id="more"></span><p>在前面的章節中，反覆提到一個很重要的觀念就是，如果 State 發生變化，React 就會 re-render component，但時常在操作畫面時，可能一個動作就操作多筆 State，一瞬間多次 re-render 勢必會造成不必要的資源消耗，因此，React 預設使用了一個機制 - Batch Update 來解決這個問題。</p><p>在每次透過 setState 來更新 State 時，其實並不是在程式碼位置的當下”馬上”更新並 re-render component，只是因為電腦運作得非常快讓我們覺得是立即執行，而實際上其實會被放進 Schedule 等待執行，直到這個行為的 function 內所有的 setState 程式碼跑完後，React 會進行一次 Batch Update 一口氣更新所有 State，並只 re-render “一次”，進而省略不必要 re-render 的效能消耗 ; 但 Batch Update 有一個前提是這些 State Update 必須是 sync，如果是 async event 如 promise 或 setTimeout …等，就無法被視為同一個 Schedule 一同執行。</p><p>一個簡單的範例如下，在一次的點擊事件中，update State 兩次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCounter(counter + <span class="number">1</span>);</span><br><span class="line">    setCounter(counter + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;App&#x27;</span>&gt;</span><br><span class="line">      &lt;h1&gt;<span class="built_in">Function</span> Component&lt;/h1&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        counter: &#123;counter&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;br/&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;Click me&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>結果 counter 會是 1，因為這兩次的 State updated 會放進 schedule 而透過 batch update 一起執行，所以其實其中的 counter 都會是在更新前的 0，更新的動作就可以視為一模一樣的動作發生了兩次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCounter(<span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">  setCounter(<span class="number">0</span> + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那麼如果要達到 +2 的目的，可以怎麼修改這段程式碼呢 ?</p><p>在先前的章節有提到，因為多組 State 更新時，可能會發生無法取得最新 State 的潛在問題，所以如果要明確取得 State 最新的值，在 setState 中就要改使用 callback function，其中的參數就會是最新的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> increase = <span class="function"><span class="params">prevCounter</span> =&gt;</span> prevCounter + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> handlerClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCOunter(increase);</span><br><span class="line">  setCOunter(increase);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://lance.coderbridge.io/2021/06/10/react-batch-update-in-hooks-and-react18/">React 的 batch update 策略</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How React really work?</title>
      <link href="/react/20220703/4435/"/>
      <url>/react/20220703/4435/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>這章節將進一步介紹 React 底層的運作方式，透過了解這些觀念，有助於我們更正確的使用 React 來開發專案</p><span id="more"></span><h2 id="How-React-really-work"><a href="#How-React-really-work" class="headerlink" title="How React really work?"></a>How React really work?</h2><p>在透過 create-react-app 建立 React 專案時，預設會安裝兩個與 React 有關的套件，分別是 React 核心 react 與 react-dom，在 react 核心中，其實並不會直接處理 DOM 相關內容，更直接的說法是不會案瀏覽器之間有互動，react 核心只負責處理 react 開發時的基本單位 - Components，而 Components 會處理所有資寮來源，如下圖所示:</p><pre class="mermaid">graph TD;  A["Props: Data from parent component"] --> D[Components];  B["Context: Component-wide data"] --> D[Components];  C["State: Internal data"] --> D[Components];  D[Components] --> E["Real DOM: What the use sees"]</pre><ul><li>Props: 來自父元件的資料</li><li>Context: Component 共用的資料</li><li>State: Component 內部的資料</li></ul><p>而在 react 核心處理完 Components 資料時，每當有資料上的更新，就會產生重新執行 component function，產生 React Virtual DOM，並比對更新前後的差異，再由 react-dom 來更新實際 DOM 不同之處;因為更新實際 DOM 的效能成本是很高的，因此先由比對 React Virtual DOM 的差異，再更新實際 DOM 必要之處，就可以進可能的減少效能上的消耗，所以重新執行 component function 並不等於重新選染 DOM</p><pre class="mermaid">flowchart TB  subgraph Components  a1["Re-evaluated whenever props, state or context changes"]  a2["React executes component functions"]  end  subgraph Real-DOM  b1["Changes to the real DOM are only made for differences between evaluations"]  end  Components --> Real-DOM</pre><h2 id="Child-Component-Re-evaluation"><a href="#Child-Component-Re-evaluation" class="headerlink" title="Child Component Re-evaluation"></a>Child Component Re-evaluation</h2><p>前面提到，當 component 關聯的資料發生異動時，component function 都會被再次呼叫，return 中的 JSX 也會再次被回傳，這代表其中的 child component 也會再次呼叫 component function，一個簡單的範例如下，透過 parent component State 來控制 child component 的存在與否</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> DemoOoutput <span class="keyword">from</span> <span class="string">&quot;./components/Demo/DemoOutput&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&quot;./components/UI/Button/Button&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showParagraph, setShowParagraph] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;APP RUNNING&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleParagraphHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setShowParagraph(<span class="function">(<span class="params">prevShowParagraph</span>) =&gt;</span> !prevShowParagraph);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hi there!&lt;/h1&gt;</span><br><span class="line">      &lt;DemoOoutput show=&#123;showParagraph&#125; /&gt;</span><br><span class="line">      &lt;Button onClick=&#123;toggleParagraphHandler&#125;&gt;Toggle ParaGraph!&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DemoOutput.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DemoOoutput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DEMOOUT RUNNING&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.show ? &quot;This is new!&quot; : &quot;&quot;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="console-log.png"></p><p>這樣的範例可能會很直覺地認為因為 child component 所 props 的 State 發生異動，所以 child component function 自然也會再次呼叫，但當我們將這個 props 改成固定值，也就是無論 parent component State 如何變動，child component 的值也不受影響</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showParagraph, setShowParagraph] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;APP RUNNING&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleParagraphHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setShowParagraph(<span class="function">(<span class="params">prevShowParagraph</span>) =&gt;</span> !prevShowParagraph);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hi there!&lt;/h1&gt;</span><br><span class="line">      &lt;DemoOoutput show=&#123;<span class="literal">false</span>&#125; /&gt;</span><br><span class="line">      &lt;Button onClick=&#123;toggleParagraphHandler&#125;&gt;Toggle ParaGraph!&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>結果仍然會發現，child component 即使值未受影響，component function 依然被呼叫了! 因為當 component 因資料異動所觸發的 re-evaluation，其 JSX 中的 child component 也是這個 component 的一部分，自然也會跟著再次呼叫，這裡就指出了一個問題，如果在上層有太多非必要的資料異動，勢必會接連帶動與資料無關的 child component 發生 re-evaluation，進而造成效能上的浪費。</p><h2 id="Preventing-Unnecessary-Re-Evaluation-with-React-memo"><a href="#Preventing-Unnecessary-Re-Evaluation-with-React-memo" class="headerlink" title="Preventing Unnecessary Re-Evaluation with React.memo()"></a>Preventing Unnecessary Re-Evaluation with React.memo()</h2><p>為了解決上述的問題，React 提供了一個方法 - <code>React.memo()</code> 來解決這個問題，只需要在非必要 re-render child component 內的 <code>export</code> 中，透過 <code>React.memo()</code> 回傳 component function，就可以避免這種情況發生</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DemoOoutput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;DEMOOUT RUNNING&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.show ? &quot;This is new!&quot; : &quot;&quot;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(DemoOoutput);</span><br></pre></td></tr></table></figure><h3 id="使用時機"><a href="#使用時機" class="headerlink" title="使用時機"></a>使用時機</h3><p>既然這個方法可以避免因非必要的呼叫所造成的效能消耗，那為什麼我們不在所有 child component 這麼使用呢 ? 因為這個方法其實也有他的效能成本，為了比較資料是否有變動，勢必就要儲存舊的資料，所以如果這個 component 無論什麼情況都會發生 re-evaluation，那這麼做就只是造成多餘的效能消耗而已了。</p><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>除此之外，<code>React.memo()</code> 還有另一個使用上的限制，同樣的方法套用到另一個資料也沒有改動的 component Button 中，會發現 component function 還是被執行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&quot;./Button.module.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;BUTTON RUNNING&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button</span><br><span class="line">      type=&#123;props.type || <span class="string">&quot;button&quot;</span>&#125;</span><br><span class="line">      className=&#123;<span class="string">`<span class="subst">$&#123;classes.button&#125;</span> <span class="subst">$&#123;props.className&#125;</span>`</span>&#125;</span><br><span class="line">      onClick=&#123;props.onClick&#125;</span><br><span class="line">      disabled=&#123;props.disabled&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(Button);</span><br></pre></td></tr></table></figure><p>原因其實不在於 React 的特性，而是在於 <code>React.memo()</code> 其實是單純比較資料新舊值是否相同，可以看成透過 <code>===</code> 來判斷新舊值，而在原生 JavaScript 中，只有 primitive type 可以被這樣比較，其餘 object type 如 function、array or object 無論值是否相同，都因為 by reference 的特性而指向不同的 object，所以每次的 <code>toggleParagraphHandler</code> function 其實是相同行為的”不同” function。</p><h2 id="Preventing-Function-Re-Creation-with-useCallback"><a href="#Preventing-Function-Re-Creation-with-useCallback" class="headerlink" title="Preventing Function Re-Creation with useCallback()"></a>Preventing Function Re-Creation with useCallback()</h2><p>很顯然的，根據原生 JavaScript 的特性，要解決這個問題，只能從 object 資料的來源來著手，讓這筆 object 資料不被重新生成，而是始終指向同一個 object，為了達到這個目的，React 提供了一個 hook - <code>useCallback()</code> 來解決這個問題，其用法就和 <code>useEffect()</code> 一樣，第一個參數就是要執行的 function，第二個參數是一個 dependency array，array 中的參數就是執行時機的依據</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&quot;./components/UI/Button/Button&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showParagraph, setShowParagraph] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;APP RUNNING&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleParagraphHandler = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setShowParagraph(<span class="function">(<span class="params">prevShowParagraph</span>) =&gt;</span> !prevShowParagraph);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hi there!&lt;/h1&gt;</span><br><span class="line">      &lt;Button onClick=&#123;toggleParagraphHandler&#125;&gt;Toggle ParaGraph!&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>同 <code>useEffect()</code>，因為 function 中只有一個 <code>setShowParagraph()</code>，React 辯護自動將其當成 dependency，所以不必在 dependency array 中帶入。</p><h2 id="useCallback-and-its-Dependencies"><a href="#useCallback-and-its-Dependencies" class="headerlink" title="useCallback() and its Dependencies"></a>useCallback() and its Dependencies</h2><p>那麼什麼時候會需要把變數加入 dependency array 之中呢 ?</p><p>一個範例如下，新增一個按鈕，並透過這個按鈕控制一個 State 來掌握原先的按鈕是否能執行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&quot;./components/UI/Button/Button&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> DemoOutput <span class="keyword">from</span> <span class="string">&quot;./components/Demo/DemoOutput&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showParagraph, setShowParagraph] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [allowToggle, setAllowToggle] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;APP RUNNING&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> toggleParagraphHandler = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (allowToggle) &#123;</span><br><span class="line">      setShowParagraph(<span class="function">(<span class="params">prevShowParagraph</span>) =&gt;</span> !prevShowParagraph);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> allowToggleHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setAllowToggle(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;Hi there!&lt;/h1&gt;</span><br><span class="line">      &lt;DemoOutput show=&#123;showParagraph&#125; /&gt;</span><br><span class="line">      &lt;Button onClick=&#123;allowToggleHandler&#125;&gt;Allow Toggling&lt;/Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;toggleParagraphHandler&#125;&gt;Toggle ParaGraph!&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 dependency array 為空時，會發現無論怎麼點選 Allow Toggling 這個按鈕，Toggle ParaGraph 都不會發生作用，原因是我們透過 <code>useCallback()</code> 來阻止資料發生變異時，執行 component function 所重新生成的的動作，而在 JavaScript 中，function 執行時會產生一個 closure，在這裡因為 toggleParagraphHandler 沒有被重新生成，所以其中的 allowToggle 始終為原始的值，在這種情況就需要透過加入 dependency array 主動告訴 React 這個值需要被更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toggleParagraphHandler = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (allowToggle) &#123;</span><br><span class="line">    setShowParagraph(<span class="function">(<span class="params">prevShowParagraph</span>) =&gt;</span> !prevShowParagraph);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [allowToggle]);</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://dmitripavlutin.com/react-usecallback/">Your Guide to React.useCallback()</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spread HTML attribute in React</title>
      <link href="/react/20220628/12461/"/>
      <url>/react/20220628/12461/</url>
      
        <content type="html"><![CDATA[<p>在使用 HTML form 表單相關 elemnt 時，常會透過許多內建的 attribute 來定義格式，在 React 中，如果將這些 element 封裝成 component，可以透過 props 的方式彈性改變 attribute </p><span id="more"></span><p>一個封裝的 input component 如下，我們希望他可以彈性的改變 attribute 條件，注意這裡的 input prop 使用了兩層大括號 {}，原因是第一層是為了使用 string 以外的資料，第二層才是欲帶入 object data</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Form.js</span></span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">&#x27;./Input.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Form = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &lt;Input label=<span class="string">&quot;Amount&quot;</span> input=&#123;&#123;</span><br><span class="line">        id: <span class="string">&quot;amount&quot;</span>,</span><br><span class="line">        type: <span class="string">&quot;number&quot;</span>,</span><br><span class="line">        min: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        max: <span class="string">&quot;5&quot;</span>,</span><br><span class="line">        step: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        defaultValue: <span class="string">&quot;1&quot;</span></span><br><span class="line">      &#125;&#125;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接著在封裝的 input component 內，label 上的 <code>htmlFor</code> 其實就是原生的 <code>for</code>，用來讓 label 綁定對應的 element，而 input 透過 ES6 spread 直接展開 props.input object，就可以使 key 直接成為 element attribute，value 自然就是 attribute value。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input.js</span></span><br><span class="line"><span class="keyword">const</span> Input = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;label htmlFor=&#123;props.input.id&#125;&gt;&#123;props.label&#125;&lt;/label&gt;</span><br><span class="line">    &lt;input &#123;...props.input&#125;&gt;&lt;/input&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不只是 input，這樣的方法適用於各種 HTML element，透過這種方式就可以使 component 的應用上更加彈性</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section9/commit/13bb593e48b153251864042e40097d06b691a3ed">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diving into Forward Refs</title>
      <link href="/react/20220626/61058/"/>
      <url>/react/20220626/61058/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在 React 中，如果要透過 <code>useRef()</code> 取得 component 內的 element，並操作它執行一些行為，如 focus、activate 等，就會需要特殊的處理</p><span id="more"></span><p>在需求方面，我們希望在點選表單送出按鈕時，如果有欄位驗證沒有通過，可以 focus 到該欄位，以供使用者更改輸入內容。</p><p>首先，先將 form 表單內重複出現的 input 欄位進行封裝，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Login.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Login = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=&#123;classes.login&#125;&gt;</span><br><span class="line">      &#123;<span class="comment">/* &#123;emailState.value&#125; */</span>&#125;</span><br><span class="line">      &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">        &lt;Input</span><br><span class="line">          ref=&#123;emailInputRef&#125;</span><br><span class="line">          isValid=&#123;emailIsValid&#125;</span><br><span class="line">          id=<span class="string">&quot;email&quot;</span></span><br><span class="line">          type=<span class="string">&quot;email&quot;</span></span><br><span class="line">          label=<span class="string">&quot;E-mail&quot;</span></span><br><span class="line">          value=&#123;emailState.val&#125;</span><br><span class="line">          onChange=&#123;emailChangeHandler&#125;</span><br><span class="line">          onBlur=&#123;validateEmailHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Input</span><br><span class="line">          ref=&#123;passwordInputRef&#125;</span><br><span class="line">          isValid=&#123;passwordIsValid&#125;</span><br><span class="line">          id=<span class="string">&quot;password&quot;</span></span><br><span class="line">          type=<span class="string">&quot;password&quot;</span></span><br><span class="line">          label=<span class="string">&quot;Password&quot;</span></span><br><span class="line">          value=&#123;passwordState.val&#125;</span><br><span class="line">          onChange=&#123;passwordChangeHandler&#125;</span><br><span class="line">          onBlur=&#123;validatePasswordHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=&#123;classes.actions&#125;&gt;</span><br><span class="line">          &lt;Button type=<span class="string">&quot;submit&quot;</span> className=&#123;classes.btn&#125;&gt;</span><br><span class="line">            Login</span><br><span class="line">          &lt;/Button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div</span><br><span class="line">      className=&#123;<span class="string">`<span class="subst">$&#123;classes.control&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        props.isValid === <span class="literal">false</span> ? classes.invalid : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>`</span>&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;label htmlFor=&#123;props.id&#125;&gt;&#123;props.label&#125;&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&#123;props.type&#125;</span><br><span class="line">        id=&#123;props.id&#125;</span><br><span class="line">        value=&#123;props.value&#125;</span><br><span class="line">        onChange=&#123;props.onChange&#125;</span><br><span class="line">        onBlur=&#123;props.onBlur&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Input;</span><br></pre></td></tr></table></figure><h2 id="錯誤方法一"><a href="#錯誤方法一" class="headerlink" title="錯誤方法一"></a>錯誤方法一</h2><p>遇到這種需求，可能很直覺的會直接透過 <code>useRef()</code> 取得 input 欄位，再透過 <code>useEffect()</code> 觸發預期的效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div</span><br><span class="line">      className=&#123;<span class="string">`<span class="subst">$&#123;classes.control&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        props.isValid === <span class="literal">false</span> ? classes.invalid : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>`</span>&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;label htmlFor=&#123;props.id&#125;&gt;&#123;props.label&#125;&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        ref=&#123;inputRef&#125;</span><br><span class="line">        type=&#123;props.type&#125;</span><br><span class="line">        id=&#123;props.id&#125;</span><br><span class="line">        value=&#123;props.value&#125;</span><br><span class="line">        onChange=&#123;props.onChange&#125;</span><br><span class="line">        onBlur=&#123;props.onBlur&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但很不幸的是，透過這種直接綁定的方式，還是無法觸發 child component 內的 <code>useEffect()</code></p><h2 id="錯誤方法二"><a href="#錯誤方法二" class="headerlink" title="錯誤方法二"></a>錯誤方法二</h2><p>那如果嘗試在 parent component 透過 <code>useRef()</code> 綁定 component，並呼叫由 child component 提供的方法，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input.js</span></span><br><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> activate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div</span><br><span class="line">      className=&#123;<span class="string">`<span class="subst">$&#123;classes.control&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        props.isValid === <span class="literal">false</span> ? classes.invalid : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>`</span>&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;label htmlFor=&#123;props.id&#125;&gt;&#123;props.label&#125;&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        ref=&#123;inputRef&#125;</span><br><span class="line">        type=&#123;props.type&#125;</span><br><span class="line">        id=&#123;props.id&#125;</span><br><span class="line">        value=&#123;props.value&#125;</span><br><span class="line">        onChange=&#123;props.onChange&#125;</span><br><span class="line">        onBlur=&#123;props.onBlur&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login.js</span></span><br><span class="line"><span class="keyword">const</span> Login = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> emailInputRef = useRef();</span><br><span class="line">  <span class="keyword">const</span> passwordInputRef = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="comment">// props.onLogin(enteredEmail, enteredPassword);</span></span><br><span class="line">    <span class="keyword">if</span> (formIsValid) &#123;</span><br><span class="line">      authCtx.onLogin(emailState.value, passwordState.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!emailIsValid) &#123;</span><br><span class="line">      emailInputRef.current.activate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      passwordInputRef.current.activate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=&#123;classes.login&#125;&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">        &lt;Input</span><br><span class="line">          ref=&#123;emailInputRef&#125;</span><br><span class="line">          isValid=&#123;emailIsValid&#125;</span><br><span class="line">          id=<span class="string">&quot;email&quot;</span></span><br><span class="line">          type=<span class="string">&quot;email&quot;</span></span><br><span class="line">          label=<span class="string">&quot;E-mail&quot;</span></span><br><span class="line">          value=&#123;emailState.val&#125;</span><br><span class="line">          onChange=&#123;emailChangeHandler&#125;</span><br><span class="line">          onBlur=&#123;validateEmailHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Input</span><br><span class="line">          ref=&#123;passwordInputRef&#125;</span><br><span class="line">          isValid=&#123;passwordIsValid&#125;</span><br><span class="line">          id=<span class="string">&quot;password&quot;</span></span><br><span class="line">          type=<span class="string">&quot;password&quot;</span></span><br><span class="line">          label=<span class="string">&quot;Password&quot;</span></span><br><span class="line">          value=&#123;passwordState.val&#125;</span><br><span class="line">          onChange=&#123;passwordChangeHandler&#125;</span><br><span class="line">          onBlur=&#123;validatePasswordHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=&#123;classes.actions&#125;&gt;</span><br><span class="line">          &lt;Button type=<span class="string">&quot;submit&quot;</span> className=&#123;classes.btn&#125;&gt;</span><br><span class="line">            Login</span><br><span class="line">          &lt;/Button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>結果還是沒有預期的效果</p><h2 id="解決方式"><a href="#解決方式" class="headerlink" title="解決方式"></a>解決方式</h2><p>其實到方法二的實作為止並沒有錯誤，只是還缺少了兩個步驟來解決這個問題</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle()"></a>useImperativeHandle()</h3><p>第一步會需要用到一組新的 React Hooks - <code>useImperativeHandle()</code>，這組 hooks 有兩個參數</p><ul><li><p>ref<br>這個參數需要帶入的是 component function 的二個參數 <code>ref</code>，如果在 parent component 有透過 <code>useRef()</code> 綁定 component，就可以透過這個參數建立連結</p></li><li><p>callback function<br>這個 function 會回傳一個 object，其中的 key 代表 parent component 透過 <code>useRef()</code> 綁定所能呼叫的方法，value 則是 child component 被呼叫後將執行的行為</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input.js</span></span><br><span class="line"><span class="keyword">const</span> Input = <span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> activate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      focus: activate,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div</span><br><span class="line">      className=&#123;<span class="string">`<span class="subst">$&#123;classes.control&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        props.isValid === <span class="literal">false</span> ? classes.invalid : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>`</span>&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;label htmlFor=&#123;props.id&#125;&gt;&#123;props.label&#125;&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        ref=&#123;inputRef&#125;</span><br><span class="line">        type=&#123;props.type&#125;</span><br><span class="line">        id=&#123;props.id&#125;</span><br><span class="line">        value=&#123;props.value&#125;</span><br><span class="line">        onChange=&#123;props.onChange&#125;</span><br><span class="line">        onBlur=&#123;props.onBlur&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="React-forwardRef"><a href="#React-forwardRef" class="headerlink" title="React.forwardRef"></a>React.forwardRef</h3><p>最後，如果是這種綁定 child component 特定 element 的需求，還會需要一個步驟是透過 <code>React.forwardRef</code> 來建立這個 child component</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> activate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      focus: activate,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div</span><br><span class="line">      className=&#123;<span class="string">`<span class="subst">$&#123;classes.control&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        props.isValid === <span class="literal">false</span> ? classes.invalid : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>`</span>&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;label htmlFor=&#123;props.id&#125;&gt;&#123;props.label&#125;&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        ref=&#123;inputRef&#125;</span><br><span class="line">        type=&#123;props.type&#125;</span><br><span class="line">        id=&#123;props.id&#125;</span><br><span class="line">        value=&#123;props.value&#125;</span><br><span class="line">        onChange=&#123;props.onChange&#125;</span><br><span class="line">        onBlur=&#123;props.onBlur&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="React-ForwardRefRenderFunction"><a href="#React-ForwardRefRenderFunction" class="headerlink" title="React.ForwardRefRenderFunction"></a>React.ForwardRefRenderFunction</h3><p>可以做為 Component Function 參數放入 <code>React.forwardRef</code> 中</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Input = React.ForwardRefRenderFunction&lt;HTMLDivElement, InputProps&gt; = <span class="function">(<span class="params">props: InputProps, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ...;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section9/commit/f384875ab26fe41ebb133cb34a20401491f5e054">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rules of Hooks</title>
      <link href="/react/20220626/49936/"/>
      <url>/react/20220626/49936/</url>
      
        <content type="html"><![CDATA[<p>到目前為止已經介紹過不少 React Hooks，這章節將進一步這些 hooks 在使用上的限制</p><span id="more"></span><h2 id="Only-call-React-Hooks-in-React-Functions"><a href="#Only-call-React-Hooks-in-React-Functions" class="headerlink" title="Only call React Hooks in React Functions"></a>Only call React Hooks in React Functions</h2><p>只有在兩種環境才使用 React Hooks </p><ul><li>React Components Functions<br>這在前面章節也不斷提到，React Hooks 無法運行在 Components Function 之外</li><li>Custom Hooks<br>這在之後的章節會再進一步介紹，React Hooks 還可以客製化生成</li></ul><h2 id="Only-call-React-Hooks-in-Top-Level"><a href="#Only-call-React-Hooks-in-Top-Level" class="headerlink" title="Only call React Hooks in Top Level"></a>Only call React Hooks in Top Level</h2><ul><li>Don’t call them in nested Functions<br>在滿足第一個前提之下，React Hooks 只能直接被使用，無法再被其他 function 封裝</li><li>Don’t call them in any block statements<br>不只是 function 內，所有 block statements (if、switch…) 也無法使用</li></ul><h2 id="Unofficial-Rule-for-useEffect"><a href="#Unofficial-Rule-for-useEffect" class="headerlink" title="Unofficial Rule for useEffect()"></a>Unofficial Rule for useEffect()</h2><p>還有一個關於 <code>useEffect()</code> 的非官方限制，那就是如果在 <code>useEffect()</code> callback function 中參照的資料，那它就應該被加入 dependency，較現代 IDE 如 VSCode 就會直接給予提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> identifier = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Checking from validity!&quot;</span>);</span><br><span class="line">    setFormIsValid(emailValid &amp;&amp; passwordValid);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;CLEANUP&quot;</span>);</span><br><span class="line">    <span class="built_in">clearTimeout</span>(identifier);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [emailValid]);</span><br></pre></td></tr></table></figure><p><img src="useEffect-limitations.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section9/commit/a9f6bf098dd89abdae690220b9292f154a5ef186">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Context API</title>
      <link href="/react/20220626/41766/"/>
      <url>/react/20220626/41766/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在開發中，時常會遇到一個問題是，因為 component 層層區分，當有一個子元件要傳資料給另外一條支線的子元件時，如果透過 props 傳遞就會變得相當麻煩，中間不需要得到這些資訊的 component 也需要幫忙傳遞，就像是如果今天要送一個禮物給堂弟，我不能直接拿給他，只能先傳給父親，再傳給爺爺，接這再傳給堂弟的父親，最後才會交到他的手上，在 Vue 中，可以透過 <code>provide/inject</code> &amp; <code>Vuex</code> 來解決這些問題，React 中提供了一些方法稱為 - Context API</p><span id="more"></span><p>從下方的 component-tree 可以看到，即便是功能這麼單純的 component，在子元件之間的資料傳遞也想當不便，很顯然的我們需要一些其他方法來解決這些問題</p><p><img src="component-tree.png"></p><h2 id="Create-Context-File"><a href="#Create-Context-File" class="headerlink" title="Create Context File"></a>Create Context File</h2><p>首先，我們需要先建立一個檔案來存放這些共用資料，這樣的檔案可大可小，名稱上一般統一使用 store 作為資料夾名稱，再根據功能為檔案命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">- store</span><br><span class="line">  - auth-context.js</span><br></pre></td></tr></table></figure><p>在這個檔案中，呼叫 <code>React.createContext()</code> 來建立 context，並將欲共用的變數放在裡面，最後透過 <code>export</code> 匯出回傳值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AuthContext = React.createContext(&#123;</span><br><span class="line">  isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AuthContext;</span><br></pre></td></tr></table></figure><h2 id="Using-Context-with-Provider"><a href="#Using-Context-with-Provider" class="headerlink" title="Using Context with Provider"></a>Using Context with Provider</h2><p>建立了 Context 後，接著就是要將這些資料分享到需要的 component 上，這時候就可以透過 Context Provider 將對應的 JSX 包住，這麼一來其中所有的 child component 就都能使用這些資料了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AuthContext <span class="keyword">from</span> <span class="string">&quot;./store/auth-context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;AuthContext.Provider&gt;</span><br><span class="line">        &lt;MainHeader isAuthenticated=&#123;isLoggedIn&#125; onLogout=&#123;logoutHandler&#125; /&gt;</span><br><span class="line">        &lt;main&gt;</span><br><span class="line">          &#123;!isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Login</span> <span class="attr">onLogin</span>=<span class="string">&#123;loginHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">          &#123;isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Home</span> <span class="attr">onLogout</span>=<span class="string">&#123;logoutHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">        &lt;/main&gt;</span><br><span class="line">      &lt;/AuthContext.Provider&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>甚至可以更進一步簡化將 <code>React.Fragment</code> 移除，因為這本來就是為了維持回傳單一組元件而存在</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider&gt;</span><br><span class="line">      &lt;MainHeader isAuthenticated=&#123;isLoggedIn&#125; onLogout=&#123;logoutHandler&#125; /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &#123;!isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Login</span> <span class="attr">onLogin</span>=<span class="string">&#123;loginHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Home</span> <span class="attr">onLogout</span>=<span class="string">&#123;logoutHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/AuthContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context Consumer"></a>Context Consumer</h2><p>取得使用權後，還需要將資料個別放置到對應的地方，這次使用的對象是 MainHeader 內的 Navigation，同樣需要使用到另一組 context function - Consumer，不同的是，在裡面會有一組 callback function，context data 會由 function parameters 取得，最後 return JSX</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> AuthContext <span class="keyword">from</span> <span class="string">&quot;../../store/auth-context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Navigation = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Consumer&gt;</span><br><span class="line">      &#123;<span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;nav className=&#123;classes.nav&#125;&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &#123;ctx.isLoggedIn &amp;&amp; (</span><br><span class="line">                &lt;li&gt;</span><br><span class="line">                  &lt;a href=<span class="string">&quot;/&quot;</span>&gt;Users&lt;/a&gt;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">              )&#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          &lt;/nav&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &lt;/AuthContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Navigation;</span><br></pre></td></tr></table></figure><h2 id="Default-Value"><a href="#Default-Value" class="headerlink" title="Default Value"></a>Default Value</h2><p>但到目前為止會看到出現以下 error log，原因是 Context 中已經有預設值，但 Consumer 中所使用的初始值須由 Provider 提供，所以還需要在 Provider 加上初始值</p><p><img src="provider-without-default-value.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;MainHeader isAuthenticated=&#123;isLoggedIn&#125; onLogout=&#123;logoutHandler&#125; /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &#123;!isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Login</span> <span class="attr">onLogin</span>=<span class="string">&#123;loginHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Home</span> <span class="attr">onLogout</span>=<span class="string">&#123;logoutHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/AuthContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這麼一來就可以將原先透過 props 傳遞的方式移除了，並由 component 內的 State 來代表這個值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        isLoggedIn, <span class="comment">// Using State</span></span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;MainHeader onLogout=&#123;logoutHandler&#125; /&gt; <span class="comment">// remove props</span></span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &#123;!isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Login</span> <span class="attr">onLogin</span>=<span class="string">&#123;loginHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Home</span> <span class="attr">onLogout</span>=<span class="string">&#123;logoutHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/AuthContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext()"></a>useContext()</h2><p>React 提供了另一個 hook 來取代 Context Consumer，使的寫法更加簡潔，只需要呼叫 useContext() 並帶入 Context object，其所原傳的值就是上述 Context 中的共用變數了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> AuthContext <span class="keyword">from</span> <span class="string">&quot;../../store/auth-context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Navigation = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = useContext(AuthContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;nav className=&#123;classes.nav&#125;&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;ctx.isLoggedIn &amp;&amp; (</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;a href=<span class="string">&quot;/&quot;</span>&gt;Users&lt;/a&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Making-Context-Dynamic"><a href="#Making-Context-Dynamic" class="headerlink" title="Making Context Dynamic"></a>Making Context Dynamic</h2><p>在 Context 的使用上，當然不限於純值或物件資料，還可以共用 function 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        isLoggedIn,</span><br><span class="line">        onLogout: logoutHandler,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &#123;!isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Login</span> <span class="attr">onLogin</span>=<span class="string">&#123;loginHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Home</span> <span class="attr">onLogout</span>=<span class="string">&#123;logoutHandler&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/AuthContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Navigation.js</span></span><br><span class="line">  <span class="keyword">const</span> Navigation = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = useContext(AuthContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;nav className=&#123;classes.nav&#125;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;ctx.isLoggedIn &amp;&amp; (</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;a href=<span class="string">&quot;/&quot;</span>&gt;Users&lt;/a&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">          &#123;ctx.isLoggedIn &amp;&amp; (</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;button onClick=&#123;ctx.onLogout&#125;&gt;Logout&lt;/button&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/nav&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這裡就會有點納悶的是，既然預設值可以直接設定在 Provider value 上，那 Context 檔案內的設定必要性在哪 ? 是否可以維持空物件就好了 ?</p><p>其實維持空物件或預設值給定不同型別也不會出錯，但為了讓 IDE 可以較輕易辨別，建議還是給予初始設定，如果是 function 給定 anonymous function 即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auth-context.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AuthContext = React.createContext(&#123;</span><br><span class="line">  isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">  onLogout: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AuthContext;</span><br></pre></td></tr></table></figure><h2 id="When-to-use-Props-amp-Context"><a href="#When-to-use-Props-amp-Context" class="headerlink" title="When to use Props &amp; Context ?"></a>When to use Props &amp; Context ?</h2><p>Context 可以突破 component 之間的關係直接傳遞資料，但大部分的情況還是會直接透過 Props 直接傳遞父子元件之間的資料，雖然沒有明確規範，但如果只有單層，盡量還是保持透過 Props 傳遞，這麼一來透過查看傳遞方式就可以比較直接的知道資料傳遞的出處與目標。</p><h2 id="Building-amp-Using-a-Custom-Context-Provider-Component"><a href="#Building-amp-Using-a-Custom-Context-Provider-Component" class="headerlink" title="Building &amp; Using a Custom Context Provider Component"></a>Building &amp; Using a Custom Context Provider Component</h2><p>到目前為止，已經達成目的透過 Context 將特定 property &amp; method 傳遞到指定元件，但目前的寫法會發現，所有關於登入的邏輯都直接寫在 root component App.js，一旦隨著開發的內容越來越多，更好的方法是將特定的邏輯都抽離出去成為一個負責專一功能的 component，Context Provider 也不例外，甚至可以將包含邏輯和 JSX 全部抽離到 Context Component，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auth-context.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AuthContext = React.createContext(&#123;</span><br><span class="line">  isLoggedIn: <span class="literal">false</span>,</span><br><span class="line">  onLogout: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">  onLogin: <span class="function">(<span class="params">email, password</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AuthContextProvider = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoggedIn, setIsLoggedIn] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> storedUserLoggedInInformation = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;isLoggedIn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (storedUserLoggedInInformation === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">      setIsLoggedIn(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> loginHandler = <span class="function">(<span class="params">email, password</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// We should of course check emㄑail and password</span></span><br><span class="line">    <span class="comment">// But it&#x27;s just a dummy/ demo anyways</span></span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;isLoggedIn&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    setIsLoggedIn(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> logoutHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;isLoggedIn&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    setIsLoggedIn(<span class="literal">false</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;AuthContext.Provider</span><br><span class="line">      value=&#123;&#123;</span><br><span class="line">        isLoggedIn,</span><br><span class="line">        onLogout: logoutHandler,</span><br><span class="line">        onLogin: loginHandler,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/AuthContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AuthContext;</span><br></pre></td></tr></table></figure><p>並在注入點 index.js 導入 Context Provider component，將它直接包在 App..js 之外，這麼一來 root component App.js 內所有的 component 都可以直接取用 Context，邏輯也變得更加單純</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AuthContextProvider &#125; <span class="keyword">from</span> <span class="string">&quot;./store/auth-context&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.render(</span><br><span class="line">  &lt;AuthContextProvider&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/AuthContextProvider&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = useContext(AuthContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;MainHeader /&gt;</span><br><span class="line">      &lt;main&gt;</span><br><span class="line">        &#123;!ctx.isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Login</span> /&gt;</span></span>&#125;</span><br><span class="line">        &#123;ctx.isLoggedIn &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;/main&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>其他需要使用到 Context 資料的 component 便可自行透過 Context Consumer or useContext hook 取得</p><h2 id="React-Context-Limitations"><a href="#React-Context-Limitations" class="headerlink" title="React Context Limitations"></a>React Context Limitations</h2><p>即便 React Context 提供了非常方便的方法讓 component 突破關聯傳遞資料，但仍有幾個使用上的限制，如下:</p><ul><li><p>更動頻率過高<br>官方團隊也直接提到，如果是更動頻率過高的資料，就不適合透過 Context 來管理，在這之後仍有一種方法稱為 Redux 來接管這種情況</p></li><li><p>完全由 Context 管理 component 資料<br>Context 並非來取代所有 props 資料傳遞的，它只是提供了一個更方便的方式來處理跨 component 資料傳遞，但單純的富子元件還是建議直接使用 props 會有更好的效能表現</p></li></ul><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section9/commit/a9f6bf098dd89abdae690220b9292f154a5ef186">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useReducer &amp; Reducers</title>
      <link href="/react/20220625/40125/"/>
      <url>/react/20220625/40125/</url>
      
        <content type="html"><![CDATA[<p>隨著開發的功能和複雜度的逐漸提升，一個功能可能會由多組 State 來控制操作狀態，但因為 State 的更新機制，在某些情況下可能造成維護不易或預料之外的 Bug，所以 React 提供了另一個 Hook - <code>useReducer()</code> 來解決這種情況下的問題 </p><span id="more"></span><p>如果是一個簡單的表單驗證功能，透過 <code>useState()</code> 會需要個別有一組資料和驗證加以管理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredEmail, setEnteredEmail] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [emailsValid, setEmailsValid] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> emailChangeHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    setEnteredEmail(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validateEmailHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setEmailsValid(enteredEmail.includes(<span class="string">&quot;@&quot;</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;div</span><br><span class="line">        className=&#123;<span class="string">`<span class="subst">$&#123;classes.control&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">          emailIsValid === <span class="literal">false</span> ? classes.invalid : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>`</span>&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">&quot;email&quot;</span>&gt;E-Mail&lt;/label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&quot;email&quot;</span></span><br><span class="line">          id=<span class="string">&quot;email&quot;</span></span><br><span class="line">          value=&#123;enteredEmail&#125;</span><br><span class="line">          onChange=&#123;emailChangeHandler&#125;</span><br><span class="line">          onBlur=&#123;validateEmailHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer()"></a>useReducer()</h2><p>在上述的範例中，可以發現其實這兩個 State 可以看作為一組，因為驗證的 State 還是會透過資料的 State 來判斷以回應對應的值，這種情況就可以透過 <code>useReducer()</code> 將之改寫為一組 State</p><p>首先，介紹一下其結構，在前方回傳的變數其實和 <code>useState()</code> 相同，分別為 State 和修改 State 的 <code>dispatchFn</code>，比較特別的呼叫 <code>useReducer()</code> 所帶入的三個參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);</span><br></pre></td></tr></table></figure><ul><li>reducerFn(prevState, action):<br>因為其中的值並不會和 component function 內的其他值有交互作用，所以甚至可以把這個 function 寫在 component function 之外<ul><li>prevState: 顧名思義就是”前一個”最新的 State snapshot</li><li>action: 藉由 <code>dispatchFn</code> 取得最新的 State snapshot</li></ul></li><li>initialState: State 初始值</li><li>initFn: 將 State 設為初始值</li></ul><p>透過 <code>useReducer()</code>，我們可以讓 State 為一個 object，並有兩個 key 分別表示值和驗證狀態，呼叫 <code>dispatchFn()</code> 時，可以單純帶入值和行為類別，將邏輯由 <code>reducerFn</code> 來處理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emailReducer = <span class="function">(<span class="params">prevState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">&quot;USER_INPUT&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: action.val, <span class="attr">isValid</span>: action.val.includes(<span class="string">&quot;@&quot;</span>) &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.type === <span class="string">&quot;INPUT_BLUR&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: prevState.value, <span class="attr">isValid</span>: prevState.value.includes(<span class="string">&quot;@&quot;</span>) &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&quot;&quot;</span>, <span class="attr">isValid</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [emailState, dispatchEmail] = useReducer(emailReducer, &#123;</span><br><span class="line">    value: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    isValid: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> emailChangeHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    dispatchEmail(&#123;</span><br><span class="line">      type: <span class="string">&#x27;USER_INPUT&#x27;</span>,</span><br><span class="line">      val: event.target.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> validateEmailHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    dispatchEmail(&#123;</span><br><span class="line">      type: <span class="string">&#x27;INPUT_BLUR&#x27;</span>,</span><br><span class="line">      val: emailState.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;div</span><br><span class="line">        className=&#123;<span class="string">`<span class="subst">$&#123;classes.control&#125;</span> <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">          emailState.isValid === <span class="literal">false</span> ? classes.invalid : <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>`</span>&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">&quot;email&quot;</span>&gt;E-Mail&lt;/label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=<span class="string">&quot;email&quot;</span></span><br><span class="line">          id=<span class="string">&quot;email&quot;</span></span><br><span class="line">          value=&#123;emailState.value&#125;</span><br><span class="line">          onChange=&#123;emailChangeHandler&#125;</span><br><span class="line">          onBlur=&#123;validateEmailHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這裡要注意的是，因為 <code>isValid</code> 初始值就是 <code>false</code>，所以一開始在 UI 上就會顯示驗證未通過的樣式，為了區分初始狀態，可已透過其他 falsy 值如 null, undefined 來代替</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [emailState, dispatchEmail] = useReducer(emailReducer, &#123;</span><br><span class="line">    value: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    isValid: <span class="literal">null</span> or <span class="literal">undefined</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="With-useEffect"><a href="#With-useEffect" class="headerlink" title="With useEffect()"></a>With useEffect()</h2><p>有了個別欄位的驗證變數後，仍然會需要一組總表單的驗證變數來判斷每個欄位是否都驗證通過，這時候就可以透過先前的 <code>useEffect()</code> 來監聽所有欄位的變化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> identifier = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setFormIsValid(</span><br><span class="line">      emailState.isValid &amp;&amp; passwordState.isValid</span><br><span class="line">    );</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(identifier);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [emailState, passwordState]);</span><br></pre></td></tr></table></figure><p>寫到這裡其實已經達到驗證功能的目的了，但還可以進一步優化的地方是，這樣的寫法在驗證上”過於頻繁”了，只要欄位的值一改動，就會進行監聽，其實需要判斷的時機只有在個別欄位的驗證結果發生改變時，才會需要更新總表單的驗證結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> identifier = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setFormIsValid(</span><br><span class="line">      emailState.isValid &amp;&amp; passwordState.isValid</span><br><span class="line">    );</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(identifier);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [emailState.isValid, passwordState.isValid]);</span><br></pre></td></tr></table></figure><p>或是可以透過 ES6 object de-structuring 來個別取的 <code>isValid</code> 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">isValid</span>: emailValid &#125; = emailState;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">isValid</span>: passwordValid &#125; = passwordState;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> identifier = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setFormIsValid(</span><br><span class="line">      emailValid &amp;&amp; passwordValid</span><br><span class="line">    );</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(identifier);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [emailValid, passwordValid]);</span><br></pre></td></tr></table></figure><h2 id="useState-vs-useReducer"><a href="#useState-vs-useReducer" class="headerlink" title="useState() vs useReducer()"></a>useState() vs useReducer()</h2><p>在 React 中，其實並沒有明確規定什麼時候該用哪一種 hook，兩者可以辦到的事相同，只是在什麼時機更適合，基本上可以為兩者的使用時機做出一些區別</p><ul><li><p>useState()</p><ul><li>一個主要由 State 來管理的工具</li><li>每個 State 獨立運作，較沒有相互作用的情況</li><li>State 的更新較為單純，改別的值也比限制在固定的範圍內</li></ul></li><li><p>useReducer()</p><ul><li>更複雜的資料結構，如 object</li><li>資料彼此之間的關聯性高，更新時環環相扣</li><li>處理更複雜的邏輯</li></ul></li></ul><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section9/commit/62833e04b790178ecee12e6130f1d5aa2bcf7664">useReducer()</a><br><a href="https://github.com/Jerry-Yeh/React-The-Complete-Guide-Section9/commit/8d16b47603cf77097c9a90a8d409184bbeca57f7">with useEffect()</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What are Side Effect &amp; Introducing useEffect</title>
      <link href="/react/20220619/1954/"/>
      <url>/react/20220619/1954/</url>
      
        <content type="html"><![CDATA[<p>在 React component 中，如果有 State 被更新，component function 會再次被呼叫，並交叉比對原 DOM 物件與新的 DOM 物件之間的差異進行重新渲染，以回應使用者的操作行為，但在某些情況如 HTTP Request，React 其實並不在意這些非同步行為，因此可能為導致資料更新上的 Bug 或 Infinite loop 的情況發生，接下來將介紹一些 React 中的 hooks 來解決這些問題。</p><span id="more"></span><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p><code>useEffect</code> hook 中存在兩個參數，分別為以下兩者:</p><ul><li>Callback function: 放入 side effect 程式，在 dependencies 改變時會被呼叫</li><li>Dependencies array: 將所有 dependency 放入 array，其中的更動會觸發前面的 callback function</li></ul><p>那麼到底什麼時候需要使用到這組 hook 呢? 一組簡易的登入範例如下:</p><p>登入成功後，將成功的變數紀錄在 localStorage，這麼一來在下次造訪時，就可以透過這個變數判斷是否登入，進而跳過再次登入的環節</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoggedIn, setIsLoggedIn] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> storedUserLoggedInInformation = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;isLoggedIn&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (storedUserLoggedInInformation === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">    setIsLoggedIn(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> loginHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;isLoggedIn&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    setIsLoggedIn(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前為止看似一切正常，但在執行後就會發現，出現了以下 error log</p><p>原因是在上述的範例中，出現了 Infinite loop，因為在判斷 localStorage 中變數狀態正確後，便去更改 State 的值，在更改的 State 的值就會觸發 component function re-render，進而導致因再次判斷正確後又更改 State 的 Infinite loop ; 所以在這裡就會需要使用 <code>useEffect</code> 將這段程式碼放到 callback function 之中，如果第二個變數中的 Dependencies Array 沒有加入執行時機，那麼就只會在第一次 render 時執行，這麼一來就可以避免 Infinite loop 的出現了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLoggedIn, setIsLoggedIn] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> storedUserLoggedInInformation = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;isLoggedIn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (storedUserLoggedInInformation === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">      setIsLoggedIn(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> loginHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;isLoggedIn&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    setIsLoggedIn(<span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><p>在前面的範例中，將判斷 localStorage 的程式碼放到 useEffect 之中，避免因 component function 觸發導致的 Infinite loop 情況發生，但第二個參數 Dependencies Array 為空，表示只有在 component function 執行時會觸發其中的程式碼。</p><p>但在很多情況如非同步 HTTP Request 或使用者行為等，會需要被動的監聽某些值的話來執行對應的程式碼，這時候就會需要把要監聽的值作為 Dependency 放入第二個參數 Array 之中，以達到被動觸發的目的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredEmail, setEnteredEmail] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [enteredPassword, setEnteredPassword] = useState(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setFormIsValid(</span><br><span class="line">      enteredEmail.includes(<span class="string">&#x27;@&#x27;</span>) &amp;&amp; enteredPassword.trim().length &gt; <span class="number">6</span></span><br><span class="line">    );</span><br><span class="line">  &#125;, [enteredEmail, enteredPassword]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Cleanup-function"><a href="#Cleanup-function" class="headerlink" title="Cleanup function"></a>Cleanup function</h2><p>延續上方的範例，透過 <code>useEffect</code> 監聽每次欄位變動時，都會即時做出對應的驗證，但這麼做其實會造成瀏覽器很大的負擔，更何況如果這個驗證行為是一個 Http Request，那就可想而知對效能來說是個很不好的消息。</p><p>為了解決這個問題，React 在 <code>useEffect</code> 提供了一組 return cleanup function，他只會在 first side-effct 後執行 (Component 第一次生成時不執行);透過這個方式，我們可以將上述的驗證行為包裝到一個非同步 <code>setTimeout</code> 之中，並給定一段延遲時間 (500ms，可自行定義)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Checking from validity!&quot;</span>);</span><br><span class="line">    setFormIsValid(</span><br><span class="line">      enteredEmail.includes(<span class="string">&quot;@&quot;</span>) &amp;&amp; enteredPassword.trim().length &gt; <span class="number">6</span></span><br><span class="line">    );</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;CLEANUP&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [enteredEmail, enteredPassword]);</span><br></pre></td></tr></table></figure><p><img src="first-side-effect.png"></p><p>但到目前為止，我們只是延遲了欄位更改後的對應驗證，並沒有真的移除這些非必要的即時驗證，這時候就可以透過原生的方式，將 <code>setTimeout</code> 賦予一個變數，並在 cleanup function 中透過 <code>clearTimeout</code> 移除在限定時間內(這裡是先前設定的 500ms)的非必要即時驗證，這麼一來就會發現，只有在超過時間的行為，會真的執行 <code>useEffect</code> 中的程式碼了，因為在這時間內的行為都會在 cleanup function 中被移除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> identifier = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Checking from validity!&quot;</span>);</span><br><span class="line">    setFormIsValid(</span><br><span class="line">      enteredEmail.includes(<span class="string">&quot;@&quot;</span>) &amp;&amp; enteredPassword.trim().length &gt; <span class="number">6</span></span><br><span class="line">    );</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;CLEANUP&#x27;</span>);</span><br><span class="line">    <span class="built_in">clearTimeout</span>(identifier);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [enteredEmail, enteredPassword]);</span><br></pre></td></tr></table></figure><p><img src="fast-keystroke.png"></p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><h3 id="只有第一組-callback-function"><a href="#只有第一組-callback-function" class="headerlink" title="只有第一組 callback function"></a>只有第一組 callback function</h3><p>如果在使用 <code>useEffect</code> 時，只有帶入第一個參數 callback funciton，第二個參數 dependencies array 甚至連 empty array 都沒有帶入的話，其中的程式碼就會在每次 component function 執行時跟著執行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;EFFECT RUNNING&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> identifier = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Checking from validity!&quot;</span>);</span><br><span class="line">    setFormIsValid(</span><br><span class="line">      enteredEmail.includes(<span class="string">&quot;@&quot;</span>) &amp;&amp; enteredPassword.trim().length &gt; <span class="number">6</span></span><br><span class="line">    );</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;CLEANUP&#x27;</span>);</span><br><span class="line">    <span class="built_in">clearTimeout</span>(identifier);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [enteredEmail, enteredPassword]);</span><br></pre></td></tr></table></figure><p><img src="without-dependenies.png"></p><h3 id="Empty-Dependencies-Array"><a href="#Empty-Dependencies-Array" class="headerlink" title="Empty Dependencies Array"></a>Empty Dependencies Array</h3><p>要避免這個情況就是至少應該給予 dependencies array 一個 empty array</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;EFFECT RUNNING&#x27;</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>如果是一個 empty dependencies array 條件下的 cleanup function，在 component function 重新執行時不會觸發，但在該 comopnent 移除時 (頁面切換) 就會觸發</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;EFFECT RUNNING&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;EFFECT CLEANUP&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><img src="switch-page.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a> </p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Refs</title>
      <link href="/react/20220619/43584/"/>
      <url>/react/20220619/43584/</url>
      
        <content type="html"><![CDATA[<p>在 React 中，可以透過 useState 在 component 重新選染時保留資料，並透過 handler &amp; value 來為 JSX 與 JS 做到雙向綁定，但在某些情況下，會只有特定的時機會需要取得資料，並不需要隨時對資料進行監聽，因此 React 提供了一個更輕便的方式 - Refs 來達到這個目的</p><span id="more"></span><p>回到先前的範例，為了避免 component rendered 所造成的資料流失，我們會透過 state 來儲存在資料，並透過 handler 監聽資料的更動以即時更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NewUser = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [user, setUser] = useState(&#123;</span><br><span class="line">    username: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    age: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usernameChangeHandler = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ageChangeHandler = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;username&quot;</span>&gt;Username&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        id=<span class="string">&quot;username&quot;</span></span><br><span class="line">        type=<span class="string">&quot;text&quot;</span></span><br><span class="line">        value=&#123;user.username&#125;</span><br><span class="line">        onChange=&#123;usernameChangeHandler&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;age&quot;</span>&gt;Age(Years)&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        id=<span class="string">&quot;age&quot;</span></span><br><span class="line">        type=<span class="string">&quot;number&quot;</span></span><br><span class="line">        value=&#123;user.age&#125;</span><br><span class="line">        onChange=&#123;ageChangeHandler&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add User&lt;/Button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React-Refs"><a href="#React-Refs" class="headerlink" title="React Refs"></a>React Refs</h2><p>但其實我們不需要隨時監聽資料的更動，只需要在送出表單時，取得當前資料即可，因此 React 便提供了另一個 hooks - Refs ; 如同其他的 React hooks，Refs 也只能應用於 component function 之中，透過查看 useRefs 所傳的值，它總是會包含一個屬性 - current，這個屬性即是我們綁定的 DOM，其中的 value 即是 DOM value。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRef&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NewUser = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> nameInputRef = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nameInputRef);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usernameChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;label htmlFor=<span class="string">&quot;username&quot;</span>&gt;Username&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        id=<span class="string">&quot;username&quot;</span></span><br><span class="line">        type=<span class="string">&quot;text&quot;</span></span><br><span class="line">        value=&#123;user.username&#125;</span><br><span class="line">        onChange=&#123;usernameChangeHandler&#125;</span><br><span class="line">        ref=&#123;nameInputRef&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="refs-value.png"></p><p>透過 Refs，便可在送出表單時取得即時資料，因此先前綁定 State 所使用的監聽方式也不在必要，單純透過綁定 Refs 也可以直接更改 <code>current.value</code> 的值，如送出表單後清空欄位的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  nameInputRef.current.value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  ageInputRef.current.value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">    &lt;label htmlFor=<span class="string">&quot;username&quot;</span>&gt;Username&lt;/label&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      id=<span class="string">&quot;username&quot;</span></span><br><span class="line">      type=<span class="string">&quot;text&quot;</span></span><br><span class="line">      ref=&#123;nameInputRef&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Controlled-vs-Uncontrolled-Components"><a href="#Controlled-vs-Uncontrolled-Components" class="headerlink" title="Controlled vs Uncontrolled Components"></a>Controlled vs Uncontrolled Components</h2><p>在 React 中，透過 State 綁定資料與 JSX，及時監聽 JSX 變化，並透過 React 回填最新的資料，這種完全由 React 所主導的元件稱之為 - Controlled Component。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [username, setUsername] = useState();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    setUsername(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> usernameHandler = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    setUsername(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;input value=&#123;username&#125; onChnage=&#123;usernameHandler&#125;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反之，透過 Refs 綁定 JSX 後，只在需要時即時查看最新資料，這種非完全透過 React 完全掌握資料變動的方式就稱為 - Uncontrolled component ; 但這裡也許會有些疑問是，在送出表單後，不也是透過更動 <code>useRef</code> 所回傳的 <code>object.current.value</code> 來達到主動更新資料嗎 ?</p><p>這裡的差異是，Ref 更新資料只是透過 DOM API 來更新 value，來不是完全由 React 提供的方式來辦到 ; 也許到目前為止還無法感受這麼區分的目的，但這在 React 的開發中是非常典型用來區分 component 開發模式的方式，在更進階的開發中會進一步探討它們的差異。</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Portals</title>
      <link href="/react/20220618/21072/"/>
      <url>/react/20220618/21072/</url>
      
        <content type="html"><![CDATA[<p>這章節將介紹另一個 React 的功能 - Portals，他可以使我們的程式碼更符合操作邏輯和語意，不只是技術上可行而已 </p><span id="more"></span><p>一個具有 modal 的範例如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line">    &lt;MyModal /&gt;</span><br><span class="line">    &lt;MyInputForm /&gt;</span><br><span class="line">  &lt;/React.Fragment&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>透過這樣的寫法，在渲染為實際的 DOM 後，結構上會像是以下這樣的結構:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h2&gt;Some other content...&lt;/h2&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;my-modal&quot;</span>&gt;</span><br><span class="line">      &lt;h2&gt;A Modal Title!&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;test&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>這樣的結構在技術上完全可行，但就頁面顯示來說，modal 應該是一個滿版覆蓋 (overlay) 的 component，而不是放置於 component 內，所以合理的結構應該如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;my-modal&quot;</span>&gt;</span><br><span class="line">    &lt;h2&gt;A Modal Title!&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h2&gt;Some other content...&lt;/h2&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &lt;label&gt;Username&lt;/label&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;test&quot;</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Working-with-Portals"><a href="#Working-with-Portals" class="headerlink" title="Working with Portals"></a>Working with Portals</h2><p>為了解決讓 DOM 渲染在正確位置的問題，react-dom 提供了一個方法來達到這個目的，注意這裡說的是 react-dom 而不是 react 核心，react-dom 是被額外延伸出來負責處理 DOM 的 plugin，還有許多 plugin 如 react-native 則專門處理打包成桌面應用程式。</p><p>首先，我們在 index.html 中新增兩個 element 分別用來放置 backdrop &amp; overlay</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;backdrop-root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;overlay-root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ReactDOM-createPortal"><a href="#ReactDOM-createPortal" class="headerlink" title="ReactDOM.createPortal()"></a>ReactDOM.createPortal()</h3><p>接著便可在原先的 ErrorModal 中導入 <code>ReactDOM.createPortal()</code> 方法，藉由這個方法便可以將 JSX 指定渲染到上述於 index.html 中所新增的位置，而為了個別指定 backdrop &amp; overlay，可以將這兩組 JSX 分別區分為兩個 Component</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BackDrop = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classes.backdrop&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onConfirm&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ModalOverlay = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=&#123;classes.modal&#125;&gt;</span><br><span class="line">      &lt;header className=&#123;classes.header&#125;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;/header&gt;</span><br><span class="line">      &lt;div className=&#123;classes.content&#125;&gt;&#123;props.message&#125;&lt;/div&gt;</span><br><span class="line">      &lt;footer className=&#123;classes.actions&#125;&gt;</span><br><span class="line">        &lt;Button onClick=&#123;props.onConfirm&#125;&gt;Okay&lt;/Button&gt;</span><br><span class="line">      &lt;/footer&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>ReactDOM.createPortal()</code> 這個方法需調入兩個參數，方別為:</p><ul><li>Component: 欲渲染的 component</li><li>Pointer: 指定渲染的位置，可以使用原生方法 <code>ducment.getElementById()</code> 來指定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ErrorModal = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &#123;ReactDOM.createPortal(</span><br><span class="line">        &lt;BackDrop onConfirm=&#123;props.onConfirm&#125; /&gt;,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;backdrop-root&quot;</span>)</span><br><span class="line">      )&#125;</span><br><span class="line">      &#123;ReactDOM.createPortal(</span><br><span class="line">        &lt;ModalOverlay</span><br><span class="line">          title=&#123;props.title&#125;</span><br><span class="line">          message=&#123;props.message&#125;</span><br><span class="line">          onConfirm=&#123;props.onConfirm&#125;</span><br><span class="line">        /&gt;,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;overlay-root&quot;</span>)</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這麼一來在觸發 modal 啟動時，就會發現以上 component 被渲染到指定位置了</p><p><img src="rendered.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSX Limitations &amp; Workrounds</title>
      <link href="/react/20220615/47101/"/>
      <url>/react/20220615/47101/</url>
      
        <content type="html"><![CDATA[<p>這章節將來討論 JSX 的限制與解決方法</p><span id="more"></span><p>在過往的章節中，反覆提到的一個概念就是 component function 所 return 的 JSX 只有有一個 element，原因是在前面也有提到過，當我們 return 一組 element 時，React 就會執行 <code>React.createElement()</code> 來生成實際的 DOM element，而在 JavaScript 中，function return 本來就只能回傳一個值，無論是基本型別或物件也好，都只能是一個，所以在 component 內有多個 element 時，解決方法如下:</p><h2 id="方法一-Parent-Element"><a href="#方法一-Parent-Element" class="headerlink" title="方法一: Parent Element"></a>方法一: Parent Element</h2><p>最直接的方法就是透過一個 parent element 包住所有 element， 常見的做法就是直接使用一組 <code>div</code>，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&lt;/div&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法二-Array"><a href="#方法二-Array" class="headerlink" title="方法二: Array"></a>方法二: Array</h2><p>前面的章節其實也提供了另一種方式，那就是 return array，在 JSX 中，element list 是可以直接被解析的，如同先前的範例透過 <code>Array.map()</code> 渲染出 data list item</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.listData.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;li&gt;...&lt;/li&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>透過這種方式也可以直接使用 array [] 取代 parent element，並透過逗號 , 隔開所有 element</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    [</span><br><span class="line">      &lt;div&gt;&lt;/div&gt;,</span><br><span class="line">      ...</span><br><span class="line">      &lt;div&gt;&lt;/div&gt;,</span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但按照先前的經驗，在 React 中，透過 array 產生 element 就需要賦予每個 item 一組 unique id，這裡當然也不例外</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    [</span><br><span class="line">      &lt;div key=<span class="string">&quot;e1&quot;</span>&gt;&lt;/div&gt;,</span><br><span class="line">      ...</span><br><span class="line">      &lt;div key=<span class="string">&quot;en&quot;</span>&gt;&lt;/div&gt;,</span><br><span class="line">    ]</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但很顯然的，既然還要主動賦予一組 unique key，那還不然乾脆就加上 parent element 就解決了，雖然這麼做完全可行，但也間接產生了其他問題是，有些 CSS style 是直接指定 child element，多餘的多層非必要 parent element 可能會導致無法指向預期的目標，再加上這些非必要的 parent element 也會增加瀏覽器和 React 在處理上的負擔，進而影響網頁效能。</p><h2 id="方法三-Wrapper-Component"><a href="#方法三-Wrapper-Component" class="headerlink" title="方法三: Wrapper Component"></a>方法三: Wrapper Component</h2><p>縱關上述的兩個方式，似乎都還不是很理想，因此 React 提供了另一個方式 - Wrapper Component，顧名思義就是建立一個名為 Wrrapper 的 Component，並在 Component 中直接回傳 <code>props.chilren</code>，再使用這個 Component 取代原先的 parent element (div)，這麼一來就可以在符合 return 一個 element 的原則下不應加額外 element 的目的了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrapper.js</span></span><br><span class="line"><span class="keyword">const</span> Wrapper = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    props.children</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Else Component</span></span><br><span class="line"><span class="keyword">import</span> Wrapper <span class="keyword">from</span> <span class="string">&#x27;@/components/Helpers/Wrapper&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Wrapper&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/Wrapper&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="React-Fragments"><a href="#React-Fragments" class="headerlink" title="React Fragments"></a>React Fragments</h2><p>因為這個方式完整的解決了這個問題，所以 React 甚至幫我們寫好了，透過以下 3 種方式就可以達到相同的目的</p><ul><li>React.Fragment: 直接取代自製 Wrapper 即可，這個方式適用於所有 React 專案環境</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>Fragment: 這個方法使用方式相同，使用上也更為簡潔，但並非支援於所有 React 專案，需視專案建立環境而訂</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>empty: 最後也是最簡潔的方式是，完全可以直接省略 element 中的文字，這種方式並非原生 HTML tag，而是 JSX 獨有的語法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prop className</title>
      <link href="/react/20220614/12696/"/>
      <url>/react/20220614/12696/</url>
      
        <content type="html"><![CDATA[<p>這章節將透過傳遞 class 達到擴充 Component class style 的目的</p><span id="more"></span><h2 id="props-className"><a href="#props-className" class="headerlink" title="props.className"></a>props.className</h2><p>在許多開發情境中，時常會將重複的樣式單獨拉出去為一個 Component 以供複用，一個外層 Component 的應用如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Card.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./Card.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Card = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">`<span class="subst">$&#123;classes.card&#125;</span>`</span>&#125;&gt;&#123;props.children&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddUser.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./AddUser.module.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&#x27;../UI/Card&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AddUser = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=&#123;classes.input&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但如果只透過上方的寫法各自導入 CSS 會發現，AddUser 中的 element 並沒有實際取得 AddUser.module.css 中的 CSS Style，原因是 Card 並不是內建的 HTML element，而是我們自製的 component，AddUser 中的 element 會透過 <code>props.children</code> 傳進 Card 對應位置，所以 CSS Style (classes)也需要被傳入，而 classes 是一個 object，所以 prop name 並非一定得是 <code>className</code>，只是為了開發上統一，一般還是會沿用 <code>className</code> 作為 CSS Style</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Card.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./Card.module.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Card = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;<span class="string">`<span class="subst">$&#123;classes.card&#125;</span> <span class="subst">$&#123;props.className&#125;</span>`</span>&#125;&gt;&#123;props.children&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using the React Devtools</title>
      <link href="/react/20220613/64148/"/>
      <url>/react/20220613/64148/</url>
      
        <content type="html"><![CDATA[<p>在前一章節中，我們介紹了如透過 Chrome devtools 來 Debug React 專案但其實那個方式並非僅限於 React，而是任何 Web 開發都適用，接下來將介紹一個完全為了 React 量身打造的 Chrome Plugin Debugger Tool - <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools</a></p><span id="more"></span><p>就如同其他 Chrome Plugin 一樣，在 Chrome 擴充功能中搜尋即可快速安裝，安裝並啟動後，在打開 Chrome devtools 會發現多了兩個 tab Components &amp; Profiler</p><p><img src="chrome-plugin.png"></p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>首先，切換到 Components 會發現當下頁面所有 Component 會依序從 Root Component 到 Child Componet 完整列出，且點選 Component 時還會在頁面上 highlight 對應的 comoponent，更包含詳細資訊如下:</p><ul><li>props: 傳入 component 的資料</li><li>rendered by: parent component 路徑</li><li>souce: 程式碼位置</li></ul><p><img src="components.png"></p><p>甚至可以在 devtools 中直接修改，畫面也會動態的隨之調整</p><p><img src="updated.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debugging React Apps</title>
      <link href="/react/20220613/54546/"/>
      <url>/react/20220613/54546/</url>
      
        <content type="html"><![CDATA[<p>這章節將介紹透過 Chrome Debug 的方式</p><span id="more"></span><p>首先，我們先讓程式碼故意出錯，在新增於 list 的 item ID 上，使其固定，重複的 ID 便會使 React 出錯，這時候可以打開 Chrome / devtools / Sources，並找出該操作行為所指向的那行程式碼，點擊最前方的行數便會發現剛行被選取了</p><p><img src="breakpoint.png"></p><p>接著在畫面上執行我們預期會發生的錯誤操作，便會發現在畫面上方出現 <code>Paused in debugger</code>，且畫面操被暫停於操作前，代表程式碼並沒有依序執行下去，接下來我們將透過點選 <code>Step into next function call</code> 按鈕，程式碼就會按照步驟一步一步跳轉</p><p><img src="step-into-function-call.png"></p><p>透過這個方式，我們就可能間接或直接的找到程式碼中錯誤的位置，進而加以修正</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Using CSS Modules</title>
      <link href="/react/20220612/39569/"/>
      <url>/react/20220612/39569/</url>
      
        <content type="html"><![CDATA[<p>在前一章節，我們介紹了透過 styled-components 將 CSS 限制在 Component 內的方式，無論你喜不喜歡這個方式，它成功解決了 global style 的問題，並擁有許多擁護者，但好消息是，如果你不喜歡這個方式，React 提供了另一個稱為 <a href="https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/">CSS Module</a> 的方式來解決這個問題，如果是透過 create-react-app 建立專案，這個方式甚至已經內建在專案內了，接下來讓我們透過 CSS Module 來改寫相同的範例。 </p><span id="more"></span><p>在實作上，這兩個方式有一個很大的差異是，CSS Module 並不會像 styled-components 將所有 CSS 寫到 JS 內，而是照舊將 CSS 和 JS 區分為兩個檔案，只是在檔名和導入方式上有所差異</p><h2 id="檔名"><a href="#檔名" class="headerlink" title="檔名"></a>檔名</h2><p>如果是透過 CSS Module 的方式建立 Scoped CSS，在檔名上就要在中間加上 <code>module</code>，並以 <code>.</code> 隔開</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button.css -&gt; Button.module.css </span><br></pre></td></tr></table></figure><h2 id="導入方式"><a href="#導入方式" class="headerlink" title="導入方式"></a>導入方式</h2><p>在導入方式上，原先只是單純 <code>import</code> CSS 檔案，但這個方式需要將 CSS 檔案作為一個 object 導入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./Button.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> classes <span class="keyword">from</span> <span class="string">&#x27;./Button.module.css&#x27;</span>;</span><br></pre></td></tr></table></figure><p>導入後，所有 class name 將透過這個 object 取得</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button type=&#123;props.type&#125; className=&#123;classes.button&#125; onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Class-Name"><a href="#Class-Name" class="headerlink" title="Class Name"></a>Class Name</h2><p>透過以上這些步驟，就已經達到我們的目的了，進一步打開 devtools Element 會看到，class name 的命名方式和 styled-components 不太一樣，並非單純產生 unique ID，而是透過以下命名方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;Component Name&#125;_$&#123;Class Name&#125;__$&#123;unique ID&#125;</span><br></pre></td></tr></table></figure><p><img src="unique-class-name.png"></p><h2 id="Dynamic-Styles"><a href="#Dynamic-Styles" class="headerlink" title="Dynamic Styles"></a>Dynamic Styles</h2><p>同樣的，我們繼續透過 CSS Module 來改寫另一個動態改變 style 的 Component ; 在改變 CSS 檔名和導入方式後，一樣可以透過 CSS object 取得 class name，就如同原生 JS 一樣，如果是一個包含 <code>-</code> 的 key，會改以 [] 取得屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">    &lt;div className=&#123;classes[<span class="string">&#x27;form-control&#x27;</span>]&#125;&gt;</span><br><span class="line">      &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在寫法上其實和使用 CSS Module 前大同小異，同理，也可以透過相同的方式加上判斷</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">    &lt;div className=&#123;<span class="string">`<span class="subst">$&#123;classes[<span class="string">&#x27;form-control&#x27;</span>]&#125;</span> <span class="subst">$&#123;!isValid &amp;&amp; classes.invalid&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Media-Queries"><a href="#Media-Queries" class="headerlink" title="Media Queries"></a>Media Queries</h2><p>因為 CSS Module 並沒有去改動 css 檔案內容，所以在使用 Media Queries 來區分各種裝置解析度時，寫法上就照舊採用原生 CSS 的方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Button.module.css */</span></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>介紹了 styled-components 和 CSS Module 這兩種方式都可以得到 CSS Scpoed 的目的，在使用上完全是依照個人和團隊喜好來決定，喜歡透過 JS 一路寫到底的則可以選擇 styled-components，如果還是習慣將 CSS &amp; JS 做區分的則可以選擇 CSS Module。</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/">CSS Module</a></p><!-- [Github](https://github.com/Jerry-Yeh/react-complete-guide/commit/08898606159d04d4eedc5b8c808679a73cf9e4b0) -->]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introducing Styled Components</title>
      <link href="/react/20220612/60289/"/>
      <url>/react/20220612/60289/</url>
      
        <content type="html"><![CDATA[<p>到目前為止，在我們建立 Component 時，都會再額外建立一個同名的 css 檔案作為 Comoponent Style，但在 React 中，.css 一旦被任意 Component 導入，它就會成為 global style，而非只有導入的 Component 可以使用 (Scoped)，這在小專案也許不會是什麼問題，但當專案逐漸擴大、參與協作的人逐漸增加，就難免會發生 class 命名上重複的問題，進一步導致彼此的 CSS 互相覆蓋，這章節將介紹一個 React Plugin - <a href="https://styled-components.com/">styled-components</a> 來解決這個問題</p><span id="more"></span><p>首先，不免俗的當然是先透過 npm 來安裝這個 plugin</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save styled-components</span><br></pre></td></tr></table></figure><p>安裝完成後，在目標 Component 導入這個套件，這個 <code>styled</code> object 可以直接取代原先的 Component Function，而且這個 <code>styled</code> object 包含所有 HTML tag，每個 HTML tag 都是 function，接著在後方透過 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">ES6 Template literals</a> 放入所有原先寫在 .css 裡面的 class style，但這裡需要稍微修改的是，可以不必加上 class name，只需要寫入 css attribute 即可，而如果是 Element state，則改成 <code>&amp;</code> 來取代 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  font: inherit;</span></span><br><span class="line"><span class="string">  padding: 0.5rem 1.5rem;</span></span><br><span class="line"><span class="string">  border: 1px solid #8b005d;</span></span><br><span class="line"><span class="string">  color: white;</span></span><br><span class="line"><span class="string">  background: #8b005d;</span></span><br><span class="line"><span class="string">  box-shadow: 0 0 4px rgba(0, 0, 0, 0.26);</span></span><br><span class="line"><span class="string">  cursor: pointer;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;:focus &#123;</span></span><br><span class="line"><span class="string">    outline: none;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;:hover,</span></span><br><span class="line"><span class="string">  &amp;:active &#123;</span></span><br><span class="line"><span class="string">    background: #ac0e77;</span></span><br><span class="line"><span class="string">    border-color: #ac0e77;</span></span><br><span class="line"><span class="string">    box-shadow: 0 0 8px rgba(0, 0, 0, 0.26);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>完成後會發現頁面和原先呈現相同的效果，打開 devtools Element 指向這個 HTML tag，styled-components 會幫我們產生 unique class name，如此一來，就不會有 global style 的問題了</p><p><img src="unique-class-name.png"></p><h2 id="Dynamic-Props"><a href="#Dynamic-Props" class="headerlink" title="Dynamic Props"></a>Dynamic Props</h2><p>根據上方的範例，也許我們會有些疑問，因為這個範例太單純了，甚至不需要 <code>props</code> 其他條件來改變 <code>style</code>，那麼如果是更複雜的 Component 也能透過 styled-components 來改寫嗎 ? 答案是當然可以</p><p>以一個更複雜的 Component 為例，我們來改寫 <code>form</code> 內的 <code>div</code>，在改寫前其程式碼如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">const</span> CourseInput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredValue, setEnteredValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [isValid, setIsValid] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> goalInputChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.target.value.trim().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      setIsValid(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setEnteredValue(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formSubmitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">if</span> (enteredValue.trim().length === <span class="number">0</span>) &#123;</span><br><span class="line">      setIsValid(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    props.onAddGoal(enteredValue);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">      &lt;div className=&#123;<span class="string">`form-control <span class="subst">$&#123;!isValid ? <span class="string">&#x27;invalid&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>&#125;&gt;</span><br><span class="line">        &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line"><span class="selector-class">.form-control</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.5rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">font</span>: inherit;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0.25rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span> <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fad0ec</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#8b005d</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span><span class="selector-class">.invalid</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span><span class="selector-class">.invalid</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffd7d7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著透過 styled-component 我們可以將 CSS 導入，並產生 <code>div</code> Component，同樣的將 class name 刪除，僅留下 css attribute，如果有 nested class、HTML tag or element state，則同樣透過 <code>&amp;</code> 取代，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FormControl = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  margin: 0.5rem 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp; label &#123;</span></span><br><span class="line"><span class="string">    font-weight: bold;</span></span><br><span class="line"><span class="string">    display: block;</span></span><br><span class="line"><span class="string">    margin-bottom: 0.5rem;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp; input &#123;</span></span><br><span class="line"><span class="string">    display: block;</span></span><br><span class="line"><span class="string">    width: 100%;</span></span><br><span class="line"><span class="string">    border: 1px solid #ccc;</span></span><br><span class="line"><span class="string">    font: inherit;</span></span><br><span class="line"><span class="string">    line-height: 1.5rem;</span></span><br><span class="line"><span class="string">    padding: 0 0.25rem;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp; input:focus &#123;</span></span><br><span class="line"><span class="string">    outline: none;</span></span><br><span class="line"><span class="string">    background: #fad0ec;</span></span><br><span class="line"><span class="string">    border-color: #8b005d;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;.invalid label &#123;</span></span><br><span class="line"><span class="string">    color: red;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp;.invalid input &#123;</span></span><br><span class="line"><span class="string">    border-color: red;</span></span><br><span class="line"><span class="string">    background: #ffd7d7;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CourseInput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">      &lt;FormControl&gt;</span><br><span class="line">        &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;/FormControl&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到這裡會發現，點選欄位並沒有顯示對應的 style 效果，這是當然的，因為我們還沒有補上透過 <code>isValid</code> 加以判斷 ; 透過 styled-components 產生的 Component 同樣可以帶入其他 <code>className</code> 來達到判斷的目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CourseInput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">      &lt;FormControl className=&#123;!isValid &amp;&amp; <span class="string">&#x27;invalid&#x27;</span>&#125;&gt;</span><br><span class="line">        &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;/FormControl&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但這裡有一個更進階的用法是，<code>props</code> 甚至可以直接傳入透過 styled-components 產生的 Components 內，直接將判斷寫在 CSS attribute 內，同樣可以將 props name 寫在 JSX 上，並在 Template literals 內透過 <code>$&#123;&#125;</code> 寫入 callback function，其參數及是 <code>props</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FormControl = styled.div<span class="string">`</span></span><br><span class="line"><span class="string">  margin: 0.5rem 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp; label &#123;</span></span><br><span class="line"><span class="string">    font-weight: bold;</span></span><br><span class="line"><span class="string">    display: block;</span></span><br><span class="line"><span class="string">    margin-bottom: 0.5rem;</span></span><br><span class="line"><span class="string">    color: <span class="subst">$&#123;props =&gt; props.invalid ? <span class="string">&#x27;red&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp; input &#123;</span></span><br><span class="line"><span class="string">    display: block;</span></span><br><span class="line"><span class="string">    width: 100%;</span></span><br><span class="line"><span class="string">    border: 1px solid <span class="subst">$&#123;props =&gt; props.invalid ? <span class="string">&#x27;red&#x27;</span> : <span class="string">&#x27;#ccc&#x27;</span>&#125;</span>;</span></span><br><span class="line"><span class="string">    background: <span class="subst">$&#123;props =&gt; props.invalid ? <span class="string">&#x27;#ffd7d7&#x27;</span> : <span class="string">&#x27;transparent&#x27;</span>&#125;</span>;</span></span><br><span class="line"><span class="string">    font: inherit;</span></span><br><span class="line"><span class="string">    line-height: 1.5rem;</span></span><br><span class="line"><span class="string">    padding: 0 0.25rem;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &amp; input:focus &#123;</span></span><br><span class="line"><span class="string">    outline: none;</span></span><br><span class="line"><span class="string">    background: #fad0ec;</span></span><br><span class="line"><span class="string">    border-color: #8b005d;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CourseInput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">      &lt;FormControl invalid=&#123;!isValid&#125;&gt;</span><br><span class="line">        &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;/FormControl&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一次見到這種寫法真的會有點大開眼界，畢竟 HTML &amp; CSS 都可以直接寫在 JS 內，並且確實解決了 global style 的問題</p><h2 id="Media-Queries"><a href="#Media-Queries" class="headerlink" title="Media Queries"></a>Media Queries</h2><p>在開發 Web 專案時，時常會需要配合各種裝置解析度做出對應的樣式調整，在 CSS 中，我們可以透過 media queries <code>@media</code> 來建立各種解析度範圍，而在 styled-components 中，這個用法完全可以直接應用，不需要做其他多餘的改寫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  width: 100%;</span></span><br><span class="line"><span class="string">  font: inherit;</span></span><br><span class="line"><span class="string">  padding: 0.5rem 1.5rem;</span></span><br><span class="line"><span class="string">  border: 1px solid #8b005d;</span></span><br><span class="line"><span class="string">  color: white;</span></span><br><span class="line"><span class="string">  background: #8b005d;</span></span><br><span class="line"><span class="string">  box-shadow: 0 0 4px rgba(0, 0, 0, 0.26);</span></span><br><span class="line"><span class="string">  cursor: pointer;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  @media (min-width: 768px) &#123;</span></span><br><span class="line"><span class="string">    width: auto;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><h2 id="VSCode-Extension"><a href="#VSCode-Extension" class="headerlink" title="VSCode Extension"></a>VSCode Extension</h2><p>如果是 VSCode 的開發者，在使用 styled-components 這個 plugin 時，可以額外安裝 <a href="https://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-components">vscode-styled-components</a> 這個 extension，它不僅提供了 CSS emmet，還加上了 Syntax highlight，大大提高了開發效率。</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates">MDN Template literals</a><br><a href="https://styled-components.com/">Styled Components</a></p><!-- [Github](https://github.com/Jerry-Yeh/react-complete-guide/commit/08898606159d04d4eedc5b8c808679a73cf9e4b0) -->]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Setting Dynamic Inline Styles</title>
      <link href="/react/20220612/18219/"/>
      <url>/react/20220612/18219/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在前一章節中，我們可以將變數代入 JSX style 中動態賦值，這堂課將進一步套討 Conditional Style 更好的應用方式</p><span id="more"></span><p>在一個基本的輸入欄位中，如果使用者未輸入任何訊息及送出表單，通常會有進一步提示以提醒操作方式有誤，一個簡易的表單如下，如果判斷欄位為空，則 <code>return</code> 不做資料上的更改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CourseInput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredValue, setEnteredValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> goalInputChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredValue(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formSubmitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">if</span> (enteredValue.trim().length === <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 欄位為空</span></span><br><span class="line">    props.onAddGoal(enteredValue);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;form-control&quot;</span>&gt;</span><br><span class="line">        &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>進一步如果需要加上提示，就需要動態修改 <code>style</code> 內容，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CourseInput = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredValue, setEnteredValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [isValid, setIsValid] = useState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> goalInputChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.target.value.trim().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      setIsValid(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setEnteredValue(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formSubmitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">if</span> (enteredValue.trim().length === <span class="number">0</span>) &#123;</span><br><span class="line">      setIsValid(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    props.onAddGoal(enteredValue);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;form-control&quot;</span>&gt;</span><br><span class="line">        <span class="comment">// New Style Start</span></span><br><span class="line">        &lt;label style=&#123;&#123; <span class="attr">color</span>: !isValid ? <span class="string">&quot;red&quot;</span> : <span class="string">&quot;black&quot;</span> &#125;&#125;&gt;Course Goal&lt;/label&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          style=&#123;&#123;</span><br><span class="line">            borderColor: !isValid ? <span class="string">&quot;red&quot;</span> : <span class="string">&quot;#ccc&quot;</span>,</span><br><span class="line">            backgroundColor: !isValid ? <span class="string">&quot;salmon&quot;</span> : <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line">          &#125;&#125;</span><br><span class="line">          type=<span class="string">&quot;text&quot;</span></span><br><span class="line">          onChange=&#123;goalInputChangeHandler&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        <span class="comment">// New Style End</span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但很顯然的，這不是一個好方法，除了需要在 JSX 中加入大量的 style 和判斷外，在一般的狀態下還得重複撰寫已經定義在 .css 檔案中的初始樣式，在 React 中，我們有更好的方式來完成 Conditional Style</p><h2 id="Setting-CSS-Classed-Dynamically"><a href="#Setting-CSS-Classed-Dynamically" class="headerlink" title="Setting CSS Classed Dynamically"></a>Setting CSS Classed Dynamically</h2><p>其實無論是否透過 Framework 來開發，在處理 CSS Style 時，一般更傾向透過 <code>class</code> 來包含更多的樣式與狀態，而非透過 <code>style</code> 一一將樣式寫在 HTML 之中，不僅繁瑣也缺乏複用性 ; 同理，React 也可以透過動態加入 <code>class</code> 來更好的處理這種情況</p><p>首先，我們在 .css 檔案中加入特殊樣式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.form-control</span><span class="selector-class">.invalid</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.form-control</span><span class="selector-class">.invalid</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: red;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ffd7d7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著就可以透過相同參數判斷是否顯示這些 <code>class</code>，在不符合的條件下，僅需回傳空字串即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;form onSubmit=&#123;formSubmitHandler&#125;&gt;</span><br><span class="line">    &lt;div className=&#123;<span class="string">`form-control <span class="subst">$&#123;!isValid ? <span class="string">&#x27;invalid&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>&#125;&gt;   <span class="comment">// 條件判斷</span></span><br><span class="line">      &lt;label&gt;Course Goal&lt;/label&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;goalInputChangeHandler&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;Button type=<span class="string">&quot;submit&quot;</span>&gt;Add Goal&lt;/Button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/d1a9c9979618b9f30b7e8a19c956a9b6de0f384a">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adding a Chart</title>
      <link href="/react/20220612/34522/"/>
      <url>/react/20220612/34522/</url>
      
        <content type="html"><![CDATA[<p>這堂課將加上圖表來統計每個月份的總開銷，並根據資料動態改變 CSS Style</p><span id="more"></span><p>首先，新增一組 Component Bar.js，並加上基本結構如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bar.js</span></span><br><span class="line"><span class="keyword">const</span> Chart = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;chart&quot;</span>&gt;</span><br><span class="line">      &#123;props.dataPoints.map(<span class="function">(<span class="params">dataPoint</span>) =&gt;</span> (</span><br><span class="line">        &lt;ChartBar</span><br><span class="line">          key=&#123;dataPoint.label&#125;</span><br><span class="line">          value=&#123;dataPoint.value&#125;</span><br><span class="line">          label=&#123;dataPoint.label&#125;</span><br><span class="line">          maxValue=&#123;<span class="literal">null</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Adding-Dynamic-Styles"><a href="#Adding-Dynamic-Styles" class="headerlink" title="Adding Dynamic Styles"></a>Adding Dynamic Styles</h2><p>接著新增一組 Component ChartBar.js，其基本結構如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ChartBar = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;chart-bar&quot;</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;chart-bar__inner&quot;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;chart-bar__fill&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;chart-bar__label&quot;</span>&gt;&#123;props.label&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接著我們需要計算 props 進來的值，藉此動態顯示對應的 CSS Style ; 在 React 中，如果要在 JSX 加上 <code>style</code>，其中的值為一個 object {}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ChartBar = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> barFillHeight = <span class="string">&#x27;0%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (props.max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    barFillHeight = <span class="built_in">Math</span>.round((props.value / props.max) * <span class="number">100</span>) + <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;chart-bar&quot;</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;chart-bar__inner&quot;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;chart-bar__fill&quot;</span> style=&#123;&#123;<span class="attr">height</span>: barFillHeight&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;chart-bar__label&quot;</span>&gt;&#123;props.label&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果遇到 <code>background-color</code> 這種多字元的屬性，則須要透過引號 ‘’ 來包住它，或是透過駝峰式 Camel Case 來表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quatation Marks</span></span><br><span class="line">&lt;div className=<span class="string">&quot;chart-bar__fill&quot;</span> style=&#123;&#123;<span class="string">&#x27;background-color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Camel Case</span></span><br><span class="line">&lt;div className=<span class="string">&quot;chart-bar__fill&quot;</span> style=&#123;&#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="Wrap-Up-amp-Next-Steps"><a href="#Wrap-Up-amp-Next-Steps" class="headerlink" title="Wrap Up &amp; Next Steps"></a>Wrap Up &amp; Next Steps</h2><p>接著，我們可以在 Expense 資料節中新增一個 Component ExpenseChar 來導入 Component Chart，並帶入過濾後的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expenses.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  &lt;ExpenseChart expenses=&#123;filteredExpenses&#125;&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有了這些資料後，便可以對資料進行加總統計，並將資料整理成 Component Chart 需要的格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseChart.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseChart = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> chartDataPoints = [</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Jan&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Feb&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Mar&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Apr&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;May&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Jun&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Jul&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Aug&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Sep&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Oct&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Nov&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">label</span>: <span class="string">&quot;Dec&quot;</span>, <span class="attr">value</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> expense <span class="keyword">of</span> props.expenses) &#123;</span><br><span class="line">    <span class="keyword">const</span> expenseMonth = expense.date.getMonth(); <span class="comment">// starting at 0 =&gt; January =&gt; 0</span></span><br><span class="line">    chartDataPoints[expenseMonth].value += expense.amount; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Chart</span> <span class="attr">dataPoints</span>=<span class="string">&#123;chartDataPoints&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最後就可藉由這些資料取得最大值作為 100% 的基準了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chart.js</span></span><br><span class="line"><span class="keyword">const</span> Chart = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dataPointValues = props.dataPoints.map(<span class="function"><span class="params">dataPoint</span> =&gt;</span> dataPoint.value);</span><br><span class="line">  <span class="keyword">const</span> totalMaximum = <span class="built_in">Math</span>.max(...dataPointValues);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;chart&quot;</span>&gt;</span><br><span class="line">      &#123;props.dataPoints.map(<span class="function">(<span class="params">dataPoint</span>) =&gt;</span> (</span><br><span class="line">        &lt;ChartBar</span><br><span class="line">          key=&#123;dataPoint.label&#125;</span><br><span class="line">          value=&#123;dataPoint.value&#125;</span><br><span class="line">          label=&#123;dataPoint.label&#125;</span><br><span class="line">          maxValue=&#123;totalMaximum&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/d1a9c9979618b9f30b7e8a19c956a9b6de0f384a">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Outputting Conditional Content</title>
      <link href="/react/20220611/42263/"/>
      <url>/react/20220611/42263/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>這章節將透過篩選欄位來過濾符合條件的資料</p><span id="more"></span><p>其實在篩選條件的原理上和新增大同小異，都是對資料列表做出對應的改動，但比較不同的是，篩選時我們一般不會直接改動原資料，而是透過 <code>Array.filter()</code> 來產生一組符合條件的資料列表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Expenses</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [filteredYear, setFilteredYear] = useState(<span class="string">&quot;2020&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filterExpenses = props.item.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.date.getFullYear() === +filteredYear);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;filterExpenses.map(<span class="function">(<span class="params">expense</span>) =&gt;</span> (</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        key=&#123;expense.id&#125;</span><br><span class="line">        title=&#123;expense.title&#125;</span><br><span class="line">        amount=&#123;expense.amount&#125;</span><br><span class="line">        date=&#123;expense.date&#125;</span><br><span class="line">      &gt;&lt;/ExpenseItem&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="無資料預設內容"><a href="#無資料預設內容" class="headerlink" title="無資料預設內容"></a>無資料預設內容</h2><p>一般在介面設計上，無倫是圖片或是文字內容，在沒有取得資料時常會有預設內容以提升使用體驗，在這個範例中我們可以在判斷該年度沒有取得資料時，填入一段預設文字，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Expenses</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [filteredYear, setFilteredYear] = useState(<span class="string">&quot;2020&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filterExpenses = props.item.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.date.getFullYear() === +filteredYear);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;filterExpenses.length === <span class="number">0</span> ? (</span><br><span class="line">      &lt;p&gt;No expenses found.&lt;/p&gt;</span><br><span class="line">    ) : (</span><br><span class="line">      filterExpenses.map(<span class="function">(<span class="params">expense</span>) =&gt;</span> (</span><br><span class="line">        &lt;ExpenseItem</span><br><span class="line">          key=&#123;expense.id&#125;</span><br><span class="line">          title=&#123;expense.title&#125;</span><br><span class="line">          amount=&#123;expense.amount&#125;</span><br><span class="line">          date=&#123;expense.date&#125;</span><br><span class="line">        &gt;&lt;/ExpenseItem&gt;</span><br><span class="line">      ))</span><br><span class="line">    )&#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又或者可以透過 JavaScript &amp;<code>&amp;</code> 來改寫，當判斷第一個條件為 <code>true</code> 時，就顯示第二個條件的結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  ...</span><br><span class="line">  &#123;filterExpenses.length === <span class="number">0</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>No expenses found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">  &#123;filterExpenses.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    filterExpenses.map(<span class="function">(<span class="params">expense</span>) =&gt;</span> (</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        key=&#123;expense.id&#125;</span><br><span class="line">        title=&#123;expense.title&#125;</span><br><span class="line">        amount=&#123;expense.amount&#125;</span><br><span class="line">        date=&#123;expense.date&#125;</span><br><span class="line">      &gt;&lt;/ExpenseItem&gt;</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="區分-JS-邏輯與-HTML-頁面"><a href="#區分-JS-邏輯與-HTML-頁面" class="headerlink" title="區分 JS 邏輯與 HTML 頁面"></a>區分 JS 邏輯與 HTML 頁面</h2><p>這樣的寫法有一個問題是，隨著我們開發內容不斷增加，如果把過多的邏輯都寫到 <code>return</code> 中，就會讓程式碼看起來相對複雜一點，為了避免這個情況，我們可以將邏輯從 <code>return</code> 中抽離到 Component Function ; 在 React 中，有一個比較特別的用法是，JSX 其實不只可以寫在 <code>return</code> 內，還可以讓它作為一個變數的值來儲存，透過這個功能我們就可以輕易地將邏輯獨立出來</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Expenses</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [filteredYear, setFilteredYear] = useState(<span class="string">&quot;2020&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> filterExpenses = props.item.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.date.getFullYear() === +filteredYear);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> expenseContent = <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>No expenses found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (filterExpenses.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    expenseContent = filterExpenses.map(<span class="function">(<span class="params">expense</span>) =&gt;</span> (</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        key=&#123;expense.id&#125;</span><br><span class="line">        title=&#123;expense.title&#125;</span><br><span class="line">        amount=&#123;expense.amount&#125;</span><br><span class="line">        date=&#123;expense.date&#125;</span><br><span class="line">      &gt;&lt;/ExpenseItem&gt;</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">    &#123;expenseContent&#125;</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Adding-Conditional-Return-Statements"><a href="#Adding-Conditional-Return-Statements" class="headerlink" title="Adding Conditional Return Statements"></a>Adding Conditional Return Statements</h2><p>我們可以進一步將這些內容抽離出成為一個 Component ExpenseList，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expenses.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseList <span class="keyword">from</span> <span class="string">&#x27;./ExpenseList&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Expenses</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    &lt;ExpenseList items=&#123;filteredExpenses&#125;/&gt;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ExpenseList.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseItem <span class="keyword">from</span> <span class="string">&quot;./ExpenseItem&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">expense</span>) =&gt;</span> (</span><br><span class="line">        &lt;ExpenseItem</span><br><span class="line">          key=&#123;expense.id&#125;</span><br><span class="line">          title=&#123;expense.title&#125;</span><br><span class="line">          amount=&#123;expense.amount&#125;</span><br><span class="line">          date=&#123;expense.date&#125;</span><br><span class="line">        &gt;&lt;/ExpenseItem&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseList;</span><br></pre></td></tr></table></figure><p>但這裡有一個比較特別的做法是，因為 Component 抽離使的功能更加單純，所以先前透過判斷資料列表沒有資料時，所做的預設內容可以直接在條件符合時將之回傳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (props.items.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;expenses-list__fallback&quot;</span>&gt;</span>Found no expenses.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul className=<span class="string">&quot;expense-list&quot;</span>&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">expense</span>) =&gt;</span> (</span><br><span class="line">        &lt;ExpenseItem</span><br><span class="line">          key=&#123;expense.id&#125;</span><br><span class="line">          title=&#123;expense.title&#125;</span><br><span class="line">          amount=&#123;expense.amount&#125;</span><br><span class="line">          date=&#123;expense.date&#125;</span><br><span class="line">        &gt;&lt;/ExpenseItem&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rendering Lists of Data</title>
      <link href="/react/20220611/40578/"/>
      <url>/react/20220611/40578/</url>
      
        <content type="html"><![CDATA[<p>一般的使用者介面是透過資料動態呈現畫面的，延續這個範例，消費清單的比數應該根據資料的比數對應呈現，接下來畫面 (JSX) 將透過資料來產生</p><span id="more"></span><p>到目前為止，ExpenseItem 是透過 hard code 的方式固定 4 筆在頁面中，並沒有依照資料動態產生</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Expenses.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ExpenseItem <span class="keyword">from</span> <span class="string">&quot;./ExpenseItem&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./Expenses.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&quot;../UI/Card&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ExpensesFilter <span class="keyword">from</span> <span class="string">&quot;./ExpenseFilter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Expense = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [filteredYear, setFilteredYear] = useState(<span class="string">&quot;2020&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> filterChangeHandler = <span class="function">(<span class="params">selectedYear</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;selectedYear&quot;</span>, selectedYear);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=<span class="string">&quot;expenses&quot;</span>&gt;</span><br><span class="line">      &lt;ExpensesFilter</span><br><span class="line">        selected=&#123;filteredYear&#125;</span><br><span class="line">        onChnageFilter=&#123;filterChangeHandler&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">0</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">0</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">0</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">1</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">1</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">1</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">2</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">2</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">2</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">3</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">3</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">3</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Expense;</span><br></pre></td></tr></table></figure><p>而在 React 中，我們可以在 JSX 內透過透過大括號 {} 寫入任何 JS code，而如果寫入的是一個包含 JSX 的 Aarry，甚至可以直接被選染出來</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Expenses</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      ...</span><br><span class="line">      &#123;[<span class="xml"><span class="tag">&lt;<span class="name">ExpenseItem</span> /&gt;</span></span>, <span class="xml"><span class="tag">&lt;<span class="name">ExpenseItem</span> /&gt;</span></span>]&#125;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>透過這個功能，我們就可以動態的藉由傳進來的資料來產生對應的 JSX</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Expenses</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      ...</span><br><span class="line">      &#123;props.items.map(<span class="function">(<span class="params">expense</span>) =&gt;</span> (</span><br><span class="line">        &lt;ExpenseItem</span><br><span class="line">          title=&#123;expense.title&#125;</span><br><span class="line">          amount=&#123;expense.amount&#125;</span><br><span class="line">          date=&#123;expense.date&#125;</span><br><span class="line">        &gt;&lt;/ExpenseItem&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Using-Stateful-Lists"><a href="#Using-Stateful-Lists" class="headerlink" title="Using Stateful Lists"></a>Using Stateful Lists</h2><p>有了資料與頁面互相綁定後，接著要將新增項目 NewExpense 實際去更改資料，藉此更新頁面 ; 首先，我們可以接初始值 (一般來自於後端 API) 放置到 Component Function 之外，反正它只是暫時固定不變的值 (DUMMY_EXPENSES)，並透過 <code>useState</code> 建立觸發 Component Rerender 的資料，再將新增的資料塞到這組 Array 之中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DUMMY_EXPENSES = [</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&quot;Car Insurance&quot;</span>, <span class="attr">amount</span>: <span class="number">294.67</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">4</span>) &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&quot;Toilet Paper&quot;</span>, <span class="attr">amount</span>: <span class="number">94.12</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">3</span>) &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&quot;New TV&quot;</span>, <span class="attr">amount</span>: <span class="number">299.49</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">2</span>) &#125;,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&quot;New Desk (Wooden)&quot;</span>, <span class="attr">amount</span>: <span class="number">450</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">1</span>) &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [expenses, setExpenses] = useState(DUMMY_EXPENSES);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> addExpenseHandler = <span class="function">(<span class="params">expense</span>) =&gt;</span> &#123;</span><br><span class="line">    setExpenses([expense, ...expenses]);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;NewExpense onAddExpense=&#123;addExpenseHandler&#125;&gt;&lt;/NewExpense&gt;</span><br><span class="line">      &lt;Expenses items=&#123;expenses&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Updating-State-That-Depends-On-The-Previous-State"><a href="#Updating-State-That-Depends-On-The-Previous-State" class="headerlink" title="Updating State That Depends On The Previous State"></a>Updating State That Depends On The Previous State</h2><p>看似已經完成了，但這裡有一個問題是，在前面的課程中有提到，如果更改 State 資料是建立在上一筆資料，那麼 setState 中就必須透過一個一組 callback function 來改動否則可能會沒有取得最新的上一筆資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [expenses, setExpenses] = useState(DUMMY_EXPENSES);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> addExpenseHandler = <span class="function">(<span class="params">expense</span>) =&gt;</span> &#123;</span><br><span class="line">    setExpenses(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [expense, ...expenses];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;NewExpense onAddExpense=&#123;addExpenseHandler&#125;&gt;&lt;/NewExpense&gt;</span><br><span class="line">      &lt;Expenses items=&#123;expenses&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Understanding-“Keys”"><a href="#Understanding-“Keys”" class="headerlink" title="Understanding “Keys”"></a>Understanding “Keys”</h2><p>目前為止，一切看似符合我們的需求了，但在 devtools console 中，卻出現一組 error log 如下:</p><p><img src="key.png"></p><p>原因是在 React 中，如果是透過列表資料 (Array) 來渲染畫面，就必須在 JSX 中加入 <code>key</code> 屬性，藉此讓 React 知道每一筆資料所對應的 HTML Element，否則在每次更改這份列表資料時，React 因為無法知道每一筆資料所對應的 HTML Element，所以就會重新渲染整個列表，而非單純重新渲染更改的部分而已，這不只會造成效能上的消耗，更有可能產生無法預期的 bug，例如在原有 item 上有其它的更動。</p><p>這點可以透過打開 devtools Elements 中發現，如果沒有加上 <code>key</code>，即便在資料列表中，我們是將新資料家在最前方，但卻是在最後渲染一組新的 HTML Element，並將前面每一組資料向後遞延一位，因為 React 無法得知哪一筆是新資料，所以只能將整組列表重新渲染。</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/f1ac375e92b665a95e430071c02ee59ee1871bc2">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Child to Parent Component Communication (Bottom-up)</title>
      <link href="/react/20220608/9807/"/>
      <url>/react/20220608/9807/</url>
      
        <content type="html"><![CDATA[<p>在過去的課程中，我們可以透過 <code>props</code> 將資料由上而下從父元件傳遞到子元件，接下來將介紹如何層子元件由下而上傳遞資料到父元件</p><span id="more"></span><p>首先，我們先來了解一下為什麼會有這種由下而上傳遞資料的需求呢 ? 原因一般我們在開發時，會將頁面拆分成許多 Component 以利功能更加單純並兼具複用性，所以常會有資料從一個 Component 生成，但要反映到另一個 Component 來呈現，但傳遞資料只能以 Component 之間的關係垂直傳遞，無法任意傳遞到其他 Component，否則資料就會過於混亂難以管理。</p><p>那麼實作上到底該怎麼執行呢 ? 其實答案在之前的範例中已經出現了，那就是我們在監聽原生 <code>input</code> 時，透過 <code>onChange</code> 綁定一個 function，當 function 被執行時，其第一個參數就是從 input 回傳的 event</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredTitle, setEnteredTitle] = useState();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> titleChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredTitle(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;label&gt;Title&lt;/label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&quot;text&quot;</span></span><br><span class="line">        value=&#123;enteredTitle&#125;</span><br><span class="line">        onChange=&#123;titleChangeHandler&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      ...</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到我們的範例，首先，在父元件 (NewExpense) 綁定 event 到子元件 (ExpenseForm) 上，並期待它會回傳表單資訊 (expenseData)，再透過 <code>Math.random()</code> 追加一組隨機產生的 unique id (可能會重複，僅供練習測試)，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewExpense.js</span></span><br><span class="line"><span class="keyword">const</span> NewExpense = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> enteredExpenseHandler = <span class="function">(<span class="params">expense</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> expenseData = &#123;</span><br><span class="line">      ...expense,</span><br><span class="line">      id: <span class="built_in">Math</span>.random().toString(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;expenseData&#x27;</span>, expenseData);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;new-expense&#x27;</span>&gt;</span><br><span class="line">      &lt;ExpenseForm onEnteredExpense=&#123;enteredExpenseHandler&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接著來到子元件，我們可以從 <code>props</code> 中取得傳進來的 event <code>onEnteredExpense</code>，並將表單資料 <code>expenseData</code> 回傳給它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseForm</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> expenseData = &#123;</span><br><span class="line">      title: enteredTitle,</span><br><span class="line">      amount: enteredAmount,</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>(enteredDate),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    props.onEnteredExpense(expenseData);</span><br><span class="line">    setEnteredTitle(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    setEnteredAmount(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    setEnteredDate(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要這份表單資料的另一組元件 <code>ExpenseItem</code>，所以我們還需要繼續往上傳至根元件 <code>App.js</code>，才能過它傳遞到目標元件，而 Component 垂直傳遞的方式無法跳過中間元件 <code>NewExpense</code> (後面有其他作法)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewExpense.js</span></span><br><span class="line"><span class="keyword">const</span> NewExpense = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> enteredExpenseHandler = <span class="function">(<span class="params">expense</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> expenseData = &#123;</span><br><span class="line">      ...expense,</span><br><span class="line">      id: <span class="built_in">Math</span>.random().toString(),</span><br><span class="line">    &#125;;</span><br><span class="line">    props.onAddExpense(expenseData);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;new-expense&#x27;</span>&gt;</span><br><span class="line">      &lt;ExpenseForm onEnteredExpense=&#123;enteredExpenseHandler&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addExpenseHandler = <span class="function"><span class="params">expense</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;App.js&#x27;</span>, expense);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;NewExpense onAddExpense=&#123;addExpenseHandler&#125;&gt;&lt;/NewExpense&gt;</span><br><span class="line">      &lt;Expenses items=&#123;expenses&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/48949796ffcf7c04fa32de9e096e8d39a4b71af9">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handling Form Submission</title>
      <link href="/react/20220607/55451/"/>
      <url>/react/20220607/55451/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>接下來將取得表單資料，並模擬將表單資料送出的動作</p><span id="more"></span><p>在原生 browser 中，如果是位於 form 表單內 <code>type=&quot;submit&quot;</code> 的 button，在點擊時都會觸發 form 上預設的 event submit，在 React 中，按照慣例會在前方加上 on (onSubmit)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Add Expense&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但原生的 sumbit event 會因為送出 request 而 reload browser，這不是我們期待的結果，所以需要透過一個 default event function <code>event.preventDefault</code> 來預防這件事發生</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Add Expense&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著我們暫時先將三筆表單資料特自透過 <code>useState</code> 來建立，並在 submit event 中組合成一個 object 送出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredTitle, setEnteredTitle] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [enteredAmount, setEnteredAmount] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [enteredDate, setEnteredDate] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> expenseData = &#123;</span><br><span class="line">    title: enteredTitle,</span><br><span class="line">    amount: enteredAmount,</span><br><span class="line">    date: <span class="keyword">new</span> <span class="built_in">Date</span>(enteredDate),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(expenseData);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      ...</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Add Expense&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Adding-Two-Way-Binding"><a href="#Adding-Two-Way-Binding" class="headerlink" title="Adding Two-Way Binding"></a>Adding Two-Way Binding</h2><p>到目前為止，我們都只是單方面的監聽使用者輸入的內容，但如果我們希望在點擊送出表單的按鈕 (Submit) 時，將所有欄位的資料清空，就需要用到 React 中一個很重要的觀念 - 雙向綁定 Two-Way Binding，以現有的範例延伸，我們只需要在 <code>input</code> 上加上屬性 <code>value</code>，並將 State 各自綁定上去，這一來就可以藉由改變 State 來改變 <code>input</code> 的內容了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@format </span>*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseForm.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredTitle, setEnteredTitle] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [enteredAmount, setEnteredAmount] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [enteredDate, setEnteredDate] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> titleChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredTitle(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> amountChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredAmount(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dateChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredDate(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> submitHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">    setEnteredTitle(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    setEnteredAmount(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    setEnteredDate(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;submitHandler&#125;&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;new-expense__controls&quot;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;Title&lt;/label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">&quot;text&quot;</span></span><br><span class="line">            value=&#123;enteredTitle&#125;</span><br><span class="line">            onChange=&#123;titleChangeHandler&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;Amount&lt;/label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">&quot;number&quot;</span></span><br><span class="line">            min=<span class="string">&quot;0.01&quot;</span></span><br><span class="line">            step=<span class="string">&quot;0.01&quot;</span></span><br><span class="line">            value=&#123;enteredAmount&#125;</span><br><span class="line">            onChange=&#123;amountChangeHandler&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;<span class="built_in">Date</span>&lt;/label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">&quot;date&quot;</span></span><br><span class="line">            min=<span class="string">&quot;2019-01-01&quot;</span></span><br><span class="line">            max=<span class="string">&quot;2022-12-31&quot;</span></span><br><span class="line">            value=&#123;enteredDate&#125;</span><br><span class="line">            onChange=&#123;dateChangeHandler&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;new-expense__actions&quot;</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Add Expense&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseForm;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/48949796ffcf7c04fa32de9e096e8d39a4b71af9">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Form Inputs</title>
      <link href="/react/20220606/31080/"/>
      <url>/react/20220606/31080/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>接下來將會加入 Expense APP 最基本的功能 - 提供使用者自行新增 Expense Item</p><span id="more"></span><h2 id="Adding-Form-Inputs"><a href="#Adding-Form-Inputs" class="headerlink" title="Adding Form Inputs"></a>Adding Form Inputs</h2><p>首先，我們新增一組 Form Component 供使用者填入 Expense Item 資訊，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./ExpenseForm.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &lt;div className=<span class="string">&#x27;new-expense__controls&#x27;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;new-expense__control&#x27;</span>&gt;</span><br><span class="line">          &lt;label&gt;Title&lt;/label&gt;</span><br><span class="line">          &lt;input type=<span class="string">&#x27;text&#x27;</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;new-expense__control&#x27;</span>&gt;</span><br><span class="line">          &lt;label&gt;Amount&lt;/label&gt;</span><br><span class="line">          &lt;input type=<span class="string">&#x27;number&#x27;</span> min=<span class="string">&#x27;0.01&#x27;</span> step=<span class="string">&#x27;0.01&#x27;</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&#x27;new-expense__control&#x27;</span>&gt;</span><br><span class="line">          &lt;label&gt;<span class="built_in">Date</span>&lt;/label&gt;</span><br><span class="line">          &lt;input type=<span class="string">&#x27;date&#x27;</span> min=<span class="string">&#x27;2019-01-01&#x27;</span> max=<span class="string">&#x27;2022-12-31&#x27;</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&#x27;new-expense__actions&#x27;</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">&#x27;submit&#x27;</span>&gt;Add Expense&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseForm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewExpense.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ExpenseForm <span class="keyword">from</span> <span class="string">&#x27;./ExpenseForm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./NewExpense.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> NewExpense = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&#x27;new-expense&#x27;</span>&gt;</span><br><span class="line">      &lt;ExpenseForm /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> NewExpense;</span><br></pre></td></tr></table></figure><h2 id="Listening-to-User-Input"><a href="#Listening-to-User-Input" class="headerlink" title="Listening to User Input"></a>Listening to User Input</h2><p>接著我們需要監聽使用者在 Form 表單中所輸入的內容，如果是原生 JavaScript 的寫法就會是以下這樣</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doucment.getElementById(<span class="string">&quot;&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>在 React 中，我們可以在 <code>input</code> 上透過 <code>onChange</code> 來監聽它的變化，同樣不需要直接呼叫監聽的 function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseForm.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> titleChangeHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Title changed!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;new-expense__controls&quot;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;Title&lt;/label&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;titleChangeHandler&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;Amount&lt;/label&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;number&quot;</span> min=<span class="string">&quot;0.01&quot;</span> step=<span class="string">&quot;0.01&quot;</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;<span class="built_in">Date</span>&lt;/label&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;date&quot;</span> min=<span class="string">&quot;2019-01-01&quot;</span> max=<span class="string">&quot;2022-12-31&quot;</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;new-expense__actions&quot;</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Add Expense&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但目前我們只監聽到 <code>input</code> 變動的行為，還未取得到它的值，這時候就可以透過 handler 的預設參數 <code>event</code> 取得，我們可以透過 <code>console.log</code> 來查看它究竟是什麼</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> titleChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>會發現包含了許多屬性，其中 <code>target</code> 直接指向了 DOM element，而最常使用的 <code>target.value</code> 就是我們要取得的值了</p><p><img src="event.png"></p><h2 id="Working-with-Multiple-States"><a href="#Working-with-Multiple-States" class="headerlink" title="Working with Multiple States"></a>Working with Multiple States</h2><p>接著我們還需要透過先前的 <code>useState</code> 來儲存每次 <code>input</code> 輸入所更新的值，原因是透過這樣的方式儲存，就能避免每次 Component Functon re-render 資料被刷新的問題了 ; 在這組表單中，有 3 格欄位，基本用法上我們可以分成三 3 組 <code>useState</code> 來個別儲存資料，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseForm.js</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@format </span>*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseForm.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [enteredTitle, setEnteredTitle] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [enteredAmount, setEnteredAmount] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [enteredDate, setEnteredDate] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> titleChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredTitle(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> amountChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredAmount(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dateChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    setEnteredDate(event.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;new-expense__controls&quot;</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;Title&lt;/label&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;text&quot;</span> onChange=&#123;titleChangeHandler&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;Amount&lt;/label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">&quot;number&quot;</span></span><br><span class="line">            min=<span class="string">&quot;0.01&quot;</span></span><br><span class="line">            step=<span class="string">&quot;0.01&quot;</span></span><br><span class="line">            onChange=&#123;amountChangeHandler&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;new-expense__control&quot;</span>&gt;</span><br><span class="line">          &lt;label&gt;<span class="built_in">Date</span>&lt;/label&gt;</span><br><span class="line">          &lt;input</span><br><span class="line">            type=<span class="string">&quot;date&quot;</span></span><br><span class="line">            min=<span class="string">&quot;2019-01-01&quot;</span></span><br><span class="line">            max=<span class="string">&quot;2022-12-31&quot;</span></span><br><span class="line">            onChange=&#123;dateChangeHandler&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;new-expense__actions&quot;</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Add Expense&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseForm;</span><br></pre></td></tr></table></figure><h2 id="Using-One-State-Instead-And-What’s-Better"><a href="#Using-One-State-Instead-And-What’s-Better" class="headerlink" title="Using One State Instead (And What’s Better)"></a>Using One State Instead (And What’s Better)</h2><p>以上的作法在運作上完全沒有問題，但因為三組類似的 input 欄位使我們寫了相同的三組 <code>useState</code> 來定義這些資料，我們也可以改以一個 object 一口氣囊括這三個資料欄位來改寫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">const</span> [enteredTitle, setEnteredTitle] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> [enteredAmount, setEnteredAmount] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> [enteredDate, setEnteredDate] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">const</span> [userInput, setUserInput] = useState(&#123;</span><br><span class="line">  enteredTitle: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  enteredAmount: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  enteredDate: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那麼問題來了，每次使用者在透過 input 輸入資料時，其實只會更新這個 object data 中的一個屬性，那我們應該如何只更新這個屬性並保留其他兩個屬性得值呢 ?</p><p>ES6 提供了一個很方便的方法 - Spread <code>...</code>，透過這個方式，我們可以將舊的值 (userInput) 展開，並在後方以新的值賦寫目標屬性，即可得到只更新一個值的 object 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> titleChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  setUserInput(&#123;</span><br><span class="line">    ...userInput,</span><br><span class="line">    enteredTitle: event.target.value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> amountChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  setUserInput(&#123;</span><br><span class="line">    ...userInput,</span><br><span class="line">    enteredAmount: event.target.value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dateChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  setUserInput(&#123;</span><br><span class="line">    ...userInput,</span><br><span class="line">    enteredDate: event.target.value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Updating-State-That-Depends-On-The-Previous-State"><a href="#Updating-State-That-Depends-On-The-Previous-State" class="headerlink" title="Updating State That Depends On The Previous State"></a>Updating State That Depends On The Previous State</h2><p>以上的寫法在大部分的情況都沒有問題，但有時候我們會同時更新很多 State，而 React 在收到更新指令 (set function) 後，其實不會馬上去做更新，這會導致我們基於舊資料 (prevState) 所做的更新沒有可能會沒有取得最新的資料 ; React 在這種情況下提供了一個更安全的方式來解決這個問題，那就是將 set function 內的值改成一個 callback function，而這個 callback function 第一個參數就是舊資料 (preState)，最後 React 會以 return 的值最後新的值來更新 State。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">const</span> titleChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  setUserInput(&#123;</span><br><span class="line">    ...userInput,</span><br><span class="line">    enteredTitle: event.target.value,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">const</span> titleChangeHandler = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  setUserInput(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...prevState,</span><br><span class="line">      enteredTitle: event.target.value,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/b6954cdf79bc861c388dde6dac2184bef5608d89">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How Component Function Are Excuted</title>
      <link href="/react/20220605/28796/"/>
      <url>/react/20220605/28796/</url>
      
        <content type="html"><![CDATA[<p>一般透過使用者的操作進一步更改介面資料是非常普遍的行為，這一章節將透過 click event 來了解 Component Function 是如何運作的 </p><span id="more"></span><p>首先，我們將傳進 Component 的資料 <code>props.title</code> 透過一個變數存起來，接著再透過一個 button click event 來更改這筆資料，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseDate <span class="keyword">from</span> <span class="string">&quot;./ExpenseDate&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&#x27;../UI/Card&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseItem = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> title = props.title;</span><br><span class="line">  <span class="keyword">const</span> clickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    title = <span class="string">&#x27;Updated !!!&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(title);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;ExpenseDate date=&#123;props.date&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;clickHandler&#125;&gt;Change Title&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><p>然後我們嘗試透過點擊 button 來觸發資料更新，會發現 <code>console.log</code> 中的值有被印出來，但畫面上的資料並未被更改，為什麼會發生這樣的情況呢 ?</p><p>讓我們進一步了解 Component Function 的觸發方式，首先，會從最根本的檔案 (index.js) 開始運作，再從被指定做為 Root Component (App.js) 依序沿著被引入的 Component (Expenses.js -&gt; ExpenseItem.js -&gt; ExpenseDate.js) 所回傳的 JSX 取得頁面所需元件，最後再將它們渲染成瀏覽器可以讀取的 HTML 和 JavaScript，所有渲染的動作就到這裡為止，之後使用者所點擊的 click event 也只是呼叫我們所撰寫的 function，並不會再次渲染頁面，這也就是為什麼 <code>console.log</code> 中有印出資料，而頁面沒有跟著改變的原因了。</p><h2 id="Working-with-“State”-useState"><a href="#Working-with-“State”-useState" class="headerlink" title="Working with “State” (useState)"></a>Working with “State” (useState)</h2><p>為了解決資料改動後，需重新渲染畫面的問題，React 提供了一個名為 <code>State</code> 的 React Hook，在使用上，React 會在前方加上 use (useState)，我們只需要透過 import react 來取得這個 function，而這個 function 只能在 Component Function 內”直接”被使用，不能在它之外，也不能在它的 method 之內</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseDate <span class="keyword">from</span> <span class="string">&quot;./ExpenseDate&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&quot;../UI/Card&quot;</span>;</span><br><span class="line"></span><br><span class="line">useState();   <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">const</span> ExpenseItem = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> title = props.title;</span><br><span class="line">  useState();   <span class="comment">// Currect</span></span><br><span class="line">  <span class="keyword">const</span> clickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    useState();   <span class="comment">// Error</span></span><br><span class="line">    title = <span class="string">&quot;Updated !!!&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(title);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;ExpenseDate date=&#123;props.date&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;clickHandler&#125;&gt;Change Title&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><p>否則會出現以下 error log</p><p><img src="error-log.png"></p><p>當我們呼叫 <code>useState</code> 時，它會回傳一個 array，其中包含兩個值，分別為:</p><ul><li>第一個 variable: 用來存放值的變數，以上方範例就是存放 <code>props.title</code> 這個傳進 Component 的值</li><li>第二個 function: 需要更改第一個變數的值時，可以透過呼叫它來改動，並在它的第一個參數代入要改動的值</li></ul><p>那為什麼我們不能直接單純透過一個等號 = 賦予新的值呢 ? 原因是如果這麼做，又會回到一開始的狀況，值被更改但 React 並沒有重新渲染畫面，需要透過呼叫這個 function 更新，React 才會知道要重新呼叫 Component Function 以渲染畫面</p><p>既然回傳的是一個 array，這裡可以直接使用 ES6 Array Distructuring 來建立回傳 array 中的兩個參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseDate <span class="keyword">from</span> <span class="string">&quot;./ExpenseDate&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&quot;../UI/Card&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseItem = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [title, setTitle] = useState(props.title);</span><br><span class="line">  <span class="keyword">const</span> clickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setTitle(<span class="string">&quot;Updated !!!&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(title);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;ExpenseDate date=&#123;props.date&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;clickHandler&#125;&gt;Change Title&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><h2 id="A-Closer-Look-at-the-“useState”-Hook"><a href="#A-Closer-Look-at-the-“useState”-Hook" class="headerlink" title="A Closer Look at the “useState” Hook"></a>A Closer Look at the “useState” Hook</h2><p>即使是同一個 Component 在多處被重複使用，其內部的 State 都是獨立運作的彼此並不會互相干擾，否則我們當我們只是要操作單一 Component 的時候，所有使用到地方都同步更新就不符合我們期待的效果了，我們可透過在 child component 中加入 <code>console.log(&#39;ExpenseItem evaluated by React!&#39;)</code> 來判斷被呼叫的時機，從這點可以發現，只有在一次首次建立頁面時，被呼叫了 4 次，之後透過 button click event 觸發時都會只有一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expenses.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ExpenseItem <span class="keyword">from</span> <span class="string">&quot;./ExpenseItem&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./Expenses.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&#x27;../UI/Card&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Expense = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=<span class="string">&quot;expenses&quot;</span>&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">0</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">0</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">0</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">1</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">1</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">1</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">2</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">2</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">2</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">3</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">3</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">3</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Expense;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseDate <span class="keyword">from</span> <span class="string">&quot;./ExpenseDate&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&quot;../UI/Card&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExpenseItem = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [title, setTitle] = useState(props.title);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ExpenseItem evaluated by React!&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> clickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setTitle(<span class="string">&quot;Updated !!!&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(title);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;ExpenseDate date=&#123;props.date&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">        &lt;button onClick=&#123;clickHandler&#125;&gt;Change Title&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>那麼這裡又有另一個疑問了，既然透過 <code>useState</code> 所建立的變數是可以被更改的，那為什麼會使用 <code>const</code> 來建立呢 ?</p><p>原因是 React 在更新透過 <code>useState</code> 所建立的變數時，並不是單純透過等號 = 賦值，而是透過這個 Hook 對 React 進行註冊，所以當我們透過 <code>setTitle</code> 來更新時，React 會整個重新呼叫 Component Function，包含註冊變數這一行也會</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [title, setTitle] = useState(props.title);</span><br></pre></td></tr></table></figure><p>而 <code>props.title</code> 這個預設值並不會在更新時再次以它為預設值，只有第一次建立時才會，React 會對每次更新都透過 snapshot 的方式記錄，並在我們呼叫時回傳最新的值，藉此達到使用者與頁面互動的目的。</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/63ec319041dd1185e4f343c216cf66854cec40a2">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Listening to Events &amp; Working with Event Handlers</title>
      <link href="/react/20220605/41269/"/>
      <url>/react/20220605/41269/</url>
      
        <content type="html"><![CDATA[<p>到目前為止，專案的實作已拆成許多 Component 使其功能更加單純且可以重覆使用，但都還只停留在靜態資料，沒有包含使用者操作的行為，接下來將透過 React 提供的方式加入這些行為。</p><span id="more"></span><p>在 React 中，我們完全可以使用許多 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/HTMLElement">JavaScript Event</a>，但 JSX 並非一般 HTML，因此在寫法上會有些許的不同，如同前面課程所使用到的，<code>class</code> 就會由 <code>className</code> 來改寫，而 event 則會改由 <code>on$&#123;Event&#125;</code> 這種前方加上 on 的 Capital Character 的寫法，這裡我們先單純加上一個按鈕並透過 click event 印出一些資訊來測試</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">    &lt;button onClick=&#123;<span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&#x27;Clicked !!!&#x27;</span>)&#125;&#125;&gt;Change Title&lt;/button&gt;</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當然，也並非一定要使用 ES6 Arrow Function 不可，只是相較於一般 function 寫法更加簡潔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">    &lt;button onClick=&#123;<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;Clicked !!!&#x27;</span>)&#125;&#125;&gt;Change Title&lt;/button&gt;</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但就如同前面課程中所提到，在 JSX 中透過大括號 {} 可以寫入任何 JavaScript 邏輯，但為了更好的區分介面與邏輯，盡可能將邏輯寫在 JSX 外，再由名稱代入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> clickHandler = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Clicked !!!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">    &lt;button onClick=&#123;clickHandler&#125;&gt;Change Title&lt;/button&gt;</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡要特別注意的是，由 click event 所觸發的 <code>clickHandler</code> function 不需要寫成 <code>clickHandler()</code>，因為我們只是要讓程式知道當 click event 被觸發時，要呼叫這個 function，而不是在渲染它時就呼叫。</p><p>另外，在命名上，有一個非強制的建議是可以透過 <code>$&#123;event&#125;Handler</code> 這種命名方式來建立 function，以此區別單純由我們程式所觸發的 function 呼叫。</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>An Alternative Function Syntax</title>
      <link href="/react/20220605/34888/"/>
      <url>/react/20220605/34888/</url>
      
        <content type="html"><![CDATA[<p>在 React Componet 中，有一點反覆提到的就是其實我們就是在寫 JavaScript，所以我們當然也可以透過其他 JavaScript 語法來進行改寫，如 ES6 Arrow Function 就可以直接改寫 Compoent return function，但這並非必要，只是更進一步說明任何 JavaScript 語法都可以直接運用在 React Component 之中。</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 Arrow Function</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;...&#125;;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/8f79a87176b7da2e1b54521a00c619476b404baa">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Closer Look at JSX</title>
      <link href="/react/20220605/55243/"/>
      <url>/react/20220605/55243/</url>
      
        <content type="html"><![CDATA[<p>在前面關於 React 的基礎介紹中，我們反覆提到 React Component 中的 function return 的 JSX 並非瀏覽器所能讀取的 HTML，只是經過 React 封裝過看起來像是 HTML 而已，接下來我們會進一步探討 JSX 是如何運作的</p><span id="more"></span><p>首先，在透過 <code>npm start</code> (or <code>yarn start</code>) 所開啟的網頁中，打開 devtools -&gt; Application 中，可以看到在 bundle.js 內也有一個 function APP，這就是實際經過 React 編譯後，能被瀏覽器所讀取的最終結果。</p><p><img src="devtools.png"></p><h2 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement()"></a>React.createElement()</h2><p>接著回到我們透過 create-react-app 所建立的專案中，可以從 package.json 中知道預設安裝了 react 和 react-dom 這兩個 React 套件，但目前的 React 版本 (18) 的 Component 中，我們並不需要 import react，原因是 React 已經在背景為我們做到這件事了，這在較早的 React 版本中是需要開發者自行引入的，這裡我們可以嘗試使用舊有的方式來改寫 JSX。</p><p>以根目錄 App.js 為例，我們先 import react 物件，再透過 <code>React.createElement</code> 這個方法建立 HTML element，其中的參數分別為以下內容:</p><ul><li>第一個參數: 要建立的 HTML tag，如果是自製 Component 則直接帶入物件</li><li>第二個參數: tag 上的屬性</li><li>第三個參數: 這組 element 中的內容，如果是另外一層 HTML tag，則再透過 <code>React.createElement</code> 建立</li></ul><p>經過以上方式改寫後，結果就會如下方範例程式碼，且可以達到完全相同的結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Expenses <span class="keyword">from</span> <span class="string">&quot;./components/Expenses&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> expenses = [</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;Car Insurance&quot;</span>, <span class="attr">amount</span>: <span class="number">294.67</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">4</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;Toilet Paper&quot;</span>, <span class="attr">amount</span>: <span class="number">94.12</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">3</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;New TV&quot;</span>, <span class="attr">amount</span>: <span class="number">299.49</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">2</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;New Desk (Wooden)&quot;</span>, <span class="attr">amount</span>: <span class="number">450</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">1</span>) &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    React.createElement(<span class="string">&quot;h2&quot;</span>, &#123;&#125;, <span class="string">&quot;Let&#x27;s get started!&quot;</span>),</span><br><span class="line">    React.createElement(Expenses, &#123; <span class="attr">items</span>: expenses &#125;)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return (</span></span><br><span class="line">  <span class="comment">//   &lt;div className=&quot;App&quot;&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;h2&gt;Let&#x27;s get started!&lt;/h2&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;Expenses items=&#123;expenses&#125; /&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;/div&gt;</span></span><br><span class="line">  <span class="comment">// );</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/f2bd63783737eb58e311d7ecd36d476baaebc7d8">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Concept of Composition (children props)</title>
      <link href="/react/20220605/53422/"/>
      <url>/react/20220605/53422/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>延續之前的範例，我們還可以將 Component 中 container 共同的特性獨立出來做為一個可複用的 Component，這就稱為 Composition</p><span id="more"></span><p>在先前的案例中，我們可以發現，Expenses.css 和 ExpenseItem.css 中有相同的卡片樣式，這些相同的樣式都是 Component container 樣式，如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expenses.css */</span></span><br><span class="line"><span class="selector-class">.expenses</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2rem</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50rem</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">95%</span>;</span><br><span class="line">  <span class="comment">/* border-radius: 12px;</span></span><br><span class="line"><span class="comment">  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.25); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ExpenseItem.css */</span></span><br><span class="line"><span class="selector-class">.expense-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4b4b4b</span>;</span><br><span class="line">  <span class="comment">/* border-radius: 12px;</span></span><br><span class="line"><span class="comment">  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25); */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們可以將這裡相同的樣式切割出來成為 另一個 Component Card.js &amp; Card.css</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Card.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Card.css */</span></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4b4b4b</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著將這個 Component 取代 Expenses.js &amp; ExpenseItem.js 的 Container div element</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Expenses.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ExpenseItem <span class="keyword">from</span> <span class="string">&quot;./ExpenseItem&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./Expenses.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Card <span class="keyword">from</span> <span class="string">&#x27;./Card&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Expense</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Card className=<span class="string">&quot;expenses&quot;</span>&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">0</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">0</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">0</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">1</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">1</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">1</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">2</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">2</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">2</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;ExpenseItem</span><br><span class="line">        title=&#123;props.items[<span class="number">3</span>].title&#125;</span><br><span class="line">        amount=&#123;props.items[<span class="number">3</span>].amount&#125;</span><br><span class="line">        date=&#123;props.items[<span class="number">3</span>].date&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/Card&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Expense;</span><br></pre></td></tr></table></figure><h2 id="props-children"><a href="#props-children" class="headerlink" title="props.children"></a>props.children</h2><p>但在這裡會發現，Container 中的內容並沒有被渲染出來，但不用擔心，React 提供了一個解決方法，就是在 Component 中透過 <code>props.children</code> 作為內容代入 JSX 內，這個方法很像 Vue <code>slot</code> 的用法，就是透過一個標籤指定 Component 其他插入資訊的位置，如此一來就可以在預期的地方渲染出對應的畫面了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Card.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./Card.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;card&quot;</span>&gt;&#123;props.children&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Card;</span><br></pre></td></tr></table></figure><h2 id="props-className"><a href="#props-className" class="headerlink" title="props.className"></a>props.className</h2><p>到這裡為止，元件都有成功被渲染，但會發現原先 container 上的 className (expenses)並沒有被讀取到，而是單純只有因重複而被拉出去的 className (card) ; 這裡 React 提供了另一個方法 <code>props.className</code> 使兩者的 css 都可以被讀取到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Card.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./Card.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Card</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> classes = <span class="string">&#x27;card &#x27;</span> + props.className;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;classes&#125;&gt;&#123;props.children&#125;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Card;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/0739aa61606b6c6a678e504ea2072cee2e9ccbe1e">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Building a First Custom Component</title>
      <link href="/react/20220604/5794/"/>
      <url>/react/20220604/5794/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹如何客製化一個 Component</p><span id="more"></span><h2 id="Building-a-Basic-Component"><a href="#Building-a-Basic-Component" class="headerlink" title="Building a Basic Component"></a>Building a Basic Component</h2><p>延續先前的環境，其實在預設環境中，就有一個名為 APP 的 Component，這個 Component 是整個 SPA 專安的 Root Component，之後所有開發的 Component 都會從中做延伸。</p><p>而這個 Component 也為我們示範了如何在 React 中建立一個 Component，其實就是透過 JavaScript function return HTML Element (JSX) 來達到建立 Component 的目的 ; 我們一般會在 src 路徑底下建立一個 components 資料夾，接著在其內建立 component，如下，是一個名為 ExpenseItem 的 component，通常我們直接運用 Component 的名稱作為 return function 的名稱即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">  - components</span><br><span class="line">    -ExpenseItem</span><br><span class="line">  - App.js</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Expense item!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><p>接著會在 App.js 這個 Root Component 引入它，一般而言，我們會將 React Component 以 uppercase character 的方式寫入，以便區分原生 HTML element 的 lowercase character</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseItem <span class="keyword">from</span> <span class="string">&#x27;./components/ExpenseItem&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Let<span class="string">&#x27;s get started!&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;ExpenseItem&gt;&lt;/ExpenseItem&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default App;</span></span><br></pre></td></tr></table></figure><p>最後就可以在畫面上看到這些引入的內容了</p><h2 id="Writing-More-Complex-JSX-Code"><a href="#Writing-More-Complex-JSX-Code" class="headerlink" title="Writing More Complex JSX Code"></a>Writing More Complex JSX Code</h2><p>當然一般的開發情況不會像上面這個 Component 這麼單純，一個 Component 常常會有更多內容需要呈現，這時候我們需要透過小括號 () 來將這些 HTML element 包起來，並透過一個 <code>div</code> 將所有內容放進去，確保回傳時只有一個 parent element</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;June <span class="number">4</span> <span class="number">2022</span>&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;Car Insurance&lt;/h2&gt;</span><br><span class="line">        &lt;div&gt;$<span class="number">294.67</span>&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><h2 id="Adding-Basic-CSS-Styling"><a href="#Adding-Basic-CSS-Styling" class="headerlink" title="Adding Basic CSS Styling"></a>Adding Basic CSS Styling</h2><p>當然一個完整的專案不會只有 HTML 和 JavaScript，還會有許多 CSS 來調整 UI 的呈現，在 React 中，我們通常會在 Component 旁直接建立一支同名的 CSS 來開發它的 style，而且只要單純透過 <code>import</code> 就可以使用，但這裡要特別注意的是，Component function 所 return 的 HTML 終究不是原生的 HTML Element，而是 React 團隊開發出來像是 HTML 的 JSX，因此在寫法上會有些許的不同，一般採用 CSS 所使用 <code>class</code> 屬性也要改成 <code>className</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;June <span class="number">4</span> <span class="number">2022</span>&lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;Car Insurance&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$<span class="number">294.67</span>&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><h2 id="Outputting-Dynamic-Data-amp-Working-with-Expressions-in-JSX"><a href="#Outputting-Dynamic-Data-amp-Working-with-Expressions-in-JSX" class="headerlink" title="Outputting Dynamic Data &amp; Working with Expressions in JSX"></a>Outputting Dynamic Data &amp; Working with Expressions in JSX</h2><p>到目前為止，Component 的值還是 hard coded 在 HTML 內，第一步我們需要讓它由動態的資料帶入，回到之前所說的，React Component 它就是一個 JavaScript function，所以我們可以先在 function 內透過變數來代指這些資料，而在 JSX 中，我們可以透過大括號 {} 來填入各種 JavaScript 程式碼，藉此帶入動態的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> expenseDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">const</span> expenseTitle = <span class="string">&quot;Car Insurance&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> expenseAmount = <span class="number">294.67</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;&#123;expenseDate.toISOString()&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;expenseTitle&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;expenseAmount&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><h2 id="Passing-Data-via-“props”"><a href="#Passing-Data-via-“props”" class="headerlink" title="Passing Data via “props”"></a>Passing Data via “props”</h2><p>將整個專案拆成許多 Component 的目的不外乎就是為了能讓每個 Component 處理單一的邏輯與功能並提高程式碼的複用性 Reusable，因此，就以這個記帳項目的 Component 來說，資料應該是由外而內傳入的 Configurable ，並不會有固定的資料在裡面，否則就無法實現透過代入不同資料複用其功能與介面的目的了，Component 彼此無法直接使用對方的參數，這時候就會用到 React 中一個很重要的方法 - <code>props</code>。</p><p>首先，我們會有一筆資料列表位於外層的 Component (App.js)，接著可以自訂一名稱將資料變數直接定義在 JSX Component 上，並一樣透過大括號 {} 來代入這些資料變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ExpenseItem <span class="keyword">from</span> <span class="string">&quot;./components/ExpenseItem&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> expenses = [</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;Car Insurance&quot;</span>, <span class="attr">amount</span>: <span class="number">294.67</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">4</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;Toilet Paper&quot;</span>, <span class="attr">amount</span>: <span class="number">94.12</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">3</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;New TV&quot;</span>, <span class="attr">amount</span>: <span class="number">299.49</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">2</span>) &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">&quot;New Desk (Wooden)&quot;</span>, <span class="attr">amount</span>: <span class="number">450</span>, <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">1</span>) &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">      &lt;h2&gt;Let<span class="string">&#x27;s get started!&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;ExpenseItem</span></span><br><span class="line"><span class="string">        title=&#123;expenses[0].title&#125;</span></span><br><span class="line"><span class="string">        amount=&#123;expenses[0].amount&#125;</span></span><br><span class="line"><span class="string">        date=&#123;expenses[0].date&#125;</span></span><br><span class="line"><span class="string">      &gt;&lt;/ExpenseItem&gt;</span></span><br><span class="line"><span class="string">      &lt;ExpenseItem</span></span><br><span class="line"><span class="string">        title=&#123;expenses[1].title&#125;</span></span><br><span class="line"><span class="string">        amount=&#123;expenses[1].amount&#125;</span></span><br><span class="line"><span class="string">        date=&#123;expenses[1].date&#125;</span></span><br><span class="line"><span class="string">      &gt;&lt;/ExpenseItem&gt;</span></span><br><span class="line"><span class="string">      &lt;ExpenseItem</span></span><br><span class="line"><span class="string">        title=&#123;expenses[2].title&#125;</span></span><br><span class="line"><span class="string">        amount=&#123;expenses[2].amount&#125;</span></span><br><span class="line"><span class="string">        date=&#123;expenses[2].date&#125;</span></span><br><span class="line"><span class="string">      &gt;&lt;/ExpenseItem&gt;</span></span><br><span class="line"><span class="string">      &lt;ExpenseItem</span></span><br><span class="line"><span class="string">        title=&#123;expenses[3].title&#125;</span></span><br><span class="line"><span class="string">        amount=&#123;expenses[3].amount&#125;</span></span><br><span class="line"><span class="string">        date=&#123;expenses[3].date&#125;</span></span><br><span class="line"><span class="string">      &gt;&lt;/ExpenseItem&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default App;</span></span><br></pre></td></tr></table></figure><p>那麼接下來我們要如何取得傳進來的參數呢 ? 記得 Component 不過就是一個 return function，因此我們可以將參數透過 function parameter 傳入，但這裡要注意的是，無論我們在 Parent Component 中定義了多少個參數要傳到 Child Component 中，function parameter 都只會有一個，至於名稱可以自由定義，但一般我們會將它定義為這個方法的名稱 - <code>props</code>，而在 Parent Component 中定義於 JSX Component 上的名稱就是 <code>props</code> 的 <code>key</code>，如此一來就可以透過代入不同的參數達到 Component Reusable。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;&#123;props.date.toISOString()&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><h2 id="Adding-“normal”-JavaScript-Logic-to-Components"><a href="#Adding-“normal”-JavaScript-Logic-to-Components" class="headerlink" title="Adding “normal” JavaScript Logic to Components"></a>Adding “normal” JavaScript Logic to Components</h2><p>到目前為止，上述程式碼所渲染出來的日期格式與一般大家常見的使用習慣還是有點出入，如果我們希望日期可以被單獨拆分成年、月和日，可以使用 JavaScript Date 原生語法 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString">toLocaleString</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear">getFullYear</a> 來個別取得這些資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">month</span>: <span class="string">&quot;long&quot;</span> &#125;)&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">day</span>: <span class="string">&quot;2-digit&quot;</span> &#125;)&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;props.date.getFullYear()&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><p>即便在 React JSX 中，我們可以在大括號 {} 寫入任何 JavaScript 邏輯，但為了 HTML 與 JavaScript 可以區分得更明確，我們可以透過變數儲存這些邏輯再帶入 JSX 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> month = props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">month</span>: <span class="string">&quot;long&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> day = props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">day</span>: <span class="string">&quot;2-digit&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> year = props.date.getFullYear();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">month</span>: <span class="string">&quot;long&quot;</span> &#125;)&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">day</span>: <span class="string">&quot;2-digit&quot;</span> &#125;)&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;props.date.getFullYear()&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br></pre></td></tr></table></figure><h2 id="Splitting-Components-into-Multiple-Components"><a href="#Splitting-Components-into-Multiple-Components" class="headerlink" title="Splitting Components into Multiple Components"></a>Splitting Components into Multiple Components</h2><p>一般在開發時，為了因應使用需求，專案往往會有越來越多的功能與 Component，這是非常正常的 ; 因此，為了讓每個 Component 負責的功能更加單純，我們會將原有的 Component 繼續拆分成更小的 Component，但這並沒有一個硬性的規定什麼時候應該拆分，單純依照需求和經驗來判斷，延續上方的範例，我們可以嘗試將 ExpenseItem 中的 date 拆分成一個 ExpenseDate 使其功能更加單純。</p><p>首先，從 ExpenseItem 拆分出去後，我們需要 import ExpenseDate 將其引入使用，並將接受到的 date 這筆資料再次透過 <code>props</code> 傳給它，這裡特別注意一下，即便 ExpenseItem 因將 date 功能拆分出去後，並沒有直接使用到 date 這筆資料，但仍需透過它再將這筆資料 <code>props</code> 給 ExpenseDate，因為在 React 中，如果透過 <code>props</code> 傳遞資料，我們無法”跳過”中間層的 Component</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExpenseItem.js</span></span><br><span class="line"><span class="keyword">import</span> ExpenseDate <span class="keyword">from</span> <span class="string">&quot;./ExpenseDate&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ExpenseItem.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseItem</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">&quot;expense-item&quot;</span>&gt;</span><br><span class="line">      &lt;ExpenseDate date=&#123;props.date&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;expense-item__description&quot;</span>&gt;</span><br><span class="line">        &lt;h2&gt;&#123;props.title&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;div className=<span class="string">&quot;expense-item__price&quot;</span>&gt;$&#123;props.amount&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExpenseDate.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExpenseDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> month = props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">month</span>: <span class="string">&quot;long&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> day = props.date.toLocaleString(<span class="string">&quot;en-US&quot;</span>, &#123; <span class="attr">day</span>: <span class="string">&quot;2-digit&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> year = props.date.getFullYear();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;&#123;month&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;&#123;day&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;&#123;year&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ExpenseDate;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a><br><a href="https://github.com/Jerry-Yeh/react-complete-guide/commit/f2bd63783737eb58e311d7ecd36d476baaebc7d8">Github</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSX</title>
      <link href="/react/20220601/56348/"/>
      <url>/react/20220601/56348/</url>
      
        <content type="html"><![CDATA[<p>在 React 中，我們可以透過將 HTML 直接寫在 JavaScript 來達到開發 UI 的目的，這種專屬格式就稱為 JSX</p><span id="more"></span><p>延續上一章的的內容，再透過 create-react-app 所建立的初始專案中，將 App.js 中的內容注入預設的 HTML 中達到第一個 Component 開發，在這個檔案中，我們可以直接在 function 中回傳 HTML 達到建立頁面的目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;Let<span class="string">&#x27;s get started !&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;This is also visible&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default App;</span></span><br></pre></td></tr></table></figure><p>而這種方式其實不存在於原生語法中，在原生語法中，我們需要透過以下幾行程式碼來建立一個 HTML 元件並賦值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">para.textContent = <span class="string">&#x27;This is also visible&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>).append(para);</span><br></pre></td></tr></table></figure><p>而我們可以透過 JSX 方式來開發的原因就是 React 背景程式會將我們所開發的程式碼編譯成瀏覽器所能理解的原生語法，如果是在 Chrome 中，我們可以在透過 npm start 所建立的 local server 頁面的 devtools，打開 Application ，並看到 bundle.js，會發現也有一個 function App，但不只是我們開發的內容這麼簡單，而是包含了許多 React 程式碼，由此可見我們能這麼方便的開發，都是仰賴這些底層程式碼的編譯結果。</p><p><img src="devtools.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Creating a new React Project</title>
      <link href="/react/20220601/19798/"/>
      <url>/react/20220601/19798/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>Create React App 是創建 React 專案最方便的方式，對於我一個過去為 Vue 的開發者來說，他就如同 Vue CLI 的存在 ; 同樣也以 Node.js 作為背後的驅動，並在開發時提供一個 local server 及時同步開發程式與網頁呈現，並在最後將這些 Framework 的專屬程式碼打包成瀏覽器看得懂的原生 HTML、CSS 和 JavaScript 部屬在 production 環境。</p><span id="more"></span><h2 id="建立專案"><a href="#建立專案" class="headerlink" title="建立專案"></a>建立專案</h2><p>首先，我們需要先要先依據各自的作業系統安裝 <a href="https://nodejs.org/zh-tw/download/">Node.js</a> 作為背後的驅動，接著可以在 <a href="https://github.com/facebook/create-react-app">Github</a> 或 <a href="https://create-react-app.dev/">官方網站</a> 依照步驟安裝 Create React App</p><h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app <span class="variable">$&#123;app name&#125;</span></span><br></pre></td></tr></table></figure><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init react-app <span class="variable">$&#123;app name&#125;</span></span><br></pre></td></tr></table></figure><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn create react-app <span class="variable">$&#123;app name&#125;</span></span><br></pre></td></tr></table></figure><p>接著進到專案資料夾內，透過以下指令安裝 npm 預設第三方套件環境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>最後可以透過 npm 或 yarn 來啟動專案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;app name&#125;</span></span><br><span class="line"></span><br><span class="line">yarn start</span><br><span class="line">or</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="資料夾結構"><a href="#資料夾結構" class="headerlink" title="資料夾結構"></a>資料夾結構</h2><p>透過 create-react-app 所建立的 React 專案架構和 Vue CLI 所建立的專案基礎架構很類似，同樣都會有 node_modules 和 package.json 來管理第三方套件，並於 src 資料夾中進行開發</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">node_moduels</span><br><span class="line">public</span><br><span class="line">  - index.html</span><br><span class="line">src</span><br><span class="line">  - index.js</span><br><span class="line">  - index.css</span><br><span class="line">  - App.js</span><br><span class="line">package.json</span><br><span class="line">package-lock.json</span><br><span class="line">.gitignore</span><br></pre></td></tr></table></figure><p>在 React 專案中，有別於 Vue 中有 .vue 這種特殊的檔案類型，React 其實就是在寫 JavaScript，但又會發現許多原生以外的語法，例如在初始 index.js 中，就會引入 index.css 和 App.js，但其實原生檔案根本不會把 CSS 引入 JavaScript 中，原因是 React 環境會幫我們把這些編譯成瀏覽器可以解讀的語法，並透過 npm start 啟動一個 local server，及時同步開發內容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">root.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>接著往下看，會看到引入了來自 react 和 react-dom 的物件，這兩個套件其實都是 React ; <code>ReactDOM.createRoot</code> 透過 id 取得一個名為 root 的 HTML 元件，這時候可以看到 public 內的 index.html 中，包含這個 HTML 元件，原因是 React 和 Vue 一樣都是一個 SPA (Single-Page-Application) 框架，透過單頁的 index.html 抽換其中的內容來滿足使用者的頁面操作，這行指令就是以此作為注入點將我們接下來要開發的內容注入到 id=”root” 這個 HTML 元件中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而這個被注入的 <code>&lt;APP /&gt;</code> 又是什麼呢 ? 看起來很像一般的 HTML 但又不太一樣，其實這就是 React 所開發的 JSX 語法 ; 而這個 App.js，其實就是這個專案的第一個 Component，透過一個 function 回傳 HTML，將所有頁面以非原生的 JavaScript 來完成</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/react-the-complete-guide-incl-redux/">React - The Complete Guide (Incl Hooks, React Router, Redux)</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React - The Complete Guide (Incl Hooks, React Router, Redux) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>來打造一個 Framework/Library (三)</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220109/20734/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220109/20734/</url>
      
        <content type="html"><![CDATA[<p>回到最一開始的需求，我們還希望這個 Library 可以支援 <code>jQuery</code>，接下來的課程將完成這個需求，並為這個 Library 提供一些更完整的建議</p><span id="more"></span><h2 id="支援-jQuery"><a href="#支援-jQuery" class="headerlink" title="支援 jQuery"></a>支援 jQuery</h2><p>在前面的章節我們實作了許多方法，但目前都是將結果顯示在 <code>console</code> 中而已，接下來將會結合 <code>jQuery</code> 將結果顯示在 <code>jQuery</code> 取得的 DOM 上。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>首先我們看到 HTML 的部分，有一組 <code>select</code> 來選擇語言，還有一個 <code>input button</code> 來觸發事件，最後有一組 <code>h1</code> 來顯示結果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- @format --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Untitled Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;logindev&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;lang&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;en&quot;</span>&gt;</span>English<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;zh-tw&quot;</span>&gt;</span>Tranditional Chinese<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Login&quot;</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.6.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/greetr.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><p>接下來透過在 <code>prototype</code> 新增一個方法來達到以下幾個目的:</p><ul><li>判斷 <code>jQuery</code> 是否存在</li><li>取得 <code>jQuery selector</code> 所指定的 DOM 物件</li><li>呼叫的方法</li><li>將資料送到 HTML 中</li><li>維持 <code>Method Chaining</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Greetr.prototype = &#123;</span><br><span class="line"></span><br><span class="line">  HTMLGreeting: <span class="function"><span class="keyword">function</span>(<span class="params">selector, formal</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!$) <span class="keyword">throw</span> (<span class="string">&#x27;jQuery not loaded !&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!selector) <span class="keyword">throw</span> (<span class="string">&#x27;Missing jQuery selector !&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (formal) msg = formalGreeting();</span><br><span class="line">    <span class="keyword">else</span> msg = greeting();</span><br><span class="line"></span><br><span class="line">    $(selector).html(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Library-應用"><a href="#Library-應用" class="headerlink" title="Library 應用"></a>Library 應用</h3><p>最後，我們來實際使用一下這個 Library，在選取語言後，按下 Login 按鈕，就會出現預期的結果了 !</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;#login&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> loginGrtr = G$(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  $(<span class="string">&#x27;#logindiv&#x27;</span>).hide();</span><br><span class="line"></span><br><span class="line">  loginGrtr.setLang($(<span class="string">&#x27;#lang&#x27;</span>).val()).HTMLGreeting(<span class="string">&#x27;#greeting&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="result.png"></p><h2 id="好的註解"><a href="#好的註解" class="headerlink" title="好的註解"></a>好的註解</h2><p><code>JavaScript</code> 是一門非常簡潔的程式語言，相同的目的也有很多不同的方法可以實現，但這也帶出了一個問題，那就是如果其他人甚至是之後的自己，再回來看先前的程式碼時，時常會因為這種語言特性導致不容易馬上透過程式碼了解結構細節，因此，好的註解就成了輔助我們閱讀程式碼的關鍵，在每次開發時，不仿多花點時間為複雜的程式碼加上清楚的註解吧 !</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greetr.js</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, $</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &quot;new&quot; an object</span></span><br><span class="line">  <span class="keyword">var</span> Greetr = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greetr.init(firstname, lastname, language);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hidden within the scope of the IIFE and never directly acessible</span></span><br><span class="line">  <span class="keyword">var</span> supportedLangs = [<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;zh-tw&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> greetings = &#123;</span><br><span class="line">    en: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;zh-tw&#x27;</span>: <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> formalGreetings = &#123;</span><br><span class="line">    en: <span class="string">&#x27;Greetings&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;zh-tw&#x27;</span>: <span class="string">&#x27;歡迎&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> logMessages = &#123;</span><br><span class="line">    en: <span class="string">&#x27;Logged in&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;zh-tw&#x27;</span>: <span class="string">&#x27;登入&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.prototype = &#123;</span><br><span class="line"></span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">    &#125;,</span><br><span class="line">    validate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(supportedLangs.indexOf(<span class="built_in">this</span>.language) === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;Invalid language&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> greetings[<span class="built_in">this</span>.language] + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.firstname + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    formalGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> formalGreetings[<span class="built_in">this</span>.language] + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.fullName();</span><br><span class="line">    &#125;,</span><br><span class="line">    greet: <span class="function"><span class="keyword">function</span>(<span class="params">formal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> msg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if undefined or null, it will be coerced to &#x27;false&#x27;</span></span><br><span class="line">      <span class="keyword">if</span> (formal) msg = <span class="built_in">this</span>.formalGreeting();</span><br><span class="line">      <span class="keyword">else</span> msg = <span class="built_in">this</span>.greeting();</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">console</span>) <span class="built_in">console</span>.log(msg);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">console</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(logMessages[<span class="built_in">this</span>.language] + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">this</span>.fullName());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    setLang: <span class="function"><span class="keyword">function</span>(<span class="params">lang</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.language = lang;</span><br><span class="line">    </span><br><span class="line">      <span class="built_in">this</span>.validate();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    HTMLGreeting: <span class="function"><span class="keyword">function</span>(<span class="params">selector, formal</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!$) <span class="keyword">throw</span> (<span class="string">&#x27;jQuery not loaded !&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (!selector) <span class="keyword">throw</span> (<span class="string">&#x27;Missing jQuery selector !&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (formal) msg = <span class="built_in">this</span>.formalGreeting();</span><br><span class="line">      <span class="keyword">else</span> msg = <span class="built_in">this</span>.greeting();</span><br><span class="line">  </span><br><span class="line">      $(selector).html(msg);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init = <span class="function"><span class="keyword">function</span>(<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.firstname = firstname || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    self.lastname = lastname || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    self.language = language || <span class="string">&#x27;en&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Greetr.init.prototype = Greetr.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">global</span>.Greetr = <span class="built_in">global</span>.G$ = Greetr;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><h2 id="於-Library-一開始加上一個分號"><a href="#於-Library-一開始加上一個分號" class="headerlink" title="於 Library 一開始加上一個分號"></a>於 Library 一開始加上一個分號</h2><p>通常在開發時，我們會同時使用多個 Library，為了避免被前面的 Library 因為沒有使用分號 <code>;</code> 結尾導致出現非預期的錯誤，我們可以在自己開發的 Library 最前面加上一個分號。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greetr.js</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Library code </span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>來打造一個 Framework/Library (二)</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220109/49244/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220109/49244/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>延續上一堂課所打造 Library，接下來的課程將繼續擴充它的功能</p><span id="more"></span><p>在過去的課程中，我們有學到，如果希望透過 Function Constructor 所建立的物件都能有一些共同的方法，但是又不希望因為各自獨立而占用記憶體空間，這時候我們就可以將這些方法放在函式的 <code>prototype</code> 屬性內，如此一來，所有被建立的物件就可以在 <code>prototype</code> 找到這些方法了。</p><h2 id="Framework-Library-中的變數"><a href="#Framework-Library-中的變數" class="headerlink" title="Framework/Library 中的變數"></a>Framework/Library 中的變數</h2><p>如果我們希望有一些變數可以在我們所建立的 Library 中使用，但又不會被使用 Library 的人所串改，而且在他們使用 Library 中的方法時，可以取得這些變數，其實我們只要將這些變數直接放在 <code>IIFE</code> 內就好了，不需要放在 Function Constructor 或 <code>prototype</code> 內，這麼一來就會在使用這呼叫方法時透過 <code>closure</code> 的概念取得這些變數了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greetr.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, $</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Greetr = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greetr.init(firstname, lastname, language);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> supportedLangs = [<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;zh-tw&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> greetings = &#123;</span><br><span class="line">    en: <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    zh-tw: <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> formalGreetings = &#123;</span><br><span class="line">    en: <span class="string">&#x27;Greetings&#x27;</span>,</span><br><span class="line">    zh-tw: <span class="string">&#x27;歡迎&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> logMessages = &#123;</span><br><span class="line">    en: <span class="string">&#x27;Logged in&#x27;</span>,</span><br><span class="line">    zh-tw: <span class="string">&#x27;登入&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init = <span class="function"><span class="keyword">function</span>(<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.firstname = firstname || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    self.lastname = lastname || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    self.language = language || <span class="string">&#x27;en&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Greetr.init.prototype = Greetr.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">global</span>.Greetr = <span class="built_in">global</span>.G$ = Greetr;</span><br><span class="line"></span><br><span class="line"> &#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><h2 id="建立一些-Methods"><a href="#建立一些-Methods" class="headerlink" title="建立一些 Methods"></a>建立一些 Methods</h2><p>我們在 <code>IIFE</code> 於 <code>10~23</code> 行之間建立了一些變數，接下來將透過這些變數和使用者傳入的參數來建立一些方法。</p><h3 id="建立方法的位置"><a href="#建立方法的位置" class="headerlink" title="建立方法的位置"></a>建立方法的位置</h3><p>在建立方法時，有兩個地方可以供我們建立這些新的方法，分別是 <code>prototype</code> 與 Function Constructor 中，但前面有提到，為了不佔用多餘的記憶體空間，因此比較好的方式是將這些方法新增在 <code>prototype</code> 中</p><ul><li><p>prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Greetr.prototype = &#123;</span><br><span class="line">  <span class="comment">// add some methods</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Function Constructor</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Greetr.init = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  self.firstname = firstname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">  self.lastname = lastname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">  self.language = language || <span class="string">&quot;en&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add some methods</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="建立各種不同的方法"><a href="#建立各種不同的方法" class="headerlink" title="建立各種不同的方法"></a>建立各種不同的方法</h3><p>以下我們依序來建立一些不同的方法</p><ul><li><p>fullName: 取得使用者透過 Function Constructor 建立物件時，所傳入的參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>validate: 透過使用 <code>IIFE</code> 內的參數，並將串入的參數作為索引，來判斷是否符合預設的規則</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">validate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(supportedLangs.indexOf(<span class="built_in">this</span>.language) === -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;Invalid language&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>greeting: 結合 <code>IIFE</code> 內的參數與傳入的參數並將結果回傳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> greetings[<span class="built_in">this</span>.language] + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.firstname + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>formalGreeting: 結合 <code>IIFE</code> 內的參數與傳入的參數，再呼叫 <code>prototype</code> 其他的方法並回傳結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">formalGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> formalGreetings[<span class="built_in">this</span>.language] + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.fullName();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>greet: 透過使用者傳入的參數判斷使用的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greet: <span class="function"><span class="keyword">function</span>(<span class="params">formal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if undefined or null, it will be coerced to &#x27;false&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (formal) msg = <span class="built_in">this</span>.formalGreeting();</span><br><span class="line">  <span class="keyword">else</span> msg = <span class="built_in">this</span>.greeting();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">console</span>) <span class="built_in">console</span>.log(msg); </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>log: 判斷 <code>console</code> 是否存在，太舊的瀏覽器不支援</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">console</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(logMessages[<span class="built_in">this</span>.language] + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">this</span>.fullName());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>setLang: 更改串入的參數 <code>langauge</code>，並透過 <code>validate</code> 驗證是否符合規則</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setLang: <span class="function"><span class="keyword">function</span>(<span class="params">lang</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.langage = lang;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.validate();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Method-Chaining"><a href="#Method-Chaining" class="headerlink" title="Method Chaining"></a>Method Chaining</h3><p>還記的在 <code>jQuery</code> 中，當我們透過 <code>$</code> 指定一個 DOM 物件後，其後的方法可以一個接著一個呼叫，只要在每個方法最後 <code>return this</code>，就會在方法執行完後，重新將 <code>this</code> 指向原來呼叫方法的物件了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Greetr.prototype = &#123;</span><br><span class="line"></span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">  &#125;,</span><br><span class="line">  validate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(supportedLangs.indexOf(<span class="built_in">this</span>.language) === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">&#x27;Invalid language&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> greetings[<span class="built_in">this</span>.language] + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.firstname + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  formalGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> formalGreetings[<span class="built_in">this</span>.language] + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.fullName();</span><br><span class="line">  &#125;,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span>(<span class="params">formal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msg;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// if undefined or null, it will be coerced to &#x27;false&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (formal) msg = <span class="built_in">this</span>.formalGreeting();</span><br><span class="line">    <span class="keyword">else</span> msg = <span class="built_in">this</span>.greeting();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">console</span>) <span class="built_in">console</span>.log(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">console</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(logMessages[<span class="built_in">this</span>.language] + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">this</span>.fullName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  setLang: <span class="function"><span class="keyword">function</span>(<span class="params">lang</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.langage = lang;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">this</span>.validate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這麼一來，就可以連續使用這些方法了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> g = G$(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>).setLang(<span class="string">&#x27;zh-tw&#x27;</span>).greet().log();</span><br></pre></td></tr></table></figure><p><img src="final.png"></p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>來打造一個 Framework/Library (一)</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220109/57246/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220109/57246/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在之前的 <a href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220108/22241/" title="深入了解原始碼: jQuery">深入了解原始碼: jQuery</a> 課程中，從 jQuery 的原始碼中，了解到許多建立 <code>Framework</code> 和 Library 的技巧，在接下來的課程中將打造一個屬於我們自己的 Framework/Library !</p><span id="more"></span><h2 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h2><p>不論是在開發功能或是這次將實作的 <code>Framework/Library</code>，在開發前先釐清需求是最重要的，而非一股腦地動手寫程式。</p><p>在過去的課程中，作者將打招呼 <code>greeting</code> 作為許多觀念的範例，接下來的系列課程也不例外，我們稱這個 Library 為 <code>greetr</code>。</p><p>這個 Library 將會有以下幾個功能:</p><ul><li>給定姓 <code>firstname</code> 、名 <code>lastname</code> 和選擇語言 <code>optional language</code> 後，可以使用兩種正式 <code>formal</code> 與非正式 <code>informal</code> 的打招呼方式</li><li>支援英文 <code>English</code> 與西班牙文 <code>Spanish</code>，也許我們再加上中文 <code>Chinese</code></li><li>是一個可重複使用 (reusable) 的 Framework/Library，安裝的人可以直接使用，而不會干擾到它們自己的程式碼</li><li>就像 jQuery 一樣，可以直接輸入 <code>$()</code> 來使用，我們也希望直接輸入 <code>G$()</code> 來使用</li><li>可支援 jQuery，並將文字直接輸出到 HTML 上</li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>首先來了解一下專案架構，我們會有一個基本的 HTML 檔案來引入三支 <code>JavaScript</code> 檔案</p><ul><li>jquery.js: 我們會讓新的 Library - <code>greetr</code> 來支援它，所以先將它引入</li><li>greetr.js: 這就是我們將打造的 Library 程式碼</li><li>app.js: 這個基本專案的 <code>JS</code> 程式碼，將會在這裡使用 jQuery 與 <code>greetr</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Untitled Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;jquery-3.6.0.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;greetr.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;app.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Structuring-Safe-Code"><a href="#Structuring-Safe-Code" class="headerlink" title="Structuring Safe Code"></a>Structuring Safe Code</h2><p>在過去的課程中，我們有提到如果要建立一個不干擾全域環境的 Execution Context，我們需要透過 <code>IIFE</code> 來將所有程式碼包起來，另外，因為我們還希望它可以支援 jQuery，所以會將 <code>window</code> 和 jQuery 物件 - <code>$</code> 作為參數傳入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greetr.js</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// greetr code</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><h2 id="物件與其原型"><a href="#物件與其原型" class="headerlink" title="物件與其原型"></a>物件與其原型</h2><p>在一開始的需求有提到，在使用這個 Library 時，我們希望模仿 jQuery 的作法，讓使用者不須使用 <code>new</code> 就可以取得 <code>greetr</code> 的物件，那麼我們該怎麼做呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> g = G$(firstname , lastname, language);</span><br></pre></td></tr></table></figure><p>首先為了不需使用 <code>new</code> 就能建立，我們需要在使用者呼叫函式時，回傳另一個透過 <code>new</code> 建立的 Function Constructor，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Greetr = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greetr.init(firstname, lastname, language);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><h2 id="建立函式預設值"><a href="#建立函式預設值" class="headerlink" title="建立函式預設值"></a>建立函式預設值</h2><p>接著，我們需要提供這個函式一些預設的參數 <code>firstname</code>、<code>lastname</code> 與選擇性參數 <code>language</code>; 為了避免後續因執行環境改變 <code>this</code> 的值，所以先將 <code>this</code> 的值透過一個變數 <code>self</code> 存起來，接著將 <code>this</code> 的屬性賦予傳進來的參數，而因為 <code>language</code> 我們希望即使不帶入也有預設值 <code>en</code> ，因此透過 <code>||</code> (OR operator) 來給定預設值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greetr.js</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Greetr = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greetr.init(firstname, lastname, language);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.firstname = firstname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    self.lastname = lastname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    self.language = language || <span class="string">&quot;en&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><h2 id="建立原型-Prototype"><a href="#建立原型-Prototype" class="headerlink" title="建立原型 Prototype"></a>建立原型 Prototype</h2><p>還記得在之前的課程 <a href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220102/42224/" title="function-constructors-and-prototype">function-constructors-and-prototype</a> 的課程中有提到，當函式被建立時，會有一個名為 <code>prototype</code> 的屬性，而如果被作為 Function Constructor，透過 <code>new</code> 來建立的物件就會將其 <code>prototype</code> 指向函式的 <code>prototype</code> 屬性 ; 但因為先前為了讓使用者不須在使用 <code>new</code> 來建立物件，所以我們新增了另一個 Function Constructor，因為要將這兩個函式的 <code>prototype</code> 指向相同一個物件 <code>Greetr.init.prototype = Greetr.prototype;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// greetr.js</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Greetr = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greetr.init(firstname, lastname, language);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.firstname = firstname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    self.lastname = lastname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    self.language = language || <span class="string">&quot;en&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init.prototype = Greetr.prototype;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><h2 id="提供-G-使用"><a href="#提供-G-使用" class="headerlink" title="提供 G$ 使用"></a>提供 G$ 使用</h2><p>同樣回到一開始的需求，為了讓使用者可以像 jQuery 透過 <code>Greetr</code> 或縮寫 <code>G$</code> 來使用，我們必須將我們想提供的變數綁定到全域環境上，這時候就可以透過傳進來的 <code>window</code> (global) 來達到這個目的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Greetr = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Greetr.init(firstname, lastname, language);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.prototype = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init = <span class="function"><span class="keyword">function</span> (<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    self.firstname = firstname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    self.lastname = lastname || <span class="string">&quot;&quot;</span>;</span><br><span class="line">    self.language = language || <span class="string">&quot;en&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Greetr.init.prototype = Greetr.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">global</span>.Greetr = <span class="built_in">global</span>.G$ = Greetr;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, jQuery);</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>截至目前為止，我們所建立的 Library 已經可以這常使用了，透過呼叫 <code>G$</code> 帶入參數就可以得到一個我們所建立的物件了，而目前 <code>prototype</code> 還只是一個空物件，接下來將會在其中加入更多的功能供使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = G$(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g);</span><br></pre></td></tr></table></figure><p><img src="summary.png"></p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深入了解原始碼: jQuery</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220108/22241/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220108/22241/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>接下來的課程將探討一個很有的 JavaScript Library - jQuery，但課程中並不會去個別了解每個功能是如何實作的，而是去學習如何閱讀程式碼與了解其中的架構。</p><span id="more"></span><p>jQuery 是一個非常熱門的 JavaScript Library，但它其實並沒有為瀏覽器或 JavaScript 增添其他特性，而是單純透過封裝 JavaScript 來實現，且使用同一份原始碼就能支援各種瀏覽器環境。</p><p>jQuery 是封裝 JavaScript 並操縱 <code>DOM</code> 物件來實現它的功能，以下我們直接透過程式碼來了解它是如何運作的。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>首先我們可以在 <a href="https://jquery.com/download/">jQuery 官方網站</a> 下載未經壓縮的檔案，好處是它包含許多註解，可以藉此幫助我們了解程式碼，接著簡單的載一個 HTML 檔內載入我們所下載的 jQuery 檔案與自行撰寫的 JavaScript 檔案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"></span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;main&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;People&lt;/h1&gt;</span><br><span class="line">      &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;people&quot;</span>&gt;</span><br><span class="line">        &lt;li&gt;John Doe&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;Jane Doe&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;Jim Doe&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;js/jquery-3.6.0.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;js/app.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接著就可以在 JS 檔案中使用 jQuery，我們可以透過 jQuery或 <code>$</code> 使用它，括號中可以像 CSS 一樣透過 <code>tag</code>、<code>id</code> 或 <code>class</code> 指定 <code>DOM</code> 物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> q = $(<span class="string">&quot;ul.people li&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(q);</span><br></pre></td></tr></table></figure><p>透過 <code>console.log</code> 發現，符合的 <code>DOM</code> 物件會以 <code>jQuery.fn.init</code> 中的陣列來呈現，而每個取得的直都是一個 <code>DOM</code> 物件，而且它的 <code>prototype</code> 會指向一個 jQuery 物件，其中包含許多 <code>method</code> 可以使用</p><p><img src="$().png"></p><h2 id="原始碼"><a href="#原始碼" class="headerlink" title="原始碼"></a>原始碼</h2><p>接著我們來透過 jQuery 的原始碼了解為什麼會有上述的結果 ; 在這篇筆記撰寫的當下， jQuery 以來到 3.6 版，因此在官網下載未經壓縮的檔案後，得到一個 <code>jquery-3/6/0.js</code> 的檔案，打開這個檔案查看，會發現一共有一萬多行的程式碼，但我們並不是要一行行的讀它，而是先來了解它的架構。</p><h3 id="環境判斷"><a href="#環境判斷" class="headerlink" title="環境判斷"></a>環境判斷</h3><p>首先，他執行了一個 <code>IIFE</code> 來，並傳入兩個參數 <code>global</code> 與 <code>factory</code>，並在一開始透過判斷 <code>module</code> 和 <code>module.exports</code> 是否為物件來確認是 <code>CommonJS</code>、<code>CommonJS-like</code> 或 <code>Node.js</code> 環境。</p><ul><li><code>global</code>: 透過 <code>window</code> 物件是否存在，如果存在就帶入 <code>window</code>，反之則是當下執行環境本身 - <code>this</code></li><li><code>factory</code>: 這裡則是實際 jQuery 的所有程式碼，可以看到如果 <code>typeof module</code> 不是 <code>object</code> (一般 JS 環境)，就會直接把 <code>window</code> 作為 <code>global</code> 執行 <code>factory</code> 函式。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">global</span>.ducument</span><br><span class="line">      ? factory(<span class="built_in">global</span>, <span class="literal">true</span>)</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">w</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!w.document) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;jQuery requires a window with a document&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> factory(w);</span><br><span class="line">        &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory(<span class="built_in">global</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">window</span> : <span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, noGlobal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// jQuery code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="為什麼-jQuery-不需要透過-new-建立物件"><a href="#為什麼-jQuery-不需要透過-new-建立物件" class="headerlink" title="為什麼 jQuery 不需要透過 new 建立物件 ?"></a>為什麼 jQuery 不需要透過 new 建立物件 ?</h3><p>還記得前面透過錢字號 <code>$</code> 帶入 CSS 選擇器指定 DOM 物件就可以直接使用 jQuery 嗎 ?</p><p>接下來我們來看一下為什麼可以這麼使用，一樣看到程式碼 ; 首先建立一個名為 jQuery 的變數名稱，並指派一個函式給它，透過關鍵字 <code>new</code> 一個 <code>function constructor</code>，所以我們在使用它的時候就不需要加上 <code>new</code> 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="jQuery-fn-又是什麼呢"><a href="#jQuery-fn-又是什麼呢" class="headerlink" title="jQuery.fn 又是什麼呢 ?"></a>jQuery.fn 又是什麼呢 ?</h3><p>繼續往下看到程式碼，<code>jQuery.fn</code> 被指派為 <code>jQuery.prototype</code>，還記得 <a href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220102/42224/" title="function-constructors-and-prototype">function-constructors-and-prototype</a> 中提到，函式都會有一個 <code>prototype</code> 屬性來作為透過 <code>function constructor</code> 建立物件的 <code>prototype</code>，jQuery 以 <code>fn</code> 來作為 <code>prototype</code> 的別名 <code>(alias)</code>，其中包含許多 <code>method</code> 供使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">  constuctor: jQuery,</span><br><span class="line">  <span class="comment">// some methods ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="jQuery-extend"><a href="#jQuery-extend" class="headerlink" title="jQuery.extend"></a>jQuery.extend</h3><p>在 <a href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211228/40176/" title="reflection-and-extend">reflection-and-extend</a> 這堂課中，我們就介紹了 <code>underscore.js</code> 透過 <code>extend</code> 來擴充物件的屬性和方法到另一個物件上，其實 <code>jQuery.extend</code> 也是做了相同的事情</p><h3 id="在-jQuery-IIFE-中執行其他-Library-IIFE"><a href="#在-jQuery-IIFE-中執行其他-Library-IIFE" class="headerlink" title="在 jQuery IIFE 中執行其他 Library IIFE"></a>在 jQuery IIFE 中執行其他 Library IIFE</h3><p>接著往下會看到有一個名為 <code>Sizzle</code> 的變數被賦予 <code>IIFE</code>，註解還補上了 <a href="https://github.com/jquery/sizzle/wiki/">相關網址</a>，點開後發現這是一個 <code>CSS Selectors Library</code>，先不論詳細情況它做了什麼事，原來在 Library IIFE 中還可以使用另一個 Library 的 IIFE !</p><p>接著往後看到原來 <code>jQuery.find</code> 就是 <code>Sizzle</code>，而 <code>jQuery.expr</code> 就是 <code>Sizzle.selectors</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;&#125;)(</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">window</span> : <span class="built_in">this</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span>, noGlobal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Sizzle = (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// do something ...</span></span><br><span class="line">    &#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line">    jQuery.find = Sizzle;</span><br><span class="line">    jQuery.expr = Sizzle.selectors;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="new-回傳之前做點別的事"><a href="#new-回傳之前做點別的事" class="headerlink" title="new 回傳之前做點別的事"></a>new 回傳之前做點別的事</h3><p>在前面的課程中提到，如果透過建立 <code>function constructor</code>，再透過 <code>new</code> 新的物件，會自動生成一個新的空物件，並將 <code>this</code> 指向它，但接續一開始在我們使用 jQuery 時，因為它幫我們回傳一個 <code>new</code>，所以我們不需要透過 <code>new</code> 來建立 jQuery 物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但接著看到 <code>init</code> 函式，會發現它回傳的竟然是 <code>jQuery.makeArray</code> 函式所回傳的值，其中還帶入 <code>this</code> 這個參數，而 <code>this</code> 又是什麼呢 ? 這裡的 <code>this</code> 其實就是透過 <code>new</code> 所建立的新空物件，那既然透過 <code>new</code> 就會自動回傳一個空物件，它是不是有哪裡搞錯了呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> init = (jQuery.fn.init = <span class="function"><span class="keyword">function</span> (<span class="params">selector, context, root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> jQuery.makeArray(selector, <span class="built_in">this</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>讓我們繼續看到 <code>makeArray</code> 到底做了什麼</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">  makeArray: <span class="function"><span class="keyword">function</span> (<span class="params">arr, results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = results || [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isArrayLike(<span class="built_in">Object</span>(arr))) &#123;</span><br><span class="line">        jQuery.merge(ret, <span class="keyword">typeof</span> arr === <span class="string">&quot;string&quot;</span> ? [arr] : arr);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        push.call(ret, arr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>原來它最後還是把傳入的 <code>this</code> 回傳了，只是在這之前又做了其他事情而已。</p><h3 id="所有透過-jQuery-指向的-DOM-物件的-prototype-都是-jQuery"><a href="#所有透過-jQuery-指向的-DOM-物件的-prototype-都是-jQuery" class="headerlink" title="所有透過 jQuery 指向的 DOM 物件的 prototype 都是 jQuery"></a>所有透過 jQuery 指向的 DOM 物件的 prototype 都是 jQuery</h3><p>回到一開始，當我們透過 jQuery 帶入 CSS selector 所建立的物件，其 <code>prototyope</code> 都指向 <code>jQuery.prototype</code>，讓我們來看一下這是如何發生的 ; 原來是它將 <code>init.prototype</code> 也指向 <code>jQuery.fn</code>，也就是 <code>jQuery.prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> init = (jQuery.fn.init = <span class="function"><span class="keyword">function</span> (<span class="params">selector, context, root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure><h2 id="Method-Chain"><a href="#Method-Chain" class="headerlink" title="Method Chain"></a>Method Chain</h2><p><code>Method Chain</code> 指的是在 jQuery 中，當我們指定一個 DOM 物件後，可以在其後方不斷串接 <code>method</code>，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q = $(<span class="string">&#x27;ul.people&#x27;</span>).addClass(<span class="string">&#x27;newclass&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(q);</span><br></pre></td></tr></table></figure><p>當我們在後方串上一個 <code>addClass</code>，被指定的 DOM 物件就會加上這個 <code>class</code></p><p><img src="newClass.png"></p><p>不僅如此，我們還可以在後方繼續串下去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q = $(<span class="string">&#x27;ul.people&#x27;</span>).addClass(<span class="string">&#x27;newclass&#x27;</span>).removeClass(<span class="string">&#x27;newclass&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(q);</span><br></pre></td></tr></table></figure><p><img src="removeclass.png"></p><p>那麼這到底是如何做到的呢 ?</p><p>首先我們在 jQuery 原始碼中找到 <code>addClass</code>，會發現最後 <code>return this</code>，這裡的 <code>this</code> 指的就是呼叫這個函式的物件 <code>$(&#39;ul.people&#39;)</code>，而如果這個物件沒有該方法，就會透過 <code>prototypal chain</code> 找，所以找到了 jQuery 物件 ; 接著看下去，會發現包含 <code>removeClass</code> 的方法也都在最後 <code>return this</code>，這就是為什麼 jQuery 中可以不斷串接方法的原因了 !</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line"></span><br><span class="line">  addClass: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeClass: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h2 id="我們為什麼可以使用-jQuery-和"><a href="#我們為什麼可以使用-jQuery-和" class="headerlink" title="我們為什麼可以使用 jQuery 和 $"></a>我們為什麼可以使用 jQuery 和 $</h2><p>那麼回到最一開始的問題，為什麼我們載入 jQuery 的原始碼 - <code>jquery-3.6.0.js</code> 後，我們就可以直接呼叫 jQuery 和 <code>$</code> 來使用呢 ?</p><p>因為在一開始的 <code>IIFE</code> 中，我們判斷 <code>window</code> 存在後，就不帶入第二個 <code>callback function</code> 參數的第二個參數 <code>noGlobal</code>，看到原始碼最下方會發現，當判斷 <code>noGlobal</code> 不存在後，並賦予全域物件 <code>window</code> 的 jQuery 和 <code>$</code> 等於 jQuery 函式了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> ? <span class="built_in">window</span> : <span class="built_in">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span>, noGlobal</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// jQuery code</span></span><br><span class="line">  <span class="keyword">if</span> (!noGlobal) &#123;</span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嚴謹模式</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220106/47596/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220106/47596/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>JavaScript 有一個特別的選擇性模式來偵測我們所寫的程式碼，開啟它可以迫使 JavaScript Engine 更嚴謹的審視程式碼，它就是嚴謹模式 <code>strict mode</code></p><span id="more"></span><p>只要在 JavaScript 中加上字串 <code>use strict</code>，就會開啟嚴謹模式 <code>strict mode</code>。在嚴謹模式下，會有許多更嚴謹的規範來避免開發上的疏失，如下範例:</p><p>如果先建立一個變數，但在之後賦值時拼錯了，一般情況下並不會有任何錯誤，只是前者會因為沒有值而為預設的 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person;</span><br><span class="line"></span><br><span class="line">persom = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(persom); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>但如果加上 <code>use strict</code> 來開啟嚴謹模式，就會因為拼錯的 <code>persom</code> 沒有宣告而跳錯。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person;</span><br><span class="line"></span><br><span class="line">persom = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(persom); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="error.png"></p><p>嚴謹模式除了可以在整個檔案開啟，也可以單獨在函式作用域中開啟</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNewPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> person2;</span><br><span class="line"></span><br><span class="line">  persom2 = &#123;&#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(person2); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(persom2); <span class="comment">// &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person;</span><br><span class="line"></span><br><span class="line">persom = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(persom); <span class="comment">// &#123;&#125;</span></span><br><span class="line">logNewPerson();</span><br></pre></td></tr></table></figure><p><img src="error-in-function.png"></p><p>嚴謹模式固然好用，但需要選擇性開啟的原因是每個 JavaScript Engine 對嚴謹模式所支援的規範並不相同，因此我們無法完全依賴它來開發。</p><p>另外有一種情況是如果我們在一支主要的 JavaScript 檔案開啟嚴謹模式，並透過它引入其它的 JavaScript 檔案，但其它的 JavaScript 檔案在開發時並沒有開啟且遵守嚴謹模式的規範，那麼這可能為你帶來一些預料之外的問題。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">MDN Mozilla Developer Network</a><br><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>typeof and instanceof</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220105/35648/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220105/35648/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹兩個實用的內建語法，<code>typeof</code> and <code>instanceof</code></p><span id="more"></span><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>當我們都過 <code>typeof</code> 加上一個空格後，放上我們要辨識的變數，它就會回傳一個該變數型別的字串，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);   <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b):   <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> c);   <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>而因為陣列也是物件，所以透過 <code>typeof</code> 查看陣列型別時，也會回傳字串 <code>object</code>，但這裡有一個更實用的方法來辨別一般物件與陣列，只要將 <code>Object.prototype</code> 的方法 <code>toString</code> 透過 <code>call</code> 將 <code>this</code> 指向陣列，它就不會單純回傳一個字串 <code>object</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = [];</span><br><span class="line"><span class="built_in">console</span>.log(d);   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(d));   <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure><p>但如果直接在陣列呼叫 <code>toString</code>，它會將陣列中的值字串化，如陣列 <code>d</code> 是一個空陣列，因此回傳空值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(d.toString());   <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>而 <code>undefined</code> 的型別就是 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h3><p>但這裡有一個 <code>JavaScript</code> 的 Bug，而且它也沒有打算修復，因為這個 Bug 已經存在很久了，如果修復它會影響很多已存在的專案和 library ; 那就是透過 <code>typeof</code> 查看 <code>null</code> 時，會回傳字串 <code>object</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);   <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 則是會判斷前面的值是否可以在它的 <code>prototypal chain</code> 找到後面的值，如下範例:</p><p>先建立一個 function constructor - <code>Person</code>，再透過 <code>new</code> 建立新的物件 <code>e</code> ，因為 <code>e</code> 的 <code>prototype</code> 就是 <code>Person</code>，所以回傳 <code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> Person(<span class="string">&#x27;Jane&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> e);   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(e <span class="keyword">instanceof</span> Person);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Initialization</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220105/4260/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220105/4260/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹一個常見的情況 - 初始化 Initialization</p><span id="more"></span><p>當我們在開發時，有時會見到一段物件資料透過基本的方法 object literal、array literal 或 expression function 來建立，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">    addresses: [</span><br><span class="line">      <span class="string">&#x27;111 Main St.&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;22 Third St.&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    firstname: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">    lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">    addresses: [</span><br><span class="line">      <span class="string">&#x27;333 Main St.&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;444 Fifth St.&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    greet: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Hello !&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>這一個陣列可能包含許多資料，物件的資料又可能包含許多屬性與方法，但當我們看到這種情況時，其實不需要太緊張，因為這其實是非常直覺又簡潔的資料呈現方式，常用於在透過 API 取得資料前，先給定一些預設值來呈現。</p><h2 id="Error-log"><a href="#Error-log" class="headerlink" title="Error log"></a>Error log</h2><p>當我們在開發時，如果遇到以下 error log，常常是漏掉了分隔資料的逗號 <code>,</code>，導致資料結構出現非預期的呈現。</p><p><img src="error-log.png"></p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6與類別</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220104/6272/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220104/6272/</url>
      
        <content type="html"><![CDATA[<p>在過去的的課程中有提到，JavaScript 並不像其他程式語言一樣有 <code>class</code> 來定義並創造物件，但在 <code>ES6</code> 開始，JavaScript 有了 <code>class</code> 這個用法，但與其它程式語言的功能並不一樣，接下來讓我們來了解一下如何使用這個新用法吧。</p><span id="more"></span><h2 id="建立一個-Class"><a href="#建立一個-Class" class="headerlink" title="建立一個 Class"></a>建立一個 Class</h2><p>讓我們直接透過程式碼來了解什麼是 <code>class</code>，首先 <code>class</code> 會有 <code>constructor</code> 來定義物件的屬性，且可以帶入參數來改變屬性的值，另外方法則可以直接寫在 <code>class</code> 內，而創立物件的用法就和 <code>function constructor</code> 一樣透過關鍵字 <code>new</code> 創立一個新的物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">firstname, lastname</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.firstname = firstname;</span><br><span class="line">    <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hi&#x27;</span> + firstname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   firstname: &#x27;John&#x27;,</span></span><br><span class="line"><span class="comment">//   lastname: &#x27;Doe&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>這裡要注意的是，與其他程式語言不同，<code>class</code> 只是定義物件，它並不是一個物件，JavaScript 中的 <code>class</code> 不僅定義物件，它本身就是一個物件。</p><h2 id="Class-Prototype"><a href="#Class-Prototype" class="headerlink" title="Class Prototype"></a>Class Prototype</h2><p>前面提到 JavaScript 中的 <code>class</code> 也是一個物件，因此它也可以繼承另一個 <code>class</code>，只要透過 <code>extend</code> 指向要繼承的目標 <code>class</code>，並透過 <code>super</code> 傳遞 <code>constructor</code> 的參數 ; 另外我也可以覆蓋掉原有的方法 <code>greet</code> 或屬性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InformalPerson</span> <span class="title">extend</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">firstname, lastname</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(firstname, lastname);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">greet</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Yo &#x27;</span> + firstname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Syntactic-Sugar-語法糖"><a href="#Syntactic-Sugar-語法糖" class="headerlink" title="Syntactic Sugar 語法糖"></a>Syntactic Sugar 語法糖</h2><p>同樣的，如果專案需支援 <code>ES6</code> 以下的環境，我們就需需要撰寫 <code>polyfill</code> 來達到相同的效果，如同上一堂課提到的 <code>Object.create()</code> ; 在 JavaScript 中，<code>class</code> 被稱為一種語法糖 <code>Syntactic Sugar</code>，<code>Syntactic Sugar</code> 指的是在 JavaScript 底層其實是一模一樣的行為，只是我們將它包裝成另一種用法，如 <code>function constructor</code>、<code>Object.create()</code> 和 <code>class</code> 其實都是 prototypal ingeritance。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Object.create and Pure Prototypal Inheritance</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220104/21385/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220104/21385/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>在前一堂課介紹了 JavaScript 模仿其他程式語言透過 <code>class</code> 定義並創造 <code>object</code> 的方式 - <code>function constructor</code>，接下來將介紹一個 JavaScript 獨有且瀏覽器預設就有的創造 <code>object</code> 方式 - <code>Object.create。</code></p><span id="more"></span><p>首先看到一段範例如下:</p><p>我們創造了一個含有屬性與方法的物件 <code>person</code> ，並在方法中取得並回傳屬性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  lastname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span> + <span class="built_in">this</span>.firstname;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但如果方法中指向物件屬性的 <code>this</code> 被忽略了，在方法執行時，因為當前函式的 Execution Context 找不到該變數，便會向外找向 Global execution context，導致因為全域環境沒有這個變數結果出現 error。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  lastname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span> + firstname;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><p>在 JavaScript 中，有一種瀏覽器預設的方式來建立物件，那就是 <code>Object.create()</code>，首先我們同樣先建立一個物件 <code>person</code>，接著透過 <code>Object.create()</code> 建立另一個物件 <code>john</code> ，並把物件 <code>person</code> 作為參數帶入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  lastname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  greet: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span> + firstname;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(john);</span><br></pre></td></tr></table></figure><p>當我們透過 <code>console.log</code> 查看物件 <code>john</code> 時，會發現得到一個空物件，並將 <code>prototype</code> 指向作為參數帶入的物件 <code>person</code>。</p><p><img src="Object-create.png"></p><p>因為新建立物件 <code>john</code> 的 <code>prototype</code> 指向原物件 <code>person</code>，所以我們可以直接在 <code>john</code> 之下使用 <code>person</code> 的屬性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(john.firstname);   <span class="comment">// Default</span></span><br><span class="line">consoel.log(john.greet());     <span class="comment">// Hi Default</span></span><br></pre></td></tr></table></figure><p>如果我們希望自定義 <code>john</code> 的屬性，也可以直接加上去，因為當我們呼叫物件的屬性和方法時，在找不到的情況才會找向 <code>prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john.firstname = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(john.greet());   <span class="comment">// Hi John</span></span><br></pre></td></tr></table></figure><p>透過這種方式建立物件並繼承原物件我們就稱為 Pure Prototypal Inheritance</p><h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h2><p>上述透過 <code>Object.create()</code> 建立物件繼承的方式不僅簡潔易懂，還可以彈性的覆蓋或新增屬性和方法，但如果遇到需要支援舊瀏覽器的專案時，可能會有無法使用 <code>Object.create()</code> 的情況，接下來就讓我們談談一個名詞 - polyfill。</p><p>polyfill: 透過程式碼讓我們新增舊環境下缺少的特性 </p><p>聽起來有點複雜，讓我們直接透過上方的 <code>Object.create()</code> 來了解這個概念 ; 首先判斷這個環境有沒有這個特性，如果有就不用做任何事，沒有的我們就透過程式碼幫它補上原本預期要做到的事 ; 首先確認是否只有傳入一個參數，接著新增一個空函式 <code>F</code> 做為 <code>function constructor</code>，再把它的 <code>prototype</code> 指向傳入的物件 <code>o</code>，並回傳 <code>new F()</code> 來創造一個 <code>prototype</code> 指向 <code>o</code> 的空物件，如此一來就和 <code>Object.create()</code> 達到相同的目的了。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&quot;Object.create implemention only accepts the first parameter.&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>陣列與 for in</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220103/39808/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220103/39808/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹一個很容易誤會的用法，<code>Array</code> &amp; <code>for in</code></p><span id="more"></span><p>還記得在 <a href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211228/40176/" title="reflection and extend">reflection and extend</a> 這堂課中我們透過 <code>for</code> 迴圈將物件的屬性與方法擴充到另一個物件，而在 JavaScript 中，陣列也是物件，所以我們可以透過 <code>for in</code> 的方式取得陣列中的索引與值 <code>name value pair</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">&#x27;: &#x27;</span> + arr[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 John</span></span><br><span class="line"><span class="comment">// 1 Jane</span></span><br><span class="line"><span class="comment">// 2 Jim</span></span><br></pre></td></tr></table></figure><p>在單純透過中括號建立物件 <code>literal array</code> 時，其實也是 <code>new</code> 一個物件，所以它的 <code>prototype</code> 也會指向 <code>Array.prototype</code>，所以如果我們在這上方直接新增屬性或方法，新建立的陣列也會取得，但透過 <code>for in</code> 列出陣列的 <code>name value pair</code> 時，新增在 <code>Array.prototype</code> 的屬性與方法也會被列出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myCustomFeature = <span class="string">&#x27;cool!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">&#x27;: &#x27;</span> + arr[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0: John</span></span><br><span class="line"><span class="comment">// 1: Jane</span></span><br><span class="line"><span class="comment">// 2: Jim</span></span><br><span class="line"><span class="comment">// myCustomFeature: cool!</span></span><br></pre></td></tr></table></figure><p>所以在開發 <code>Array</code> 相關程式時，避免使用 <code>for in</code> 方式遍歷它的內容，使用標準的 <code>for</code> 迴圈即可，就不會出現 <code>prototype</code> 所新增的屬性與方法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++&gt;) &#123;</span><br><span class="line">  <span class="comment">// do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>內建函式建構子</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220103/32940/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220103/32940/</url>
      
        <content type="html"><![CDATA[<p>前一堂課介紹了透過函是來建立物件的函式建構子 <code>Function Constructor</code>，這堂課將進一步介紹”內建”的函式建構子</p><span id="more"></span><h2 id="new-Number"><a href="#new-Number" class="headerlink" title="new Number()"></a>new Number()</h2><p>直接看到一段範例如下:</p><p>透過內建的函式 <code>Number</code> 來建立一個物件，內建的 <code>Function Constructor</code> 也有按照大寫開頭的慣例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>當我們透過瀏覽器的 <code>console</code> 查看 <code>a</code> 的值時，它不是一個數字 <code>number</code>，還記得前面提到 <code>function constructor</code> 會建立的會是一個物件，所以得到的 <code>a</code> 會是一個包含數字 <code>3</code> 的 <code>object</code>。</p><p><img src="Number.png"></p><p>透過這些內建的 <code>function constructor</code> 所建立的物件會有一些內建的 <code>method</code> 可以使用，只要在瀏覽器的 <code>console</code> 中透過 <code>Number.prototype</code> 就可以查看</p><p><img src="Number-prototype.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.toString();   <span class="comment">// &#x27;3&#x27;</span></span><br></pre></td></tr></table></figure><p>不透過關鍵字 <code>new</code> 我們也可以單純使用 <code>Number()</code> 來將 <code>String</code> 轉為 <code>Number</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="new-String"><a href="#new-String" class="headerlink" title="new String()"></a>new String()</h2><p>接著看到第二個範例:</p><p>我們透過 <code>String</code> 來建立一個新的物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;John&#x27;</span>);</span><br></pre></td></tr></table></figure><p>透過 <code>function constructor</code> 所建立的 <code>object</code> 同樣會有一些預設的 <code>method</code>，同樣可以透過 <code>String.prototype</code> 來查看，但如果直接這麼使用會發現結果不如預期</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.indexOf(<span class="string">&#x27;o&#x27;</span>);   <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">String</span>.prototype.indexOf(<span class="string">&#x27;Jo&#x27;</span>);   <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">a.indexOf(<span class="string">&#x27;o&#x27;</span>);   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>總結以上兩個範例，不管使用的 <code>function constructor</code> 是哪一種，所建立的只是長得像原始型別 <code>primitive</code> 的 <code>object</code>，並提供許多預設的 <code>method</code> 供我們使用。</p><p>另外有一點很重要的是，我們在開發時常透過 <code>.length</code> 來取得字串的長度，但仔細想想，字串 <code>String</code> 是原始型別 <code>primitive</code>，並不是 <code>object</code>，所以並不會有 <code>property</code> 和 <code>method</code>，但當我們對 <code>primitive</code> 的值這麼做時，<code>JavaScript</code> 會自動幫你的值進行物件般的處理，如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;John&#x27;</span>.length);   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="為內建的-Function-Constructor-新增屬性和方法"><a href="#為內建的-Function-Constructor-新增屬性和方法" class="headerlink" title="為內建的 Function Constructor 新增屬性和方法"></a>為內建的 Function Constructor 新增屬性和方法</h2><p>當我們透過內建的 <code>function constructor</code> 建立物件時，會有許多預設的屬性和方法供我們使用，但在 <code>JavaScript</code> 中能做的不僅如此，我們還可以在這些內建的 <code>function constructor</code> 上新增屬性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.isLengthGreaterThan = <span class="function"><span class="keyword">function</span>(<span class="params">limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.length &gt; limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;John&#x27;</span>.isLengthGreaterThan(<span class="number">3</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面的範例中，我們在 <code>String.prototype</code> 上新增一個方法 <code>isLengthGreaterThan</code>，其函式中的 <code>this</code> 就是新建立的物件，而這裡則是 <code>John</code> 這個字串被當作物件般處理，結果是 <code>4 &gt; 3</code>，所以回傳 <code>true</code>。</p><h2 id="自動將原始型別轉為物件處理"><a href="#自動將原始型別轉為物件處理" class="headerlink" title="自動將原始型別轉為物件處理"></a>自動將原始型別轉為物件處理</h2><p>那麼如果我們對數字 <code>number</code> 也這麼做會得到什麼呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.isPositive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span> &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="Number-prototype-method.png"></p><p>結果會得到 <code>error</code>，因為 <code>JavaScript</code> 只會將字串 <code>String</code> 自動轉為物件般處理，所以如果是其他原始型別，只能透過 <code>function constructor</code> 建立物件才能為它擴充屬性與方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">a.isPositive();   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="避免都使用-Function-Constructor-建立原始值"><a href="#避免都使用-Function-Constructor-建立原始值" class="headerlink" title="避免都使用 Function Constructor 建立原始值"></a>避免都使用 Function Constructor 建立原始值</h2><p>即便以上透過 <code>function constructor</code> 來建立原始值的物件看似方便好用，但在開發時，除非你很清楚這麼做的目的，否則都建議直接使用原始型別來建立，讓我們透過一段範例來了解為什麼要這麼做。</p><p>首先，分別使用 <code>primitive</code> 和 <code>function constructor</code> 來建立數字 <code>3</code>，當我們透過雙等號 <code>==</code> 比較時，會得到 <code>true</code>，因為透過 <code>==</code> 比較時，<code>JavaScript</code> 會發現等號兩側不同型別，因此會幫我們自動轉型，所以得到 <code>true</code> 的結果，反之三等號 <code>===</code> 不會自動轉型，所以得到 <code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>所以在開發時，使用 <code>function constructor</code> 必須有很明確的目的，否則盡量單純使用 <code>primitive</code> 建立原始值即可</p><h2 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h2><p>這裡介紹一個處理 <code>Date</code> 很有名的 <code>Library</code> - <a href="https://momentjs.com/">Moment.js</a>，它就是透過 <code>Date</code> 這個 <code>function constructor</code> 提供許多關於日期的方法。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>function-constructors-and-prototype</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220102/42224/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20220102/42224/</url>
      
        <content type="html"><![CDATA[<p>前一堂課介紹了如何透過關鍵字 <code>new</code> 來建立物件，這堂課將進一步介紹 <code>function construsctors</code> 和 <code>.prototype</code></p><span id="more"></span><h2 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h2><p>延續上一堂課的範例，如果透過 <code>new</code> 關鍵字來建立的物件，並使用 <code>__proto__</code> 來查看它的 <code>prototype</code> 會是什麼呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.firstname = firstname;</span><br><span class="line">  <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;This function is invoked.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john.__proto__);</span><br></pre></td></tr></table></figure><p>我們會得到一個名為 <code>Person</code> 的空物件</p><p><img src="proto.png"></p><p>但這到底是如何形成的呢 ?</p><p>之前的課程有提到過，在一個函式被件建立時，它會有幾個預設的屬性，函式內的程式碼 - <code>code</code>、匿名函式不會有的 - <code>name</code> 和一個只被用來產生物件的 <code>function constructor</code> 才會有的屬性 - <code>prototype</code></p><p><img src="function.png"></p><p>但這裡很弔詭的是，函式的 <code>prototype</code> 屬性並不是這個函式的 <code>prototype</code>，而是透過 <code>new</code> 建立的物件的 <code>__proto__</code> 會自動指向這個函式的 <code>prototype</code> 屬性，這裡我們透過一個範例來了解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.firstname = firstname;</span><br><span class="line">  <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john);</span><br><span class="line"><span class="built_in">console</span>.log(john.getFullName());   <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure><p>這裡我們將一個函式 <code>getFullName</code> 指派給 <code>Person.prototype</code>，接著呼叫 <code>john.getFUllName()</code> 時，因為 <code>john</code> 本身並沒有這個方法，因此會沿著 <code>prototypal chain</code> 尋找，這時會找到 <code>Person.prototype</code>，所以我們會得到 <code>return</code> 的結果。</p><p>那麼我們是不是也可以將這麼方法直接在函式 <code>Person</code> 建立時就賦予給它呢 ?</p><p>當然可以，因為透過 <code>new</code> 來建立物件時會呼叫這個函式，並將 <code>this</code> 指向新的空物件，就和屬性一樣，方法也會出現在新建立的物件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.firstname = firstname;</span><br><span class="line">  <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line">  <span class="built_in">this</span>.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john.getFullName());   <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure><h2 id="記憶體占用"><a href="#記憶體占用" class="headerlink" title="記憶體占用"></a>記憶體占用</h2><p>但這裡不一樣的是，如果把方法 <code>getFullName</code> 在函式建立時就賦予給它，每當我們透過 <code>new</code> 建立一個物件時，這些物件都會有自己的 <code>getFullName</code> 方法，所以自然會有各自占用的記憶體空間 ; 但如果透過 <code>Person.prototype</code> 賦予時，在呼叫物件的方法時，因為找不到，所以會沿著 <code>prototypal chain</code> 找到賦予在函式 <code>prototype</code> 的方法，藉此減少相同方法占用記憶體空間。</p><h2 id="後續新增方法"><a href="#後續新增方法" class="headerlink" title="後續新增方法"></a>後續新增方法</h2><p>透過函式的 <code>prototype</code> 新增方法的方式甚至可以在物件被建立後追加，不需要因為後續新增方法而去修改先前建立的物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.firstname = firstname;</span><br><span class="line">  <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line">  <span class="built_in">this</span>.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john.getFullName());   <span class="comment">// John Doe</span></span><br><span class="line"></span><br><span class="line">Person.prototype.getFormalFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.lastname + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.firstname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(john.getFormalFullName());   <span class="comment">// Doe, John</span></span><br></pre></td></tr></table></figure><h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h2><p>在 <code>JavaScript</code> 透過 <code>function constructor</code> 的方式建立物件時，我們需要在呼叫函式前加上一個關鍵字 <code>new</code>，但如果我們漏掉關鍵字 <code>new</code>，整個程式碼還是可以執行的，只是這個變數會被賦予函式 <code>return</code> 的值，如果沒有回傳任何資料，這個值就會是 <code>undefined</code>，因為這也是一般呼叫函式的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">this</span>.firstname = firstname;</span><br><span class="line">  <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;This function is invoked.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = Person(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(john.getFullName()):   <span class="comment">// error... </span></span><br></pre></td></tr></table></figure><p>為了盡量避免發生這種錯誤，所以在開發時通常會一個慣例，那就是如果這個函式是一個 <code>function constructor</code>，那命名上就會使用大寫開頭 <code>capital letter</code> (person –&gt; Person)，藉此提醒我們在透過這類函式建立物件時，記得加上關鍵字 <code>new</code>。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函數建構子、new 與 JavaScript 的歷史</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211229/60572/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211229/60572/</url>
      
        <content type="html"><![CDATA[<p>在過去的章節介紹過物件最基本的建立方式 - literal object，這堂課將透過 JavaScript 的歷史來介紹物件的其他建立方式。</p><span id="more"></span><p>JavaScript 在創立初期，作者為了吸引 Java 的開發者使用它，所以在命名上便參考 Java 這個字，但在開發上其實有非常大的不同 ; 其中 <code>new</code> 這個關鍵字便是模仿 Java 而來，但在 Java 中，<code>new</code> 是用來建立一個 <code>class</code>，<code>class</code> 並非 <code>object</code>，而是用來定義並建立 <code>object</code> ; 然而在 JavaScript 中，<code>new</code> 則是被用來建立 <code>object</code>，這也是本堂課將介紹的用法 ; JavaScript 在 ES6 後的本版也有 <code>class</code> 這個關鍵字，但用法則和 <code>Java</code> 完全不同。</p><h2 id="new-object"><a href="#new-object" class="headerlink" title="new object"></a>new object</h2><p>前面提到，JavaScript 中的關鍵字 <code>new</code> 和 <code>Java</code> 中的用法並不一樣，那麼當我們透過 <code>new</code> 來建立物件的時候到底會發生什麼事呢 ?</p><p>讓我們透過一段程式碼範例來了解:</p><p>首先，建立一個函式 <code>person</code>，接著透過 <code>new</code> 來呼叫這個函式並指派給一個變數 <code> john</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.firstname = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.lastname = <span class="string">&#x27;Doe&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;This function is invoked.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(john);</span><br></pre></td></tr></table></figure><p>讓我們依序拆解這段程式碼，首先，呼叫函式 <code>Person()</code> 其實就和一般呼叫函式相同，會直接執行函式內的程式碼，如果沒有特別 <code>return</code>，就會回傳 <code>undefined</code>，接著前面的關鍵字 <code>new</code> 會建立一個空物件 <code>&#123;&#125;</code>，並將函式的 <code>this</code> 指向這個物件，所以當我們透過 <code>console.log</code> 查看 <code>john</code> 時，會得到一個含有兩個屬性 <code>firstname</code> 和 <code>lastname</code> 的物件。</p><p><img src="new-object.png"></p><p>那麼如果再透過 <code>new</code> 函式來建立第二個物件呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(jane);</span><br></pre></td></tr></table></figure><p>會和第一個物件 <code>john</code> 得到一個含有兩個屬性的物件。</p><p><img src="new-two-object.png"></p><p>但如果我們希望透過 <code>new</code> 來建立的物件能自由地賦予它屬性的值該怎麼做呢 ?</p><p>前面提到，這種建立物件的方式其實會先呼叫這個函式，再將它的 <code>this</code> 指向一個新產生的空物件，所以就如同一般函式，我們可以傳入參數，並指派給它的屬性，這麼一來就可以達到自由賦予屬性值的目的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstname, lastnmae</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.firstname = firstname;</span><br><span class="line">  <span class="built_in">this</span>.lastname = lastname;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(john);   <span class="comment">// &#123;firstname: &#x27;John&#x27;, lastname: &#x27;Doe&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Person(<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jane);   <span class="comment">// &#123;firstname: &#x27;Jane&#x27;, lastname: &#x27;Doe&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>這種被用來透過關鍵字 <code>new</code> 來建立物件並回傳將 <code>this</code> 指派給新生成空物件的函式就稱為 Function Constructors。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Reflection and Extend</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211228/40176/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211228/40176/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>這堂課將來介紹一個在很多 Libaries 會使用到的觀念 - Extend，而 Extend 又因為 Reflection 而成立，讓我們來了解一下這兩個名詞吧。</p><span id="more"></span><p>首先，來了解一下 Reflection 這個名詞，Reflection 指的是物件可以取得並更改自己的屬性 <code>properties</code> 和方法 <code>method</code>。</p><p>延續上次堂課的範例，我們建立兩個物件 <code>person</code> 和 <code>john</code>，並將 <code>john</code> 的 <code>prototype</code> 指向 <code>person</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  lastname: <span class="string">&quot;Default&quot;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstname + <span class="string">&quot; &quot;</span> + lastname;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = &#123;</span><br><span class="line">  firstname: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastname: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don&#x27;t do this EVER! for demo purposes only !!</span></span><br><span class="line">john.__proto__ = person;</span><br></pre></td></tr></table></figure><h2 id="for-in-基本應用"><a href="#for-in-基本應用" class="headerlink" title="for in 基本應用"></a>for in 基本應用</h2><p>接著透過 <code>for...in</code> 列出物件 <code>person</code> 中的所有 <code>properties</code> 與 <code>method</code>，也就是每個 <code>for</code> 迴圈的變數 <code>prop</code>，結果會發現連 <code>prototype</code> 的方法 <code>getFullName</code> 也被囊括進去了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> john) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">&quot;: &quot;</span> + john[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// firstname: John</span></span><br><span class="line"><span class="comment">// lastname: Doe</span></span><br><span class="line"><span class="comment">// getFullName: function() &#123;</span></span><br><span class="line"><span class="comment">//   return firstname + &#x27; &#x27; + lastname;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h2 id="判斷屬性是否為繼承-hasOwnProperty"><a href="#判斷屬性是否為繼承-hasOwnProperty" class="headerlink" title="判斷屬性是否為繼承 hasOwnProperty"></a>判斷屬性是否為繼承 hasOwnProperty</h2><p>那麼如果我們只希望取得該物件本身的 <code>properties</code> 該怎麼辦呢 ?</p><p>這時候便可以透過 <code>prototypal chain</code> 概念取得 <code>base object</code> 的方法 <code>hasOwnProperty</code> 來判斷該 <code>property</code> 是否來自於物件本身，是的話回傳 <code>true</code>，反之則回傳 <code>false</code>，因此我們就可以透過這個方法來篩選了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> john) &#123;</span><br><span class="line">  <span class="keyword">if</span> (john.hasOwnPorperty(prop)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prop + <span class="string">&quot;: &quot;</span> + john[prop]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// firstname: John</span></span><br><span class="line"><span class="comment">// lastname: Doe</span></span><br></pre></td></tr></table></figure><h2 id="underscore-js-extend"><a href="#underscore-js-extend" class="headerlink" title="underscore.js extend()"></a>underscore.js extend()</h2><p>接下來我們將透過 underscore.js 這個 libaries 的 source code 進一步了解 extend 的觀念。</p><p>讓我們來看一下透過 underscore.js 中的 <code>extend()</code> 可以做到什麼 ; 在載入 <code>underscrore.js</code> 的程式碼後，我們可透過下底線 <code>_</code> 來使用其中所有 API，在 <code>extned()</code> 這個 API 中，第一個參數是我們要擴充的物件，後續的參數則是擴充的來源，所以透過 <code>_.extend(john, jane, jim)</code> 便可讓 <code>john</code> 得到 <code>jane</code> 和 <code>jim</code> 的所有 properties。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john = &#123;</span><br><span class="line">  firstname: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastname: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jane = &#123;</span><br><span class="line">  address: <span class="string">&#x27;111 Main St.&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jim = &#123;</span><br><span class="line">  getFirstName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.extend(john, jane, jim);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(john);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   firstname: &quot;John&quot;,</span></span><br><span class="line"><span class="comment">//   lastname: &quot;Doe&quot;,</span></span><br><span class="line"><span class="comment">//   address: &#x27;111 Main St.&#x27;,</span></span><br><span class="line"><span class="comment">//     getFirstName: function() &#123;</span></span><br><span class="line"><span class="comment">//     return firstname;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><p>接下來讓我們到 <a href="https://github.com/jashkenas/underscore/blob/master/underscore.js">underscore.js extend source code</a> 中，依序解析它的程式碼來了解它是如何辦到的。</p><p>首先，我們可以看到 extend 這個 API 來自於 <code>createAssigner</code> 這個函式，透過回傳一個函式這裡便形成一個 closures，以下依序為各個名詞的含意:</p><ul><li><code>obj</code> : 要擴充的物件 <code>john</code></li><li><code>keysFunc</code> : 取得物件中所有 <code>key</code> 的方法</li><li><code>length</code> : 傳入的物件數，如果只傳一個物件 <code>john</code> 則代表不擴充 <code>length &lt; 2</code>，因此直接回傳</li><li>第 1 個 <code>for</code>: 從 <code>jane</code> 物件開始遍歷</li><li><code>keys</code> : 擴充來源物件 <code>jane</code> 和 <code>jim</code> 的所有 <code>key</code> </li><li><code>l</code> : 擴充來源物件 <code>jane</code> 和 <code>jim</code> 的所有 <code>key</code> 的數量</li><li>第 2 個 <code>for</code>: 將擴充來源物件所有屬性指派給要擴充的物件 <code>john</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extend a given object with all the properties in passed-in object(s).</span></span><br><span class="line"><span class="keyword">var</span> extend = createAssigner(allKeys);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAssigner</span>(<span class="params">keysFunc, defaults</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">if</span> (defaults) obj = <span class="built_in">Object</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span> || obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="built_in">arguments</span>[index],</span><br><span class="line">        keys = keysFunc(source),</span><br><span class="line">        l = keys.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = keys[i];</span><br><span class="line">        <span class="keyword">if</span> (!defaults || obj[key] === <span class="keyword">void</span> <span class="number">0</span>) obj[key] = source[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是透過解析 underscore.js 來了解 extend 概念，讓我們透過原型鍊 prototypal chain 的方式就可以擴充物件的屬性 ; 其實多閱讀這些知名 Library 的 source code 可以增進我們的程式撰寫技巧，讓我們用更聰明、簡潔的方式達到一樣的目的。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>所有東西都是物件或純值</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211228/29342/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211228/29342/</url>
      
        <content type="html"><![CDATA[<p>前一堂課了解到 <code>JavaScript</code> 中的 <code>Prototypal Chain</code> 後，這堂課將進一步探討物件中的 <code>prototype</code>。</p><span id="more"></span><p>在 <code>JavaScript</code> 中，所有物件都有 <code>prototype</code>，除了最基礎物件 <code>base object</code>。</p><p>那到底什麼是 <code>base object</code> 呢 ?</p><p>首先，我們透過 <code>console</code> 來看到每一種物件的 <code>prototype</code>，分別是物件 <code>object</code>、函式 <code>function</code> 與陣列 <code>array</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;              <span class="comment">// object</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;   <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> c = [];              <span class="comment">// array</span></span><br></pre></td></tr></table></figure><p>透過 <code>a.__proto__</code> 我們可以看到物件的 <code>prototype</code> 也是一個物件，打開它會發現已經有許多預設的 <code>method</code>，包含我們在開發時常用到的 <code>toString</code>、<code>valueOf</code> 等等，從這裡就可以得知為什麼每當我們創造一個物件時就會有這些 <code>method</code> 可以使用，因為我們透過自己宣告的物件來使用這些 <code>method</code> 時，會發現自己身上找不到，便會透過 <code>prototypal chain</code> 的概念往 <code>prototype</code> 找到這個物件，所以我們宣告的物件就有這些 <code>method</code> 了。</p><p><img src="object-prototype.png"></p><p>接著來看到 <code>function</code>，我們一樣透過 <code>b.__proto__</code> 來看 <code>function</code> 的 <code>prototype</code>，會得到一個空的函式，進一步在後方加上一個點 <code>dot operator</code> 查看它 <code>method</code>，會發現出現許多 <code>method</code> ，其中包含前幾堂課中學過的 <code>call</code>、<code>bind</code> 和 <code>apply</code>，同理這也就是我們在建立函式後會有這些 <code>method</code> 可以使用的原因了。</p><p><img src="function-prototype.png"></p><p>最後透過 <code>c.__proto__</code> 看到 <code>array</code> 的 <code>prototype</code>，同樣會有許多預設的 <code>method</code> 供我們使用。</p><p><img src="array-prototype.png"></p><p>那麼回到最一開始的問題，什麼是最基礎物件 <code>base object</code> 呢 ?</p><p>其實就是一般物件 (前面範例的 a) 的 <code>prototype</code> 了，前面提到，所有物件都有 <code>prototype</code>，除了這個 <code>base object</code> 除外，所以當我們不斷透過 <code>.__proto__</code> 指向物件的 <code>prototype</code> 直到指向這個 <code>base object</code>，它就會出現 <code>null</code> ，包含函式 <code>function</code> 和陣列 <code>array</code> 的 <code>prototype</code> 最後也會指向 <code>base object</code>，所以我們才會說所有物件除了 <code>base object</code> 都有 <code>prototype</code>。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>古典與原型繼承</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211226/8192/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211226/8192/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹 JavaScript 中，和其他程式語言很不一樣的觀念，物件導向 (Object-Oriented) 與原型繼承 (Prototypal Inheritance)</p><span id="more"></span><h2 id="Classical-Inheritance-v-s-Prototypal-Inheritance"><a href="#Classical-Inheritance-v-s-Prototypal-Inheritance" class="headerlink" title="Classical Inheritance v.s Prototypal Inheritance"></a>Classical Inheritance v.s Prototypal Inheritance</h2><p>首先，我們先來了解一下什麼是繼承 (Inheritance)，其實就是一個物件取得另一個物件的屬性 <code>properties</code> 和方法 <code>method</code>。</p><p>而繼承又分為兩種，一種是 Classical Inheritance，其他程式語言如 C#、Java 所使用的物件繼承方式 ; 另一種則是 JavaScript 所使用的繼承方式，Prototypal Inheritance。</p><h2 id="Prototype-Chain-原型鍊"><a href="#Prototype-Chain-原型鍊" class="headerlink" title="Prototype Chain 原型鍊"></a>Prototype Chain 原型鍊</h2><p>延續前面的說法， JavaScript 是一個透過 Prototypal Inheritance 來讓物件取得另一個物件的屬性 <code>properties</code> 或方法 <code>method</code>，先來讓我們看一下底下這張圖:</p><p><img src="prototype-chain.png"></p><p>首先在記憶體中有一個叫做 <code>obj</code> 的物件，如果它底下有一個名為 <code>prop1</code> 的屬性，我們可以透過點 . (dot operator) 來取得這個物件屬性 <code>obj.prop1</code>。</p><p>在前面 <code>call()、bind() and apply()</code> 的課程中，我們知道物件在被建立時，會有一些預設的屬性和方法，所有物件 (包括函式) 都會有一個 <code>prototype</code> 屬性，這裡我們先稱它為 <code>proto</code>，接著，當我們要找一個名為 <code>prop2</code> 的屬性時，在 <code>obj</code> 身上找不到，便會向 <code>proto</code> 去找，如果找到了，一樣可以透過點 . (dot operator) 來指向它 <code>obj.prop2</code>，而不須使用 <code>obj.proto.prop2</code> 來使用它。</p><p>然而，如果找不到就會繼續向 <code>proto</code> 的 <code>prototype</code> 找下去，前面提到，每個物件都有 <code>prototype</code>，而 <code>obj</code> 的 <code>proto</code> 也不例外，所以當我們輸入 <code>obj.prop3</code> 時，在 <code>obj</code> 與 <code>proto</code> 都找不到便會向 <code>proto</code> 的 <code>prototype</code> 找下去，並回傳 <code>obj.proto.proto.prop3</code> 給我們。</p><p>在物件上尋找屬性找不到便向 <code>prototype</code> 查詢的形式便會形成一個原型鍊 <code>Prototype Chain</code>，那麼一直找下去會到什麼時候呢 ? 會一直指向原型直到返回 <code>null</code> 為止。</p><p><img src="share-prototype-chain.png"></p><p>接著我們看到第二張圖，物件的 <code>prototype</code> 其實是可以分享給其他物件的，如圖中的第二個物件 <code>obj2</code>，它將 <code>prototype</code> 同樣指向 <code>obj</code> 的 <code>proto</code>，所以當我們輸入 <code>obj2.prop2</code> 時，其實會和 <code>obj.porp2</code> 同樣指向記憶體中相同的位置。</p><p>我們其實不用把這個觀念想得太複雜，當我們呼叫物件的屬性時，如果找不到便會向它的 <code>prototype</code> 尋找，找到了同樣可以把它當作物件的屬性來呼叫。</p><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>讓我們透過範例進一步了解這個概念，這個範例其實不會在一般的開發中這麼使用，因為現代瀏覽器提供了其他方式來使用它，如果按照範例使用，還會造成開發應用程式的效能問題。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;Default&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Default&#x27;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + lastname;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次強調不要在實際開發上這麼使用，這只是為了方便了解原型鍊 <code>Prototypal Chain</code> 的概念而已。<br>首先，為了讓新建立的物件 <code>john</code> 使用到 <code>person</code> 的方法 <code>getFullName</code>，我們要將 <code>john</code> 的 <code>prototype</code> 指向 <code>person</code>，在 JavaScript 我們可以透過兩個下底線 <code>_</code> 包住 proto <code>__proto__</code> 來指定，這麼一來輸入 <code>john.getFullName()</code> 時因為找不到，就會沿著 <code>Prototypal Chain</code> 找到 <code>person</code> 的 <code>getFullName</code> 方法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// don&#x27;t do this EVER! for demo purpose only !!! </span></span><br><span class="line"></span><br><span class="line">john.__proto__ = person;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(john.getFullName());   <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure><p>那麼如果在這之後單純呼叫物件 <code>john</code> 的屬性呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(john.firstname);   <span class="comment">// John</span></span><br></pre></td></tr></table></figure><p>會發現結果還是物件 <code>john</code> 自己的屬性而不是 <code>person</code> 的 <code>Default</code>，因為原型鍊的概念是，我在物件本身找不到時，才會沿著 <code>prototype</code> 往上尋找。</p><p>接著我們來看到另一個範例，首先，建立一個只有 <code>firstname</code> 屬性的物件 <code>jane</code>，同樣地，我們將它的 <code>portotype</code> 指向 <code>person</code>，所以當它呼叫 <code>getFullName</code> 方法時，因為物件本身沒有，自然就會往 <code>protype</code> 物件 <code>person</code> 尋找 ; 但是該物件並沒有 <code>lastname</code> 屬性，所以延續前面提到的，當物件沒有對應的屬性和方法時，就會往 <code>prototype</code> 尋找，結果就會是 <code>person.lastname</code> 的 <code>Default</code> 了。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jane = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;jane&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jane.__proto__ = person;</span><br><span class="line"></span><br><span class="line">jane.getFullName();   <span class="comment">// Jane Default</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Functional Programming</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211223/51899/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211223/51899/</url>
      
        <content type="html"><![CDATA[<p>有了之前對於 First Class Function 的了解後，這堂課將介紹 JavaScript 程式設計很強大的地方 - Functional Programming</p><span id="more"></span><p>在 JavaScript 有一個很特別的地方在於函式屬於物件，所以可以透過匿名函式 (Anonymous Function) 的方式指派一個變數，並透過 <code>return</code> 回傳一個值，這種方法就稱為 First Class Function，這是在其他程式語言中不太會見到的。</p><p>首先看到一段程式碼如下:</p><p>建立一個陣列，接著建立第二個空陣列，並透過 <code>for</code> 迴圈 <code>push</code> 2 倍的值進入第二個空陣列，如此一來就可以得到和第一個陣列長度相同且兩倍的值。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2.</span> <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">  arr2.push(arr1[i] * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2);   <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>但身為一個程式開發人員，我們總是想要透過最少的程式碼來達到相同的目的，且避免重複撰寫類似的程式碼，所以我們試著透過 Functional Programming 的概念來改寫這段程式碼。</p><p>首先，建立一個函式，並將這個 <code>for</code> 迴圈放入函式內，接著將第一個陣列作為第一個參數傳入，再將要對陣列做的 Callback Function 做為第二個參數傳入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapForEach</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    newArr.push(</span><br><span class="line">      fn(arr[i]);</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>為了達到和原先一樣把陣列的所有值乘上 2 的目的，只要透過呼叫 <code>mapForEach</code> 這個函式，並將要處理的陣列帶入第一個參數，接著把要處理的條件透過 <code>function expressions</code> 帶入第二個參數:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = mapForEach(arr1, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2);   <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h2 id="Functional-Programming-不同應用"><a href="#Functional-Programming-不同應用" class="headerlink" title="Functional Programming 不同應用"></a>Functional Programming 不同應用</h2><p>透過 <code>Functional Programming</code> 的方式，我們可以輕易地對 <code>array</code> 做到不同的處理 ; 如上，第一個範例是將所有值乘上 <code>2</code>，如果要判斷 <code>array</code> 中的值是否大於 <code>2</code>，也可以透過呼叫 <code>mapForEach</code> 做到:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = mapForEach(arr1, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3);   <span class="comment">// [false, false, true]</span></span><br></pre></td></tr></table></figure><p>如此一來就可以透過 <code>mapForEach</code> 中的第 2 個 <code>function</code> 參數對 <code>array</code> 做到不一樣的效果。</p><h2 id="Function-Programming-進階用法"><a href="#Function-Programming-進階用法" class="headerlink" title="Function Programming 進階用法"></a>Function Programming 進階用法</h2><p>延續上方的範例，我們來看到一個更進階的用法，如果連判斷是否大於 <code>2</code> 的條件都可以彈性透過參數帶入我們可以怎麼做呢 ?</p><p>首先建立一個函式來判斷傳入的參數 <code>item</code> 是否大於條件 <code>limiter</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapForEach</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    newArr.push(</span><br><span class="line">      fn(arr[i])</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> checkPastLimit = <span class="function"><span class="keyword">function</span>(<span class="params">limiter, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; limiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寫到這裡，會有一個疑問是，<code>mapForEach</code> 在呼叫這個函式的時候，只有帶入一個參數 <code>fn(arr[i])</code>，那麼要如何給定 <code>limiter</code> 一個預設值呢 ?</p><p>在這裡就可以用到前面章節所學到的 <code>bind()</code> 來帶入預設的參數了，只要在使用 <code>bind()</code> 的時候，預先帶入一個參數，這個參數就會是 <code>limiter</code> 的值，接著後續呼叫所帶入的值自然就會是 <code>item</code> 了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr4 = mapForEach(arr1, checkPastLimit.bind(<span class="built_in">this</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br><span class="line"><span class="comment">// [false, true, true]</span></span><br><span class="line"><span class="comment">// (1 &gt; 1, 2 &gt; 1, 3 &gt; 1)</span></span><br></pre></td></tr></table></figure><h2 id="簡化-checkPastLimit-到只帶入一個參數"><a href="#簡化-checkPastLimit-到只帶入一個參數" class="headerlink" title="簡化 checkPastLimit 到只帶入一個參數"></a>簡化 checkPastLimit 到只帶入一個參數</h2><p>接著，我們進一步來簡化上述範例，讓這個函式在使用時，不用每次都透過 <code>bind()</code> 來帶入 <code>this</code> 與參數，而是只要透過帶入一個參數作為 <code>limiter</code> 即可。</p><p>在這裡，我們要做的其實就只是將 <code>bind()</code> 的應用包裝成另一個函式，並給定一個參數 <code>limiter</code> 帶入:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> checkPastLimitSimplified = <span class="function"><span class="keyword">function</span>(<span class="params">limiter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">limiter, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; limiter;</span><br><span class="line">  &#125;.bind(<span class="built_in">this</span>, limiter);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> arr5 = mapForEach(arr1, checkPastLimitSimplified(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr5);   <span class="comment">// [false, true, true]</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>call、bind and apply</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211221/22545/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211221/22545/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹 3 個很令 JavaSCript 初學者困擾的內建函式 <code>call()</code>、<code>apply()</code> 和 <code>bind()</code></p><span id="more"></span><p>複習一下之前學過的觀念，在執行一個 <code>funciton</code> 時，會產生一個 Execution Context，並自動生成 Variable Environment、Outer Environment 和關鍵字 <code>this</code>。</p><p><img src="Function-Execution-Context.png"></p><p>另外，函式被建立時還會有以下特性</p><ul><li>屬性 <code>property</code><ul><li>NAME: 如果是 <code>Anonymous Function</code> 就不會有</li><li>CODE: 在函式中可被呼叫執行的程式碼</li></ul></li><li>方法 <code>method</code><ul><li>3 個內建函式: <code>call()</code>、<code>apply()</code> 和 <code>bind()</code></li></ul></li></ul><p><img src="Function.png"></p><h2 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h2><p>接著來看一段範例程式碼如下:</p><p>首先，我們建立一個 object，包含一些 property，並透過 method 回傳自己的 property</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fallName = <span class="built_in">this</span>.firstname + <span class="built_in">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullName;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">log1, log2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Logged: &#x27;</span> + <span class="built_in">this</span>.getFullName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logName();</span><br></pre></td></tr></table></figure><p>結果當然會出現 error，因為函式 <code>logName</code> 中的 <code>this</code> 會指向 <code>window</code>，而 <code>window</code> 並不是物件 <code>person</code>，所以沒有 <code>getFullName</code> 這個 <code>method</code></p><p><img src="error-log.png"></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>那麼如果我們要讓 <code>logName</code> 函式指向物件 <code>person</code>，這時候就可以使用到 <code>bind()</code>，但這裡要注意的是， <code>bind</code> 前的函式 <code>logName</code> 不能加上括號 <code>()</code> 呼叫它，否則就會直接 <code>return</code> 結果了，我們要的只是這個函式 ; 接著 <code>bind</code> 中的參數放入 <code>person</code>，這麼一來在執行新的函式 <code>logPersonName</code> 時，其實就是執行 <code>logName</code>，只是其中的 <code>this</code> 會指物件 <code>person</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fallName = <span class="built_in">this</span>.firstname + <span class="built_in">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullName;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">log1, log2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Logged: &#x27;</span> + <span class="built_in">this</span>.getFullName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logPersonName = logName.bind(person);</span><br><span class="line"></span><br><span class="line">logPersonName();   <span class="comment">// Logged: John Doe</span></span><br></pre></td></tr></table></figure><p>然而，我們其實還可以直接在建立函式 (creates a function on the fly) 時，就透過 <code>bind()</code> 來把 <code>this</code> 指向目標物件，並回傳一個 <code>function</code>，直接呼叫這個 <code>function </code> 就會得到和剛才一樣的結果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fallName = <span class="built_in">this</span>.firstname + <span class="built_in">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullName;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">log1, log2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Logged: &#x27;</span> + <span class="built_in">this</span>.getFullName());</span><br><span class="line"></span><br><span class="line">&#125;.bind(person);</span><br><span class="line"></span><br><span class="line">logName();   <span class="comment">// Logged: John Doe</span></span><br></pre></td></tr></table></figure><p>如剛才所說，新建立的函式 <code>logPerson</code> 其實就是執行 <code>logName</code> 函式，所以帶入的參數也會帶入函式 <code>logName</code> 中。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fallName = <span class="built_in">this</span>.firstname + <span class="built_in">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullName;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">lang1, lang2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Arguments: &#x27;</span>, lang1, lang2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logPersonName = logName.bind(person);</span><br><span class="line"></span><br><span class="line">logPersonName(<span class="string">&#x27;en&#x27;</span>);   <span class="comment">// Arguments: en undefined</span></span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>接下來看看透過 <code>call()</code> 我們可以怎麼做。</p><p>首先，<code>call()</code> 其實和括號 <code>()</code> 一樣會執行這個 <code>function</code>，但不一樣的是，第一個參數是指向的 <code>this</code>，後續才是帶入的參數。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fallName = <span class="built_in">this</span>.firstname + <span class="built_in">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullName;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">lang1, lang2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Logged: &#x27;</span> + <span class="built_in">this</span>.getFullName());</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Arguments: &#x27;</span>, lang1, lang2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logName.call(person, <span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;es&#x27;</span>);</span><br><span class="line"><span class="comment">// Logged: John Doe</span></span><br><span class="line"><span class="comment">// Arguments: en es</span></span><br></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>而 <code>apply()</code> 的用法就和 <code>call()</code> 就很像了，不同的是，第二個參數是一個 <code>array</code>，<code>array</code> 中的值就是依序帶入的參數了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logName.apply(person, [<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;es&#x27;</span>]);</span><br><span class="line"><span class="comment">// Logged: John Doe</span></span><br><span class="line"><span class="comment">// Arguments: en es</span></span><br></pre></td></tr></table></figure><p>而我們也可以透過 <code>IIFE</code> 的方式建立函式 creates a function on the fly</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">lang1, lang2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Logged: &#x27;</span> + <span class="built_in">this</span>.getFullName());</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Arguments: &#x27;</span>, lang1, lang2);</span><br><span class="line"></span><br><span class="line">&#125;).apply(person, [<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;es&#x27;</span>]);</span><br><span class="line"><span class="comment">// Logged: John Doe</span></span><br><span class="line"><span class="comment">// Arguments: en es</span></span><br></pre></td></tr></table></figure><h2 id="Function-Borrowing"><a href="#Function-Borrowing" class="headerlink" title="Function Borrowing"></a>Function Borrowing</h2><p>延續剛才的範例，我們建立第二個物件 <code>person2</code>，但它沒有 <code>getFullName</code> 這個 <code>method</code>，這時候我們就可以透過剛剛學過的 <code>bind()</code>、<code>Call()</code> 和 <code>apply()</code> 來借用 <code>person</code> 的 <code>method</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span>,</span><br><span class="line">  getFullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fallName = <span class="built_in">this</span>.firstname + <span class="built_in">this</span>.lastname;</span><br><span class="line">    <span class="keyword">return</span> fullName;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getFullName.apply(person2));   <span class="comment">// Jane Doe</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getFullName.call(person2));   <span class="comment">// Jane Doe</span></span><br><span class="line"><span class="built_in">console</span>.log(person.getFullName.bind(person2)());   <span class="comment">// Jane Doe</span></span><br></pre></td></tr></table></figure><h2 id="Function-Curring"><a href="#Function-Curring" class="headerlink" title="Function Curring"></a>Function Curring</h2><p>接著，我們來看一下第二個不同的範例，這個範例將使用到 <code>bind()</code> ; 前面有提到 <code>bind()</code> 只會回傳 <code>function</code>，<code>call</code> 和 <code>apply</code> 則會直接執行 <code>function</code>。</p><p>首先，我們建立一個函式並將傳入的兩個變數相乘，接著透過 <code>bind()</code> 來建立第二個函式，但不同的是，透過 <code>bind()</code> 建立時，我們並沒有給足兩個參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multipleByTwo = multiply.bind(<span class="built_in">this</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multipleByTwo(<span class="number">3</span>));   <span class="comment">// 2 * 3 = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(multipleByTwo(<span class="number">4</span>));   <span class="comment">// 2 * 4 = 8</span></span><br></pre></td></tr></table></figure><p>在 <code>bind()</code> 中給的參數其實就會成為新建函式的預設值，剩餘的參數才會在呼叫時補上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multipleByTwo</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我想要一開始就給足參數的數量，那麼後須呼叫時帶入的參數就不會影響執行的結果了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> multipleByTwo = multiply.bind(<span class="built_in">this</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">multipleByTwo(<span class="number">5</span>);   <span class="comment">// 2 * 3 = 6</span></span><br><span class="line">multipleByTwo(<span class="number">10</span>);   <span class="comment">// 2 * 3 = 6</span></span><br></pre></td></tr></table></figure><p>這種先創立一個 <code>function</code> 後，再透過複製並給予預設參數的方式就稱為 <code>Function Curring</code>，實際開發很常應用在大量的算術上。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Closures and Callback</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211220/6171/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211220/6171/</url>
      
        <content type="html"><![CDATA[<p>有了先前對於 Closures 的認知後，這堂課將進一步介紹 Closures 和回呼 (Callback) </p><span id="more"></span><p>首先我看到一段程式碼如下:</p><p>建立一個 <code>sayHiLater</code>，並在其中設定一個 3 秒後印出 <code>greeting</code> 變數的計時器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHiLater</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> greeting = <span class="string">&#x27;Hi!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHiLater();</span><br></pre></td></tr></table></figure><p>結果會如預期一樣，在 3 秒後印出 <code>Hi!</code>，但進一步思考這段程式碼，為什麼 <code>setTimeout</code> 在 3 秒後還會知道 <code>greeting</code> 這個變數的值呢 ?</p><p>原因其實是這裡已經形成了一個 Closures，首先，在 <code>setTimeout</code> 函式中，我們有兩點可以特別留意 ; 第一，我們之所以可以把 <code>function</code> 當成參數傳入是因為在 JavaScript 中，<code>function</code> 屬於 <code>First Class Function</code> ，<code>function</code> 是一個 <code>object</code> ; 第二，我們直接在參數的位置透過 Function Expression 的方式建立一個 Anonymous Function</p><p>在函式 <code>sayHiLater</code> 執行完畢離開 Execution Stack 後，變數 <code>greeting</code> 仍然留在記憶體的該位置，所以當 3 秒後執行 <code>setTimeout</code> 時，會透過 <code>Scope Chain</code> 的概念取得 Outer Environment 的變數值，這裡便形成了一個 Closures。</p><h2 id="常用的-jQuery"><a href="#常用的-jQuery" class="headerlink" title="常用的 jQuery"></a>常用的 <code>jQuery</code></h2><p>在 <code>jQuery</code> 中，一個常見的基本寫法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery uses function expressions and first-class functions !</span></span><br><span class="line">$(<span class="string">&#x27;button&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>click</code> 事件中放入 <code>function</code>，這就是運用了 first class function 把函式當成一般物件傳入作為參數，而把函式當作參數的也使用到了 callback function 的觀念，告訴這個函是當指定事件發生時，呼叫我給你的函式。</p><h2 id="Callback-Function"><a href="#Callback-Function" class="headerlink" title="Callback Function"></a>Callback Function</h2><p><code>Callback Function</code> 指的是當我們呼叫一個 <code>function</code> 時，傳入另一個 <code>function</code> 當作參數，呼叫的 <code>function</code> 結束時，執行我們傳入的 <code>function</code>。</p><p>這裡我們看到一段範例程式碼如下:</p><p>傳入一個 <code>function</code> 作為參數，並在呼叫的 <code>function</code> 中執行我們傳入的 <code>function</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tellMeWhenDone</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1000</span>;   <span class="comment">// some work</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2000</span>;   <span class="comment">// some work</span></span><br><span class="line"></span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tellMeWhenDone(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am done !&#x27;</span>);   <span class="comment">// I am done !</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Framework 如何使用 Closures - Function Fatories</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211219/39540/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211219/39540/</url>
      
        <content type="html"><![CDATA[<p>有了前幾堂課對於 Closures 的了解後，這堂課將介紹 Framework 如何使用 Closures</p><span id="more"></span><p>以下我們先來看一段程式碼</p><p>首先建立一個 <code>makeGreeting</code> 函式，帶入一個 <code>language</code> 變數，並透過判斷這個變數來回傳對應的函式內容，接著透過兩個變數帶入不同的參數來呼叫這函式，最後呼叫這兩個指派給變數的函式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeGreeting</span>(<span class="params">language</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (language === <span class="string">&#x27;en&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + firstname + lastname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (language === <span class="string">&#x27;es&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hola&#x27;</span> + firstname + lastname);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> grettingEnglish = makeGreeting(<span class="string">&#x27;en&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> grettingSpanish = makeGreeting(<span class="string">&#x27;es&#x27;</span>);</span><br><span class="line"></span><br><span class="line">grettingEnglish(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);   <span class="comment">// Hello John Doe</span></span><br><span class="line">grettingSpanish(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);   <span class="comment">// Hola John Doe</span></span><br></pre></td></tr></table></figure><p>結果就是得到各自預期的字串</p><h2 id="解析程式碼"><a href="#解析程式碼" class="headerlink" title="解析程式碼"></a>解析程式碼</h2><p>以下我們依序解析這段程式碼</p><p>首先，在 JavaScript Engine 開始時，因為 Hoisting 的緣故，<code>makeGreeting()</code>、<code>greetEnglish</code> 和 <code>greetSpanish</code> 會被儲存在記憶體中，接著才會開始執行程式碼</p><p><img src="Hoisting.png"></p><p>在執行到 <code>grettingEnglish</code> 時，<code>makeGreeting</code> 的 Execution Context 會被建立，同時將 <code>language = en</code> 儲存在記憶體中，最後離開 Execution Stack，同理 <code>greetSpanish</code> 也會儲存 <code>language = es</code> 在記憶體的另一個位置</p><p><img src="greetingEnglish.png"></p><p>接著當執行到 <code>greetEnglish(&#39;John&#39;, &#39;Doe&#39;)</code> 時，會產生一個新的 Execution Context，當執行到 <code>lanuage</code> 這個變數時，因為在函式內找不到，便會透過 <code>Scoped Chain</code> 找到外部的 <code>en</code>，這整個環境便形成了一個 Closures</p><p><img src="Closures.png"></p><p>程式碼往下執行到最後一行 <code>greetSpanish</code> 時，會按照相同的流程形成第二個 <code>Closures</code>。</p><p><img src="Second-Closures.png"></p><p>這段程式碼指出的 JavaScript 特色是，每執行一次函式，都會產生一個 Execution Context，JavaScript Engine 會指向該函式對應的變數，透過函式來創造函式，可以讓我們容易使用並保留預設參數，<code>makeGreeting</code> 這個函式我們就稱它為 Function Factories。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>了解閉包 Closures (二)</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211218/40201/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211218/40201/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>有了上一堂課對於 Closures 的基礎概念後，這堂課將透過一個經典的例子進一步瞭解 Closures</p><span id="more"></span><p>讓我們看到程式碼範例:</p><h2 id="範例一"><a href="#範例一" class="headerlink" title="範例一"></a>範例一</h2><p>首先建立一個函式 <code>buildFunction</code> ，並在其中透過 <code>for</code> 迴圈把 <code>function</code> 加到 <code>array</code> 中，再透過 <code>return</code> 回傳，最後依序呼叫 <code>array</code> 中的 <code>function</code>，在這裡，我們是不是預期三個 <code>function</code> 依序回傳 <code>0~2</code> 呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = buildFunction();</span><br><span class="line"></span><br><span class="line">fs[<span class="number">0</span>](); <span class="comment">// 0 ?</span></span><br><span class="line">fs[<span class="number">1</span>](); <span class="comment">// 1 ?</span></span><br><span class="line">fs[<span class="number">2</span>](); <span class="comment">// 2 ?</span></span><br></pre></td></tr></table></figure><p>當我們透過 <code>console</code> 看到結果會發現，三個 <code>function</code> 的印出來的都是 <code>3</code>，讓我依序解析程式碼來了解發生了什麼事</p><p>首先當 JavaScript Engine 啟動時，會建立一個 Global Execution Context，接著當我們一開始建立的 <code>biildFunction</code> 被呼叫 (invoked) 時，開始執行該函式，當執行到 <code>for</code> 迴圈時，依序從 <code>i = 0~2</code> 時將 <code>function</code> 加入 <code>arr</code> 中，直到 <code>i = 3</code> ，因不符合當初設立的條件 <code>(i &lt; 3)</code>，所以跳出迴圈，最後 <code>return arr</code> 這個陣列變數</p><p><img src="BuildFunction-Invoked.png"></p><p>接著函式執行在 <code>return</code> 後執行完畢，結束這個 Execution Context 跳出 Execution Stack，根據我們上一堂課所學到的，會留下最後所建立的 <code>i = 3</code> 和 <code>arr</code> 變數在其記憶體中的位置</p><p><img src="buildFunction-pop-off.png"></p><p>在這裡我們可以先透過 <code>console.log()</code> 來看一下 <code>fs</code> 中三個 <code>function</code> 的值，會發現都是一樣的 <code>function</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fs[<span class="number">0</span>]); <span class="comment">// function() &#123;console.log(i);&#125;</span></span><br></pre></td></tr></table></figure><p>當我們回到 Global Execution Context 逐行執行程式碼時，執行到陣列中第一個函式 <code>fs[0]()</code> 時，新的 Execution Context 產生，<code>console.log(i);</code> 中的變數 <code>i</code> 會因為沒有在這個 Execution Context 宣告，所以透過 Scoped Chain 往它的 Outer Environment 尋找，於是在詞彙環境 (Lexical Enviroment) 找到 <code>i = 3</code>，因此呼叫出 <code>3</code> 這個結果，同理後續兩個函式也會按照一樣的方式執行</p><p><img src="First-Function-Invoked.png"></p><h2 id="範例二"><a href="#範例二" class="headerlink" title="範例二"></a>範例二</h2><p>那我們該如何避免範例一中，印出所有都是 <code>3</code> 的相同結果呢 ?</p><p>首先我們先建立一個相同內容的 <code>biildFunctions2</code> 來理解一下，在執行 <code>buildFunctions</code> 中的 <code>for</code> 迴圈時，我們只是將 <code>function</code> 加到 <code>array</code> 中，並沒有執行這個 <code>function</code>，所以才不會保留當下 <code>i</code> 的值，而是直到之後這個 <code>function</code> 被呼叫時，才會透過 Scoped Chain 找到被保存在記憶體中的 <code>i</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildFunctions2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = buildFunctions2();</span><br><span class="line">fs[<span class="number">0</span>](); <span class="comment">// 3</span></span><br><span class="line">fs[<span class="number">1</span>](); <span class="comment">// 3</span></span><br><span class="line">fs[<span class="number">2</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>為了保留當下的 <code>i</code> ，我們有兩個方法可以達到這個目的</p><h3 id="方法一-let"><a href="#方法一-let" class="headerlink" title="方法一: let"></a>方法一: let</h3><p>透過 <code>ES6</code> 中的關鍵字 <code>let</code>，可以讓每次跑的迴圈都建立到一個新的記憶體位置中，當函式呼叫執行時，就會指向不同的位置，所以可以得到預期 <code>0~2</code> 的結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildFunctions2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = buildFunctions2();</span><br><span class="line">fs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">fs[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">fs[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>其實也可以直接將 <code>for</code> 迴圈一開始所建立的變數 <code>i</code> 透過 <code>let</code> 來建立，也會透過相同的方式建立在記憶體中不同的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildFunctions2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = buildFunctions2();</span><br><span class="line">fs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">fs[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">fs[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="方法二-加入陣列中即執行函式"><a href="#方法二-加入陣列中即執行函式" class="headerlink" title="方法二: 加入陣列中即執行函式"></a>方法二: 加入陣列中即執行函式</h3><p>如果在不支援 <code>ES6</code> 的環境下，我們可以在把 <code>function</code> 加入到 <code>array</code> 的時候，就透過 <code>IIFE</code> 的方式執行函式來創造一個 Execution Context，藉此保留當下 <code>i</code> 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildFunctions2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    arr.push(</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;(i))</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = buildFunctions2();</span><br><span class="line">fs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">fs[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">fs[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>了解閉包 Closures (一)</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211218/44904/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211218/44904/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹一個在 JavaScript 中惡名昭彰的一個觀念 - 閉包 (Closures)</p><span id="more"></span><h2 id="了解閉包"><a href="#了解閉包" class="headerlink" title="了解閉包"></a>了解閉包</h2><p>在過去的課程中所學到的 Execution Stack、Execution Context 等觀念都會在 Closures 中被應用到。</p><p>首先我們建立一個函式並回傳一個函式，接著，呼叫這個函式再加上一組括號呼叫回傳的函式，看起來有點奇怪，但其實就只是馬上執行回傳的函式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">whattosay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(whattosay + <span class="string">&#x27; &#x27;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;Hello&#x27;</span>)(<span class="string">&#x27;Tony&#x27;</span>);   <span class="comment">// Hello Tony</span></span><br></pre></td></tr></table></figure><p>那如果我們透過一個變數儲存第一次函式的呼叫，再呼叫這個變數來執行回傳的函式呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">whattosay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(whattosay + <span class="string">&#x27; &#x27;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> satHi = greet(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">sayHi(<span class="string">&#x27;Tony&#x27;</span>);   <span class="comment">// Hi Tony</span></span><br></pre></td></tr></table></figure><p>還是會得到和原來一樣預期的結果，為什麼這麼做也會成立呢 ? 因為當我們執行 <code>sayHi</code> 函式的時候，<code>whattosay</code> 這個變數仍然存在，其實這就是一個閉包 (Closures)。</p><p>讓我們依序拆解這段程式的執行流程，當我們執行 JavaScript 時，會先產生一個 Global Execution Context，接著，執行 <code>greet</code> 函式的時候會在 Context Stack 上產生它的 Execution Context， 並回傳一個匿名函式物件 (creates a function on the fly)。</p><p><img src="Function-Invoked.png"></p><p>這裡有一個問題是，每一個函式 Execution Context 都有其記憶體的位置，但當一個 Execution Context 在 <code>return</code> 抽離 Execution Stack 後，它的記憶體會發生什麼事 ?</p><p>一般來說，JavaScript Engine 會透過一個 Garbage Collection 的機制來清除這些內容，雖然 Execution Context 已經不在了，但其中的變數還是會留在該記憶體位置。</p><p><img src="Garbage-Collection.png"></p><p>接著，當程式碼執行到 <code>sayHi()</code> 時，會再建立一個匿名函式的 Execution Context，同時帶有一個變數 <code>name</code>。</p><p><img src="Next-Execution-Context.png"></p><p>當這個匿名函式執行到 <code>whattosay</code> 這個變數時，無法在函式內找到這個變數，因此根據 <code>Scoped Chain</code> 的概念就會往外部環境逐層搜尋，這時候就會找到剛剛留在 <code>greet</code> 記憶體位置中的這個變數。</p><p>在這裡，我們把這個匿名函式的 Execution 和外部變數關 (Close) 在一起，這種現象在 JavaScript 就是一個閉包 (Closures)。透過 Closures 這個特性，可以確保在函式執行時找對其對應的外部變數，不論某個函式是否執行完畢將 Execution Context 抽離 Execution Stack，JavaScript Engine 仍然可以找到對應的外部變數。  </p><p><img src="Closures.png"></p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>立即呼叫函式表達式 IIFE</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211217/19975/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211217/19975/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹在 JavaScript 中非常普遍出現在各個 Framework 和 Library 中的一個函式用法，立即呼叫函式表達式 (Immediately Invoked Function Expressionss) 簡稱 <code>IIFE</code>。</p><span id="more"></span><h2 id="Function-State-amp-Function-Expressions"><a href="#Function-State-amp-Function-Expressions" class="headerlink" title="Function State &amp; Function Expressions"></a>Function State &amp; Function Expressions</h2><p>在之前的課程中，我們已經介紹了函式陳述句 (Function Statement) 和函式表達式 (Function Expressions)，在這兩種函式被建立時，會儲存在記憶體中，但 JavaScript 執行時並不會執行這些函式，而是等到這些函式被呼叫 (invoked) 後才會執行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function Statement</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">&#x27;John&#x27;</span>);   <span class="comment">// Hello John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function Expressions</span></span><br><span class="line"><span class="keyword">var</span> greetFunc = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">greetFunc(<span class="string">&#x27;John&#x27;</span>);   <span class="comment">// Hello John</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="立即呼叫函式-Immediately-Invoked-Function-Expressions-IIFE"><a href="#立即呼叫函式-Immediately-Invoked-Function-Expressions-IIFE" class="headerlink" title="立即呼叫函式 Immediately Invoked Function Expressions (IIFE)"></a>立即呼叫函式 Immediately Invoked Function Expressions (IIFE)</h2><p>當我們建立函式的時候就馬上使用它，把建立和呼叫的動作組合在一起，就是一個立即呼叫函式。首先建立一個 Function Expressions 並回傳一個值，接著將它直接印出來，理所當然地會得到這個函式本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(greeting);   <span class="comment">// function(name) &#123;...&#125;</span></span><br></pre></td></tr></table></figure><p>當我們執行它時，就會得到函式回傳的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(greeting(<span class="string">&#x27;Jonh&#x27;</span>));   <span class="comment">// Hello John</span></span><br></pre></td></tr></table></figure><p>那如果把呼叫的動作放到函式建立的時候，就會形成一個 IIFE</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span> + name;</span><br><span class="line">&#125;(<span class="string">&#x27;Jonh&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(greeting);   <span class="comment">// Hello John</span></span><br></pre></td></tr></table></figure><p>會發現得到和原先一樣的結果，但如果我們再次呼叫 <code>greeting()</code> ，就會得到以下 Error Log，因為我們呼叫的是 <code>return</code> 的 <code>string</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span> + name;</span><br><span class="line">&#125;(<span class="string">&#x27;Jonh&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(greeting());</span><br></pre></td></tr></table></figure><p><img src="Invoke-IIFE.png"></p><h3 id="直接建立-IIFE"><a href="#直接建立-IIFE" class="headerlink" title="直接建立 IIFE"></a>直接建立 IIFE</h3><p>在 JavaScript 中，如果我們直接在程式碼寫上一個值，即使不透過變數宣告，也不會出錯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>;   <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;I am a string&#x27;</span>;   <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;Jonh&#x27;</span>   <span class="comment">// object</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那如果我們直接寫了一個 Anonymous Function 呢 ?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>會發現出現以下 Error Log，因為當 JavaScript engine 看到 <code>function</code> 開頭時，它就會期待你是一個需要名稱的 <code>Function Statename</code></p><p><img src="Anonymous-Function.png"></p><p>為了不要讓 JavaScript 認為這是一個 Function Statement，所以我們不能以 <code>function</code> 作為程式的開頭 ; 為了達到這個目的可以透過括號 <code>()</code> 來將整個函時包起來，而因為括號只會包含 Expressions，例如 <code>(3+2) * 4;</code>，所以程式就不會報錯了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(3+2) * 4;</span><br><span class="line"></span><br><span class="line">(function(name) &#123;</span><br><span class="line">  return &#39;Hello&#39; + name;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>寫到這裡就如同前面其它型別的例子，雖然這是一個合法的寫法，但其實我們也只是建立了一個函式而已什麼也沒有做，這時候我們可以函式建立時就呼叫它，看到了嗎?這就是一個 IIFE，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstname = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log)(<span class="string">&#x27;Hello&#x27;</span> + name);</span><br><span class="line">&#125;(firstname));   <span class="comment">// Hello John</span></span><br></pre></td></tr></table></figure><p>這樣的寫法常見於各大 Framework 和 Library 中，我們也許會看到呼叫的括號有的放在裡面，有的放在外面，這些其實都是合法的寫法，只要選擇一種風格並保持就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inside</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log)(<span class="string">&#x27;Hello&#x27;</span> + name);</span><br><span class="line">&#125;(firstname));   <span class="comment">// Hello John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// outside</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log)(<span class="string">&#x27;Hello&#x27;</span> + name);</span><br><span class="line">&#125;)(firstname);   <span class="comment">// Hello John</span></span><br></pre></td></tr></table></figure><h3 id="安全程式碼"><a href="#安全程式碼" class="headerlink" title="安全程式碼"></a>安全程式碼</h3><p>當 JavaScript Engine 開始執行時，會產生一個全域的執行階段 (Global Execution Context);接著當程式執行到我們所建立的 IIFE 時，這段匿名函式 (Anonymous Function) 會儲存在全域執行階段 (Global Exection Context) 中，而因為這是一個在最後有加上括號 () 的 IIFE，所以這個函式會立即被執行並產生一個新的 Execution Context，而其中所建立的變數 <code>gretting</code> 就會在這個 Execution Context 裡面，不會影響到 Global Execution Context;因此，透過 IIFE 我們就可以達到變數彼此不會互相影響目的了。 </p><p><img src="IIFE-Execution-Context.png"></p><h3 id="透過影響外層變數重複使用"><a href="#透過影響外層變數重複使用" class="headerlink" title="透過影響外層變數重複使用"></a>透過影響外層變數重複使用</h3><p>那如果我們希望 IIFE 中的變數可以重複使用的話該怎麼做呢 ?</p><p>雖然我們使用 IIFE 的目的就是希望變數彼此不會互相影響，但有時候又希望可以在全域環境中使用到這些變數，這時候就可以透過將全域物件 <code>window</code> 帶入到 IIFE 中，並將目標變數綁訂到 <code>window</code> 上，如此一來既可以在其他 Execution Context 使用到它了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">global</span>, name</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> gretting = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">  <span class="built_in">global</span>.greeting = greeting;</span><br><span class="line">  <span class="built_in">console</span>.log(gretting + <span class="string">&#x27; &#x27;</span> + name);   <span class="comment">// Hello John</span></span><br><span class="line"></span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="string">&#x27;John&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;gretting&#x27;</span>);   <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>但在開發時，我們需要確定的定義綁定到全域的變數，不能因為一個問題或一時方便就這麼做，否則就失去 IIFE 將變數環境各自獨立的目的了。</p><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自動插入分號</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211216/16113/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211216/16113/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹 JavaScript 中自動插入分號這件事</p><span id="more"></span><p>在 JavaScript 中，每段程式碼結尾的分號 ; (semicolon) 即使不加上也不會出錯，因為 JavaScript 會自動判斷在它認為需要加上的地方幫你補上分號，但其實在開發時並不建議這麼做，因為有些寫法在自動加上分號後的結果會和你預期的不太一樣</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">  &#123;</span><br><span class="line">    firstname: <span class="string">&#x27;Tony&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getPerson());   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如上程式碼，<code>return</code> 的結果會是 <code>undefined</code> 而不是我們建立的 <code>literal object</code>，原因是 JavaScript 在判斷 <code>return</code> 後沒有程式碼後，會自動幫你加上一個分號，因此這個函式就在 <code>return</code> 這裡結束了，所以記得 <code>return</code> 後不能直接留白</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    firstname; <span class="string">&#x27;Tony&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getPerson());   <span class="comment">// &#123; firstname: &#x27;Tony&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重載函數</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211216/14606/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211216/14606/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>這堂課將介紹 JavaScript 的 Frameworks 與 libraries 常見的函式使用方法</p><span id="more"></span><p>首先我們建立一個函式並判斷傳入的參數來執行不同的行為</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">  language = language || <span class="string">&quot;en&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (language === <span class="string">&quot;en&quot;</span>) <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span> + firstname + lastname);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (language === <span class="string">&quot;es&quot;</span>) <span class="built_in">console</span>.log(<span class="string">&quot;Hola&quot;</span> + firstname + lastname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>, <span class="string">&#x27;en&#x27;</span>);   <span class="comment">// Hello John Doe</span></span><br><span class="line">greet(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>, <span class="string">&#x27;es&#x27;</span>);   <span class="comment">// Hola John Doe</span></span><br></pre></td></tr></table></figure><p>可以看到上方兩次函式的呼叫方式透過判斷最後一個參數來達到不同的行為，而我們也可以將不同的判斷包裝成不同的函式來呼叫原本的函式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetEngilsh</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line">  greet(firstname, lastname, <span class="string">&#x27;en&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greetSpanish</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line">  greet(firstname, lastname, <span class="string">&#x27;es&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetEnglish(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);   <span class="comment">// Hello John Doe</span></span><br><span class="line">greetSpanish(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>);   <span class="comment">// Hola John Doe</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>arguments 與 spread</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211215/63221/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211215/63221/</url>
      
        <content type="html"><![CDATA[<p>這堂課將會介紹在 JavaScript 中，當 Function 被建立時，會自動產生的關鍵字 Arguemnts</p><span id="more"></span><p>當我們執行一個 Function 時，執行環境 (Execution Context) 會被建立，然後產生一個變數環境 (Variable Environment) 來幫我們保存變數和一個外部外部環境 (Outer Environment) 來判斷 Scoped Chain; 接著會產生 <code>this</code> ，依據函式的呼叫方式而指向不同的 <code>object</code>; 最後一個關鍵字則是這堂課的主題 <code>arguments</code></p><p><img src="Execution-Context-is-Created.png"></p><p>在 JavaScript 中，當我們建立一個函式並呼叫它時，即使不給予預期的參數，也不會出錯，只會在用到參數時回傳 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(firstname);</span><br><span class="line">  <span class="built_in">console</span>.log(lastname);</span><br><span class="line">  <span class="built_in">console</span>.log(language);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();   <span class="comment">// undeined undeined undeined</span></span><br></pre></td></tr></table></figure><p>當然我們也可以透過修改條件判斷是否有參數傳入而給予參數一個預設值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">  language = language || <span class="string">&#x27;en&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(fistname);</span><br><span class="line">  <span class="built_in">console</span>.log(lastname);</span><br><span class="line">  <span class="built_in">console</span>.log(language);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;John&#x27;</span>);   <span class="comment">// John undefined en</span></span><br></pre></td></tr></table></figure><p>除了主動設定的參數外，JavaScript 會自動幫我們建立一個名為 <code>arguments</code> 的 array-like 關鍵字來包含所有傳入的參數，它看起來像是一個 <code>Array</code>，但又不包含 <code>Array</code> 的所有特性;如下範例，我們可以和 <code>Array</code> 一樣透過 <code>length</code> 來判斷是否為空，也可以透過 [] (brakets operator) 來取得 <code>arguments</code> 中的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">firstname, lastname, language</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Missing parameters !&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(fistname);</span><br><span class="line">  <span class="built_in">console</span>.log(lastname);</span><br><span class="line">  <span class="built_in">console</span>.log(language);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;-----&#x27;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">greet();</span><br><span class="line"><span class="comment">// Missing parameters !</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line">greet(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>, <span class="string">&#x27;en&#x27;</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line"><span class="comment">// Doe</span></span><br><span class="line"><span class="comment">// en</span></span><br><span class="line"><span class="comment">// [&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;en&#x27;]</span></span><br><span class="line"><span class="comment">// John</span></span><br><span class="line"><span class="comment">// -----</span></span><br></pre></td></tr></table></figure><h2 id="展開運算子-spread-…"><a href="#展開運算子-spread-…" class="headerlink" title="展開運算子 spread (…)"></a>展開運算子 spread (…)</h2><p>在 ES6 中有一個提供了一個新的展開運算子 spread (…)，它可以將後續傳入的所以參數集結成一個新的變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">firstname, lastname, language, ...other</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(firstname);</span><br><span class="line">  <span class="built_in">console</span>.log(lastname);</span><br><span class="line">  <span class="built_in">console</span>.log(language);</span><br><span class="line">  <span class="built_in">console</span>.log(other);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>, <span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;St.&#x27;</span>, <span class="string">&#x27;Taiwan&#x27;</span>);</span><br><span class="line"><span class="comment">// John</span></span><br><span class="line"><span class="comment">// Doe</span></span><br><span class="line"><span class="comment">// en</span></span><br><span class="line"><span class="comment">// [&#x27;St.&#x27;, &#x27;Taiwan&#x27;]</span></span><br><span class="line"><span class="comment">// [&#x27;John&#x27;, &#x27;Doe&#x27;, &#x27;en&#x27;, &#x27;St.&#x27;, &#x27;Taiwan&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>陣列-任何東西的集合</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211215/29/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211215/29/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹 Array 的建立</p><span id="more"></span><h2 id="Array-建立"><a href="#Array-建立" class="headerlink" title="Array 建立"></a>Array 建立</h2><p>在 JavaScript 建立 Array 最簡單的方式就是透過 Array literal syntax 的方式使用中括號 [] 來建立取得資料的索引是從 <code>0</code> 開始依序往後遞增。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2.</span> <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]);   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]);   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>比較特別的是，不向其他語言一樣 Array 有型別的規範，JavaScript 是一個動態型別 (Dynamically Typed)，Array 中的值可以為所有不同型別</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1.</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;Tony&#x27;</span>,</span><br><span class="line">    address: <span class="string">&#x27;111 Main St.&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting + name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>因為 Array 可以透過索引 (index) 取得內部的值，所以在 Function 的建立可以直接使用匿名函式 (Anonymous Function)，甚至可以使用其中的其他值帶入函式來使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">4</span>](arr[<span class="number">3</span>].name);   <span class="comment">// Hello Tony</span></span><br><span class="line"></span><br><span class="line">## 資料來源</span><br><span class="line"></span><br><span class="line">[Udemy-JavaScript: Understanding the Weird Parts](https:<span class="comment">//www.udemy.com/course/understand-javascript/)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h2><p>如同 <code>this</code> 一樣，在一個 Function 建立時，Arguments 也會自動被建立，並包含傳進函式的所有變數，</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>物件、函數與this</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211213/23220/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211213/23220/</url>
      
        <content type="html"><![CDATA[<p>這堂課將介紹時常困擾初學 JavaScript 所遇到的一個名詞 - <code>this</code></p><span id="more"></span><h2 id="Global-Object-Window-物件"><a href="#Global-Object-Window-物件" class="headerlink" title="Global Object - Window 物件"></a>Global Object - Window 物件</h2><p>首先，我們直接透過以下三個例子來印出 <code>this</code>，分別是全域環境、函式 <code>a</code> 函式陳述式 <code>Function Statement</code>和函式 <code>b</code> 函式表達式 <code>Function Expression</code>，在執行這三段程式碼時，會分別產生三個執行階段 <code>Execution Context</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();   <span class="comment">// Window</span></span><br><span class="line">b();   <span class="comment">// Window</span></span><br></pre></td></tr></table></figure><p>會發現三者的結果都是全域環境中的 Global Object - Window，這也代表我們可以透過 Function Statement 和 Function Expression 來建立全域變數 (Global Variable)，而全域變數可以透過直接呼叫變數名稱來使用，不需要透過 . (dot-notation) 來指稱。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.newvariable = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newvariable);   <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h2 id="this-in-object-物件中的-this"><a href="#this-in-object-物件中的-this" class="headerlink" title="this in object 物件中的 this"></a>this in object 物件中的 this</h2><p>在 JavaScript 的物件中，如果值的型別是 Primitive Type (物件以外)，我們就稱為物件的屬性 (property);而如果是一個函式 (Funciton)，我們就會稱為物件的方法 (method)，以下透過物件的方法 (method) 來呼叫 <code>this</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  name: <span class="string">&#x27;The c object&#x27;</span>,</span><br><span class="line">  log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c.log();</span><br></pre></td></tr></table></figure><p>會發現這次的 <code>this</code> 指向 <code>c</code> 這個 object 本身</p><p><img src="this-in-object.PNG"></p><h2 id="JavaScripg-中-this-的問題"><a href="#JavaScripg-中-this-的問題" class="headerlink" title="JavaScripg 中 this 的問題"></a>JavaScripg 中 this 的問題</h2><p>延續上方的範例，當我們在物件中的 method 再新增一個 <code>setname</code> 函式並呼叫 <code>this</code> 來更改物件的 property，且在這個函式的前後印出 <code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  name: <span class="string">&#x27;The c object&#x27;</span>,</span><br><span class="line">  log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Updated c object&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> setname = <span class="function"><span class="keyword">function</span>(<span class="params">newname</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = newname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setname(<span class="string">&#x27;Updated again!&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c.log();</span><br></pre></td></tr></table></figure><p>會發現即使 <code>setname</code> 函式前後的 <code>this</code> 都指向 <code>c</code> 這個物件本身</p><p><img src="change-property.PNG"></p><p>但 <code>c</code> 的 property 並沒有再次被改變，而是將 <code>this.name</code> 新增在全域物件 <code>Window</code> 上</p><p><img src="property-in-window.PNG"></p><p>這被許多人認為是 JavaScript 中的一個問題</p><h3 id="解決-this-指向-Window"><a href="#解決-this-指向-Window" class="headerlink" title="解決 this 指向 Window"></a>解決 this 指向 Window</h3><p>所以在一般開發時，為了解決這個 <code>this</code> 在物件中卻指向全域物件 <code>Window</code> 的問題，我們會透過一個變數先將 <code>this</code> 存起來，當內部函式要使用而沒有定義這個變數名稱時，就會透過 <code>scoped chain</code> 一層一層往外找這個變數名稱，就會找到前面預先存起來的 <code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">  name: <span class="string">&#x27;The c object&#x27;</span>,</span><br><span class="line">  log: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    self.name = <span class="string">&#x27;Updated c object&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> setname = <span class="function"><span class="keyword">function</span>(<span class="params">newname</span>) </span>&#123;</span><br><span class="line">      self.name = newname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setname(<span class="string">&#x27;Updated again!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c.log();</span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>傳值與傳參考</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211212/27832/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211212/27832/</url>
      
        <content type="html"><![CDATA[<!-- @format --><p>這堂課將介紹在 JavaScript 一個很重要的觀念，傳值 <code>pass by value</code> 和傳參考 (傳址) <code>pass by referece</code></p><span id="more"></span><h3 id="傳值-By-Value"><a href="#傳值-By-Value" class="headerlink" title="傳值 By Value"></a>傳值 By Value</h3><p>一段簡單的程式碼如下，首先，先宣告一個變數 <code>a</code> 並給它一個 <code> primitive value</code> 3，這時候 <code>a</code> 會存在記憶體中的一個位置 <code>0x001</code> 。接著宣告一個 <code>b = a</code>，<code>b</code> 實際上會建立另一個記憶體位置 <code>0x002</code>，兩者的值並不會互相干擾，這種情況我們就稱為傳值 <code>pass by value</code>，這種情況只會發生在值為 <code>primitive type</code> 的變數上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><img src="By-Value.PNG"></p><h3 id="傳址-傳參考-By-Reference"><a href="#傳址-傳參考-By-Reference" class="headerlink" title="傳址(傳參考) By Reference"></a>傳址(傳參考) By Reference</h3><p>相對的，如果宣告一個變數 <code>a</code> 並給它一個型別為物件 (Function 也是) 的值，同樣會在記憶體中給它一個位置 <code>0x001</code> ;但當我們建立另一個變數 <code>b</code> ，並把 <code>b</code> 的值等同於 <code>a</code>，實際上不會在記憶體中再給它一個位置，變數 <code>a</code> 和 <code>b</code> 都會指向相同的位置 <code>0x001</code> ，所以當 <code>a</code> 的值給便時也會影響到 <code>b</code>，這種情況我們就稱為傳址 (傳參考) <code>pass by reference</code>。</p><p><img src="By-Reference.PNG"></p><p>一段簡單的程式碼如下，當我們建立一個變數 <code>c</code> 並給它一個物件 <code>object</code> 的值，再建立一個 <code>d</code> 並讓它等於 <code>c</code>，接著更改 (mutate) <code>c</code> 的值時，<code>d</code> 也會跟著改變; 甚至我們透過一個函式來更改 <code>c</code> 的值時，<code>d</code> 也會跟著改變</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123; <span class="attr">greeting</span>: <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> d;</span><br><span class="line"></span><br><span class="line">d = c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; greeting: &quot;Hello&quot; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// &#123; greeting: &quot;Hello&quot; &#125;</span></span><br><span class="line"></span><br><span class="line">c.greeting = <span class="string">&quot;Hola&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; greeting: &quot;Hola&quot; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// &#123; greeting: &quot;Hola&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeGreeting</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.greeting = <span class="string">&quot;Hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">changeGreeting(c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; greeting: &quot;Hi&quot; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// &#123; greeting: &quot;Hi&quot; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h3><p>前面提到如果建立變數 <code>c</code> 並給予一個 <code>object</code> 的值，並新增另一個變數<code>d</code> 等於 <code>c</code>， 就會透過 <code>pass by reference</code> 的方式指向記憶體中的這個位置，但當我們透過 <code>object literal</code> 的方式重新賦予這個變數另外一個 <code>object</code> 的值時，JavaScript 會在記憶體中新增一個位置來存放這個新的物件，這時候 <code>c</code> 和 <code>d</code> 就會分別指向記憶體中不同的 <code>object</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123; <span class="attr">greeting</span>: <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> d;</span><br><span class="line"></span><br><span class="line">d = c;</span><br><span class="line"></span><br><span class="line">c = &#123; <span class="attr">gretting</span>: <span class="string">&quot;Hi&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &#123; greeting: &quot;Hi&quot; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// &#123; greeting: &quot;Hello&quot; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函數的陳述句與表達式的用法</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211212/33122/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211212/33122/</url>
      
        <content type="html"><![CDATA[<!-- @format --> <p>在這堂課中，將介紹函數陳述式 <code>Function Statement</code> 和函數表達式 <code>Function Expressions</code> 兩種函數的建立方式</p><span id="more"></span><h2 id="表達式-Expressions-和-陳述句-Statement-的差異"><a href="#表達式-Expressions-和-陳述句-Statement-的差異" class="headerlink" title="表達式 Expressions 和 陳述句 Statement 的差異"></a>表達式 Expressions 和 陳述句 Statement 的差異</h2><h3 id="表達式-Expressions"><a href="#表達式-Expressions" class="headerlink" title="表達式 Expressions"></a>表達式 Expressions</h3><p><code>Expressions</code> 指的是會回傳值的一串程式，這個值可以是任何型別如字串、數字或物件，而這個值可以將它存成一個變數也可以不用。</p><p>如下，在瀏覽器的 <code>console</code> 中輸入 <code>a = 1 + 2</code> 時會回傳 <code>3</code>，直接輸入 <code>1 + 2</code> 也會回傳 <code>3</code>;輸入 <code>a = &#123; greet: &#39;Hello&#39; &#125;</code> 時就會回傳物件</p><p><img src="Expressions.PNG"></p><h3 id="陳述句-Statement"><a href="#陳述句-Statement" class="headerlink" title="陳述句 Statement"></a>陳述句 Statement</h3><p>相對的，不會回傳值的就是一個陳述句，如下程式碼:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這段程式碼中因為 <code>a === 3</code> 是一個 Expression，因為會回傳 <code>true</code> 或 <code>false</code>; 而 <code>if</code> 這個指令是一個 Statement，因為不會回傳一個值，所以我們也不能將他指定給一個變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 錯誤寫法</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">if</span> (a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函數表達式-Function-Expressions-和-函數陳述句-Function-Statements"><a href="#函數表達式-Function-Expressions-和-函數陳述句-Function-Statements" class="headerlink" title="函數表達式 Function Expressions 和 函數陳述句 Function Statements"></a>函數表達式 Function Expressions 和 函數陳述句 Function Statements</h2><p>在 JavaScript 中，函數是一個物件，可以透過 <code>Expressions</code> 和 <code>Statements</code> 的方式建立</p><h3 id="函數陳述句-Function-Statements"><a href="#函數陳述句-Function-Statements" class="headerlink" title="函數陳述句 Function Statements"></a>函數陳述句 Function Statements</h3><p>一個最基本的 Function Statements 如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Function Statements 的特色在於，他不會回傳一個值，且在程式一開始就會透過 hoisting 先儲存在記憶體中，所以可以在這段程式碼前就呼叫它而不會出錯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greet();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JavaScript 中函數就是一個物件，透過物件的方式理解函數的話，這個函數會有一個屬性 <code>name</code> 的值為 <code>greet</code>和一個屬性 <code>code</code> 的值為 <code>console.log(&#39;Hi&#39;)</code></p><p><img src="Function-Statements.PNG"></p><h3 id="函數表達式-Function-Expressions"><a href="#函數表達式-Function-Expressions" class="headerlink" title="函數表達式 Function Expressions"></a>函數表達式 Function Expressions</h3><p>在 JavaScript 中，函數就是物件的一種，所以可以將它儲存在一個變數中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anonymousGreet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上程式碼，<code>function() &#123; console.log(&#39;hi&#39;) &#125;</code> 就是一個 <code>Function Expressions</code> ，我們可以將這個函數表達式存在 <code>anonymousGreet</code> 這個變數之中; 這裡可以發現，因為我們已將函數存在變數之中，所以這個函數不需要 <code>name</code>， 因為透過這個變數我們就知道這個函數在記憶體中的位置了，而這也就式匿名函數 <code>Anonymous Function </code></p><p><img src="Function-Expression.PNG"></p><p>與 <code>Function Statement</code> 不同的是，<code>Function Expressions</code> 將函數指定給一個變數，在 JavaScript 一開始執行的時候，並不會被 <code>hoisting</code>，只有變數的名稱會被存在記憶體中，而變數的預設值為 <code>undefined</code>，所以在 <code>Function Expressions</code> 前呼叫它就如同呼叫一個 <code>undefined</code></p><p><img src="Function-Expressions-Invoked.PNG"></p><h2 id="函式中的函式"><a href="#函式中的函式" class="headerlink" title="函式中的函式"></a>函式中的函式</h2><p>如下程式碼，我們將不同型別的值帶入函數中並執行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// Hello</span></span><br><span class="line">log(&#123; <span class="attr">Greet</span>: <span class="string">&quot;Hi&quot;</span> &#125;); <span class="comment">// &#123;Greet: &#x27;Hi&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>當然我們也可以將這些值預先透過變數宣告，再指定到函式當中，也會得到一樣的結果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> number = <span class="number">3</span>;</span><br><span class="line">log(number); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> string = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">Greet</span>: <span class="string">&quot;Hi&quot;</span> &#125;;</span><br><span class="line">log(&#123; <span class="attr">Greet</span>: <span class="string">&quot;Hi&quot;</span> &#125;); <span class="comment">// &#123;Greet: &#x27;Hi&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="將函式帶入函式"><a href="#將函式帶入函式" class="headerlink" title="將函式帶入函式"></a>將函式帶入函式</h3><p>如果將一個匿名函式 <code>Anonymous Function</code> 作為變數帶入函式之中，這時就如同創造了一個函式來使用 (Create the function on the fly)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>這時候就會將整個函式回傳</p><p><img src="Function-in-Function.PNG"></p><p>如果要執行傳入的函式，只要將原先的 <code>log</code> 函式稍做更改，呼叫傳入的變數，呼應到 JavaScript 非同步的特性，藉此可以確保函式執行的順序，這也是開發上和許多套件中會使用到回呼函式 <code>callback function</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// Hi</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://www.udemy.com/course/understand-javascript/">Udemy-JavaScript: Understanding the Weird Parts</a>`</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函數就是物件</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211207/50804/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211207/50804/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，函數就是物件的一種，以下先針對函數有一個基礎的介紹</p><span id="more"></span><h3 id="函數就是物件"><a href="#函數就是物件" class="headerlink" title="函數就是物件"></a>函數就是物件</h3><p>函數就是物件的一種，所以所有可以對物件做的事都可以對函數做</p><ul><li>將函數指派為一個變數的值</li><li>將函數當作參數傳入另外一個函數</li><li>函數也可以有屬性和方法</li></ul><h3 id="函數特有屬性"><a href="#函數特有屬性" class="headerlink" title="函數特有屬性"></a>函數特有屬性</h3><p>另外有幾個特性是函數特有的</p><ul><li>Name<br>函數不一定要有名稱，沒有名稱的函數就稱為匿名函數 Anonymous Function</li><li>Code<br>函數中你所寫的程式是函數的屬性之一，但函數還有其他屬性</li></ul><h3 id="函數範例"><a href="#函數範例" class="headerlink" title="函數範例"></a>函數範例</h3><p>當我們建立一個函數且追加一個屬性，並透過 <code>console.log</code> 印出時，只會印出函數內容，但呼叫屬性時還是可以取得先前建立的值，因為函數就是物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet.language = <span class="string">&#x27;english&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greet);   <span class="comment">// function greet() &#123;</span></span><br><span class="line">                        <span class="comment">// console.log(&#x27;hi&#x27;);</span></span><br><span class="line">                      <span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(greet.language);   <span class="comment">// english</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.jsp 中的 ES6+</title>
      <link href="/es6/20211124/45063/"/>
      <url>/es6/20211124/45063/</url>
      
        <content type="html"><![CDATA[<p>因公司現行專案架構為 JAVA Base 的前後端整合架構，因此前端開發都會寫在 <code>.jsp</code> 檔案內，而該檔案類型本來就有 JAVA 相關語法可以使用，所以在此紀錄與純前端開發語法上的不同之處</p><span id="more"></span><h2 id="Literals-Template"><a href="#Literals-Template" class="headerlink" title="Literals Template"></a>Literals Template</h2><p>在 ES6 的模板字串中，我們可以使用 ` 包住 <code>$&#123;&#125;</code> 將變數帶入字串中，但剛好 <code>$&#123;&#125;</code> 在 <code>.jsp</code> 檔案中也是帶入參數的保留符號，所以在 <code>.jsp</code> 中要使用模板字串時要在前方加上反斜線 <code>\</code> 以做區別</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *.jsp</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> test = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">  console.log(`\$&#123;test&#125;`);   <span class="comment">// 123</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6+ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSP </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log 雖可恥但有用</title>
      <link href="/browser/20211020/34642/"/>
      <url>/browser/20211020/34642/</url>
      
        <content type="html"><![CDATA[<p>紀錄一下前端開發時常使用到的 <code>console.log</code> 所遇到的小陷阱</p><span id="more"></span><p>在前端開發時，我們常會使用到 <code>console.log</code> 來印出資料內容以確保程式碼實行的結果與我們預期的一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2.</span> <span class="number">7</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr);   <span class="comment">// [2, 7, 5]</span></span><br></pre></td></tr></table></figure><p>但當我們執行一對程式碼後，但這個 Array 進行修改後，會發現即使在修改前使用 <code>console.log</code> 印出資料，點擊後查看結果仍會是修改後的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2.</span> <span class="number">7</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">// 一堆程式碼...</span></span><br><span class="line">arr.push(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="log.PNG"></p><p>原因是瀏覽器在印出 <code>log</code> 時，會印出最終資料，這裡我們可以透過將資料轉成字串 <code>JSON.stringify()</code> 來呈現資料當下的狀況</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2.</span> <span class="number">7</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(arr));   <span class="comment">// [2, 7, 5]</span></span><br><span class="line"><span class="comment">// 一堆程式碼...</span></span><br><span class="line">arr.push(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物件與物件實體 Object and Object Literals</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211020/30806/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211020/30806/</url>
      
        <content type="html"><![CDATA[<p>延續上一章節最後提到使用 <code>new</code> 來建立一個物件並不是很好的方法，這章節會針對這點做說明，並介紹何為物件實體 (Object Literals)</p><span id="more"></span><h2 id="使用大括號-建立物件"><a href="#使用大括號-建立物件" class="headerlink" title="使用大括號 {} 建立物件"></a>使用大括號 {} 建立物件</h2><p>上一章節透過 <code>new</code> 建立物件，並透過點. (Dot) 或中括號 [] (Bracket) 來擴增物件屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">person.firstname = <span class="string">&#x27;Tony&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但其實在建立物件時，有更快的作法，我們可以透過大括號 {} 直接建立一個物件，這裡要注意的是，大括號 {} 並不是一個運算子，在 JavaScirpt 中使用大括號 {} 就會預設你建立了一個物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>當然，我們可以做到更多，包含物件屬性 (Property) 和方法 (Method) 的建立，這樣的建立方式比起透過 <code>new</code> 來建立物件再一個一個增加屬性快上許多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;Tony&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Alicea&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    street: <span class="string">&#x27;111 Main St.&#x27;</span>,</span><br><span class="line">    city: <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">    state: <span class="string">&#x27;NY&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.firstname = <span class="string">&#x27;Tony&#x27;</span>;</span><br><span class="line">person.lastname = <span class="string">&#x27;Alicea&#x27;</span>;</span><br><span class="line">person.address.street = <span class="string">&#x27;111 Main St.&#x27;</span>;</span><br><span class="line">person.address.city = <span class="string">&#x27;New York&#x27;</span>;</span><br><span class="line">person.address.state = <span class="string">&#x27;NY&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="搭配函式使用物件"><a href="#搭配函式使用物件" class="headerlink" title="搭配函式使用物件"></a>搭配函式使用物件</h2><p>延續上方當我們建立好函式後，可以搭配函式來使用建立好的物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tony = &#123;</span><br><span class="line">  firstname: <span class="string">&#x27;Tony&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Alicea&#x27;</span>,</span><br><span class="line">  address: &#123;</span><br><span class="line">    street: <span class="string">&#x27;111 Main St.&#x27;</span>,</span><br><span class="line">    city: <span class="string">&#x27;New York&#x27;</span>,</span><br><span class="line">    state: <span class="string">&#x27;NY&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span> + person.firstname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(Tony);   <span class="comment">// Hi Tony</span></span><br></pre></td></tr></table></figure><p>我們也可以透過呼叫函式時建立物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet(&#123;</span><br><span class="line">  firstname: <span class="string">&#x27;Mary&#x27;</span>,</span><br><span class="line">  lastname: <span class="string">&#x27;Doe&#x27;</span>&#125;</span><br><span class="line">);   <span class="comment">// Hi Mary</span></span><br></pre></td></tr></table></figure><h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><p>無論是使用 <code>new</code> 關鍵字或大括號 {} 來建立物件，對於 JavaScript 底層來說都是一樣的，本質上都是建立物件到記憶體中，並建立該物件的屬性 (Property) 和方法 (Method) 於記憶體中。</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物件與函式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物件與點 Objects and the Dot</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211020/22552/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211020/22552/</url>
      
        <content type="html"><![CDATA[<p>這篇文章中我們將會探討什麼是 JavaScript 中的<code>物件 (Object)</code></p><span id="more"></span><h2 id="什麼是物件-Object"><a href="#什麼是物件-Object" class="headerlink" title="什麼是物件 Object ?"></a>什麼是物件 Object ?</h2><p>在 JavaScript 中，物件其實就是一對<code>名稱/值的配對 (key value pairs)</code>，而值又可以是另一組名稱/值的配對</p><p><img src="key-value-pairs.PNG"></p><p>物件的值又可以方為以下三種:</p><ul><li>純值 Primitive<br>第一種是原生的值，像是布林值 (Boolean)、數值 (Number) 和字串 (String)，在物件當中，我們把這類的值稱為物件的屬性 (Property)</li><li>物件 Object<br>第二種是物件 (Object)，沒有錯，就像一開始說的物件中也可以再放入物件，也就是另一組名稱/值的配對，就像是孩子一樣，這一類的值我們也稱它會為物件的屬性 (Property)</li><li>函數 Function<br>第三種值是函數，在物件中的函數我們會將它稱為物件的方法 (Method)</li></ul><p>當 JavaScript 宣告一個物件時，這個物件會在記憶體中佔有一個位置，物件中的屬性 (Property) 和方法 (Method) 也會，而物件會記錄其屬性和方法的位置使其可以參考到，這些屬性和方法的位置彼此可能有關也可能無關</p><h2 id="建立物件與屬性"><a href="#建立物件與屬性" class="headerlink" title="建立物件與屬性"></a>建立物件與屬性</h2><h3 id="方法一-中括號-Bracket"><a href="#方法一-中括號-Bracket" class="headerlink" title="方法一: 中括號 [] (Bracket)"></a>方法一: 中括號 [] (Bracket)</h3><p>首先透過 <code>new</code> 這個關鍵字來建立一個物件，並透過中括號 [] (Bracket) 來新增物件的屬性，而中括號其實也是一個運算子，我們可以透過它使物件參考到對應屬性的值</p><p><img src="Bracket.PNG"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">person[<span class="string">&#x27;firstname&#x27;</span>] = <span class="string">&#x27;Tony&#x27;</span>;</span><br><span class="line">person[<span class="string">&#x27;lastname&#x27;</span>] = <span class="string">&#x27;Alicea&#x27;</span>;</span><br></pre></td></tr></table></figure><p>這個運算子好用的地方是也可透過變數來儲存物件屬性的名稱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstNameProperty = <span class="string">&#x27;firstname&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[firstNameProperty]);   <span class="comment">// Tony</span></span><br></pre></td></tr></table></figure><h3 id="方法二-點-Dot"><a href="#方法二-點-Dot" class="headerlink" title="方法二: 點 . (Dot)"></a>方法二: 點 . (Dot)</h3><p>第二種方法更常見於開發，當我們透過點 .(Dot) 來指定物件的屬性時，可以省略引號直接當成字串搜尋物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.firstname);   <span class="comment">// Tony</span></span><br><span class="line"><span class="built_in">console</span>.log(person.lastname);    <span class="comment">// Alicea</span></span><br></pre></td></tr></table></figure><p>當然我們也可以透過點 . 來新增一個值為物件的屬性，且可以不斷新增其子屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person.address = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.address.street = <span class="string">&#x27;111 Main St.&#x27;</span>;</span><br><span class="line">person.address.city = <span class="string">&#x27;New York&#x27;</span>;</span><br><span class="line">person.address.state = <span class="string">&#x27;NY&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.address.street);   <span class="comment">// 111 Main St.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.address.city);     <span class="comment">// New York</span></span><br><span class="line"><span class="built_in">console</span>.log(person.address.state);    <span class="comment">// NY</span></span><br></pre></td></tr></table></figure><h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><p><a href="https://www.udemy.com/user/anthonypalicea/">作者</a> 最後也提到，雖然中括號 [] (Bracket) 和點 . (Dot) 都可以建立、讀取物件屬性，但一般來說會建議使用點 . 來建立，它可以使程式碼更簡潔、更好除錯，除非需要使用動態字串來取得屬性。<br>另外<a href="https://www.udemy.com/user/anthonypalicea/">作者</a> 也提到，使用 <code>new</code> 關鍵字來建立物件並不是一個好方法，這在之後的課程會再介紹。</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物件與函式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debug 神器: Debugger</title>
      <link href="/browser/20211017/20624/"/>
      <url>/browser/20211017/20624/</url>
      
        <content type="html"><![CDATA[<p>紀錄一下透過胡立大在 Lidemy 平台上 <code>先別急著寫 leetcode</code> 這堂課中所學到的 Chrome Debug 技巧</p><span id="more"></span><p>首先建立一個 html 檔案，並在 <code>&lt;script&gt;</code> 中加入一個 <code>debugger</code> 關鍵字，接著下方可以隨意方進一段範例程式碼</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// test.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">debugger</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>];</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> max = arr[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span></span><br><span class="line">    if (arr[i] &gt; max) max = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(max);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是透過 VSCode 可以透過 <code>Live Server</code> 這個 Extension 開啟，或者也可以直接點擊 html 檔案於瀏覽器開啟，開啟後按 <code>F12</code> 開啟開發者工具會自動跳轉到 <code>Sources</code>，並顯示 <code>html</code> 檔案中的程式碼，且會停留在 <code>debugger</code> 這個關鍵字上</p><p><img src="Sources.PNG"></p><p>接著看到右邊會有一排按鈕，每個按鈕代表一種接下來程式碼執行的方式，最常用的 <code>Step F9</code>，按一下執行一步程式碼，依序一行一行執行</p><p><img src="Step.png"></p><p>點選 <code>Step</code> 會發現右側 <code>Scope</code> 中會根據當下執行的狀態顯示變數的值，我們就可以藉此為程式碼 Debug 囉</p><p><img src="Scope.png"></p>]]></content>
      
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架小叮嚀:預設值 Framework Aside</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211016/19790/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211016/19790/</url>
      
        <content type="html"><![CDATA[<p>在開發 JavaScript 時，我們常會透過 <code>&lt;script&gt;</code> 來導入不同的套件，這章節來進一步了解套件被引入後的執行方式</p><span id="more"></span><p>一段常見的用法如下，我們透過 <code>&lt;script&gt;</code> 導入 <code>lib1.js</code> 和 <code>lib2.js</code> 這兩個套件，最後導入 <code>app.js</code> 來執行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>各自的程式碼如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib1.js</span></span><br><span class="line"><span class="keyword">var</span> libraryName = <span class="string">&#x27;Lib 1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib2.js</span></span><br><span class="line"><span class="keyword">var</span> libraryName = <span class="string">&#x27;Lib 2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="built_in">console</span>.log(libraryName);   <span class="comment">// Lib 2</span></span><br></pre></td></tr></table></figure><p>結果會是 <code>Lib 2</code>，原因是 JavaScript 在執行這三段程式碼的時候，並不會為它們各自創造一個執行環境，直接地說是將彼此程式碼進行堆疊，所以實際上這兩個 Library 宣告了一個相同的全域變數，結果自然會以後者來取代。</p><p>所以如果在看許多套件的原始碼會看到類似以下的方式來宣告變數，避免影響到已存在的程式碼。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib2.js</span></span><br><span class="line"><span class="keyword">var</span> libraryName = libraryName || <span class="string">&#x27;Lib 2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其實也就是在 window 宣告一個全域變數</span></span><br><span class="line"><span class="built_in">window</span>.libraryName = <span class="built_in">window</span>.libraryName || <span class="string">&#x27;Lib 2&#x27;</span>;</span><br></pre></td></tr></table></figure><p>這麼一來後續導入的套件就不會影響到前者了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> libraryName = libraryName || <span class="string">&#x27;Lib 1&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> libraryName = libraryName || <span class="string">&#x27;Lib 2&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(libraryName);   <span class="comment">// Lib 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>預設值 Default Value</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211016/58810/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211016/58810/</url>
      
        <content type="html"><![CDATA[<p>這章節會透過其他角度來看 JavaScript 強制轉型的特性</p><span id="more"></span><p>首先先宣告一個擁有一個參數的函式，我們都知道 JavaScript 的變數如果沒有主動賦值，都會被給予一個 <code>undefined</code>，所以程式並不會出錯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();        <span class="comment">// Hello undefined</span></span><br><span class="line">greet(Jerry);   <span class="comment">// Hello Jerry  </span></span><br></pre></td></tr></table></figure><p>接著將變數改成如果沒有賦值，我們透過 <code>||</code> 給予一個預設值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  name = name || <span class="string">&#x27;&lt;Your name here&gt;&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();   <span class="comment">// Hello &lt;Your name here&gt;</span></span><br></pre></td></tr></table></figure><p>原因是 <code>||</code> 優先於 <code>=</code>，而 <code>||</code> 會回傳優先為 <code>true</code> 的值，所以如果沒有賦與參數，會回傳透過 <code>Boolean</code> 轉型為 <code>true</code> 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  name = <span class="literal">false</span> || <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet();   <span class="comment">// // Hello &lt;Your name here&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>存在與布林 Existence and Booleans</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211016/61081/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211016/61081/</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，我們可以透過 <code>Boolean</code> 來判斷一個值是否存在，某些值被轉型為布林後會被判斷為 <code>false</code>，如下:</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>);        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>);          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>表示這些值都不存在，但其實一般開發並不太會使用 <code>Boolean</code> 這個函式直接強制轉型，而是會透過 <code>if-else</code> 來判斷<br>如下範例，如果沒有為一個參數主動賦值，預設值就是 <code>undefined</code>，因此會被強制轉型為 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// goes to internet and looks for a value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Something is there.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著看到如果賦值為 <code>0</code>，也會被強制轉型為 <code>false</code> ; 但如果再加上一個 <code>||</code> 使值為 <code>0</code> 的時候也通過，判定的結果就會正確，因為 <code>===</code> 優先於 <code>||</code>，在 <code>false</code> 或 <code>true</code> 的結果，結果就會是 <code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始條件</span></span><br><span class="line"><span class="keyword">if</span> (a || a === <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// === 運算子優先運算</span></span><br><span class="line"><span class="keyword">if</span> (a || <span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// || 運算子由左到右，0 被轉型為 false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> || <span class="literal">true</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>比較運算子 Comparison Operators</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211010/9237/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211010/9237/</url>
      
        <content type="html"><![CDATA[<p>結合上一章的強制轉型與運算子介紹比較運算子的應用範例</p><span id="more"></span><p>我們直接從一個最簡單的例子來理解 JavaScript 中比較運算子的規則 ; 下方的例子我們可以很直覺的反應答案是 <code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>接著看到第二個例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> &lt; <span class="number">2</span> &lt; <span class="number">1</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>會發現答案也是 <code>true</code> ?，這裡我們先看一下 <code>&lt;</code> 這個比較運算子的規則</p><p><img src="less-than.PNG"></p><p>規則為由左到右，而兩個相同的運算子層級相同，所以由最左邊開始，3 &lt; 2 的結果為 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> &lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>接著，在強制轉型章節有提到，當不同型別的值進行運算時，會被強制轉型，而 <code>false</code> 經過轉型成數字後會是 <code>0</code>，<code>true</code> 則是 <code>1</code>，所以最後答案才會是 <code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> &lt; <span class="number">1</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>這時候我們回過頭看到一開始大家覺得理所當然的比較運算就會發現，雖然答案剛好和直覺相同，但運算的過程其實不一樣</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始狀態</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次運算</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 強制轉型後</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt; <span class="number">3</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="常見的特別轉型結果"><a href="#常見的特別轉型結果" class="headerlink" title="常見的特別轉型結果"></a>常見的特別轉型結果</h3><p>以下列出 JavaScript 特別的轉型結果</p><h4 id="數字轉型"><a href="#數字轉型" class="headerlink" title="數字轉型"></a>數字轉型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>);   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="運算子"><a href="#運算子" class="headerlink" title="== 運算子"></a>== 運算子</h4><p>雙等號在不同型別比較時也會進行強制轉型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>;     <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="number">0</span>;      <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">false</span>;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但這裡有一個很特別的案例，在上方 <code>null</code> 轉型成數字時是 <code>0</code>，但透過 <code>==</code> 比較又是 <code>false</code>，這也被視為 JavaScript 的缺陷，因此開發時建議使用三個等號 <code>===</code> 避免將值強制轉型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="number">0</span>;   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="運算子-1"><a href="#運算子-1" class="headerlink" title="=== 運算子"></a>=== 運算子</h4><p>這也是一般開發在進行值的比較時建議使用的方式，避免值被強制傳型出現無法預期的錯誤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span>     <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> === <span class="number">1</span>;     <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> === <span class="string">&#x27;1&#x27;</span>;   <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h4 id="amp-運算子"><a href="#amp-運算子" class="headerlink" title="!= &amp; !== 運算子"></a>!= &amp; !== 運算子</h4><p>同理 <code>!=</code> 在比較是否不相等時會強制傳型，<code>!==</code> 則不會</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> != <span class="literal">false</span>;   <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> !== <span class="literal">false</span>;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#Less_than_operator">MDN Expressions and operators</a><br><a href="Operator+Precedence+In+Javascript">Operator+Precedence+In+Javascript</a><br><a href="Equalty+Comparison+And+Sameness+">Equalty+Comparison+And+Sameness</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>強制型轉 Coercion</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211003/50074/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211003/50074/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 是一個動態型別的語言，當不同型別的參數透過運算子來運算時，JavaScript 會將參數的型別轉為相同，而不是回傳一個錯誤的訊息</p><span id="more"></span><p>上一章節中有提到透過加號 + 來做數字的運算，但其實不只能用在數字，在字串使用時會將彼此連結</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hello &#x27;</span> + <span class="string">&#x27;World&#x27;</span>;   <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure><p>如果是一個數字加上字串的運算，JavaScript 會將數字的參數強制型轉成字串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;1&#x27;</span> + <span class="number">2</span>;   <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>即使這麼做不會出現錯誤，但一般來說盡量避免這樣的運算出現，原因是在開發時通常不會只有這麼簡單的運算，兩個參數之間可能有大量的程式碼，避免出現無法預期的 Bug</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>運算子的優先性與相依性</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211003/33835/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20211003/33835/</url>
      
        <content type="html"><![CDATA[<p>在一般的運算式中，通常不會只有一個運算子，所以當出現多個運算子時，就需要透過優先性 (Precedence) 和 相依性 (Associativity) 這兩個原則來規範運算，而這兩個原則並沒有名義上的複雜，國小數學中的先乘除後加減即是基礎規範的體現</p><span id="more"></span><h3 id="優先性-Precedence"><a href="#優先性-Precedence" class="headerlink" title="優先性 Precedence"></a>優先性 Precedence</h3><p>優先性即是當出現不同運算子時，函式執行的優先順序，如<code>乘號 *</code> 優先於<code>加號+</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">4</span> * <span class="number">5</span>;   <span class="comment">// 23</span></span><br></pre></td></tr></table></figure><h3 id="相依性-Associativity"><a href="#相依性-Associativity" class="headerlink" title="相依性 Associativity"></a>相依性 Associativity</h3><p>相依性即運算函式執行的方向為左到右或是右到左，如下<code>等號 =</code> 為右到左</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">a = b = c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN Operator Precedence &amp; Associativity</a></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vite + Vue-Roueter on Github Pages</title>
      <link href="/vue-3/20210911/13819/"/>
      <url>/vue-3/20210911/13819/</url>
      
        <content type="html"><![CDATA[<p>紀錄使用 Vite + Vue 3 + Vue-Router 部屬到 Github Pages 所遇到的問題</p><span id="more"></span><h3 id="部屬到-Github"><a href="#部屬到-Github" class="headerlink" title="部屬到 Github"></a>部屬到 Github</h3><p>不論是使用 Vite 或 Vue CLI 建構專案，在部屬到 Github Page 時，如果是要部屬到額外的 Repository，都需要在生成的讀取檔案路徑前加上 Repository 名稱，但只限於部屬到 Github 上 build 出後的檔案。</p><h4 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h4><p>可透過以下兩種方式區分開發模式 (dev) 與生成 (build) 的檔案</p><ul><li><p>環境設定檔<br>在專案跟目錄新增一個環境設定檔，如果是 Vite 就是 <code>vite.config.js</code>，Vue CLI 則是 <code>vue.config.js</code>， 在 <code>vite.config.js</code> 有一個參數 <code>base</code> 可以設定檔案的路徑，並透過 <code>process.env.NODE_ENV</code> 來判斷 Server 執行在開發或正式環境中，如果是正式環境則須加上 Github Respository 名稱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  plugins: [vue()],</span><br><span class="line">  build: &#123;</span><br><span class="line">    minify: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.resolve(__dirname, <span class="string">&#x27;./src&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  base: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;/&lt;REPO&gt;/&#x27;</span> : <span class="string">&#x27;./&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>於生成正式檔案時加上<br>另外也可以透過在生成正式檔案時加上，如果是透過 vite 建置專案，可以在 <code>package.json/scripts/build</code> 後加上 <code>--base=/&lt;REPO&gt;/</code> 參數藉此在生成時附加 Repository 路徑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;vite&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vite build --base=/&lt;REPO&gt;/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vite preview&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="部屬"><a href="#部屬" class="headerlink" title="部屬"></a>部屬</h4><p>在 <a href="https://vitejs.dev/guide/static-deploy.html#github-pages">官方的文件</a> 中推薦使用建立一個 <code>deploy.sh</code> 的 Shell Script 檔案來一鍵生成、部屬到 Github <code>gh-pages</code> branch 上，在 Github 中，Github Pages 會優先讀取 <code>gh-pages</code> branch 中的檔案，因此可藉此區分開發與生成的檔案</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! deploy.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># abort on errors</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># build</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># navigate into the build output directory</span></span><br><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line"></span><br><span class="line"><span class="comment"># if you are deploying to a custom domain</span></span><br><span class="line"><span class="comment"># echo &#x27;www.example.com&#x27; &gt; CNAME</span></span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&#x27;deploy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if you are deploying to https://&lt;USERNAME&gt;.github.io</span></span><br><span class="line"><span class="comment"># git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if you are deploying to https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;</span></span><br><span class="line"><span class="comment"># git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><h3 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h3><p>在 Vue 3 所搭配使用的 <a href="https://next.router.vuejs.org/guide/essentials/history-mode.html#different-history-modes">Vue CLI 4</a> 中，提供了一個 <code>history</code> 參數來選擇前端路由的顯示模式，方別是 <code>Hash Mode</code> 和 <code>HTML5 Mode</code></p><ul><li><p>Hash Mode<br>這是在 Vue CLI 4 以前前端路由所使用的方式，會加網址後加上一個 <code>#</code> ，但也因為這樣會降低瀏覽器的 SEO ，因此官方建議如果注重 SEO 的網站可以使用第二種 <code>HTML5 Mode</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>HTML5 Mode<br>將 history 切換到這個模式後就會在網址省略 <code>#</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h4><p>但在 Github page 使用 <code>HTML Mode</code> 就會發現當 Router 切換到其他路徑時，就會跳轉到 404 Error 頁面，原因是 Vue 只是切換 Component 而已，路徑並不存在，這裡有以下三個方式可以解決這個問題</p><ul><li><p>404.html<br>在 <code>index.html</code> 跟目錄位置新增一個 <code>404.html</code>，內容只要完全複製 <code>index.html</code> 即可</p></li><li><p>Hash Mode<br>將 Vue router history 切換回 <code>Hash Mode</code> 也可以解決這個問題</p></li><li><p>實作一個簡單的重新導向機制，在出現 404 頁面時指向 <code>index.html</code>，此原理和第一種解法相同</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Bug </tag>
            
            <tag> Vite </tag>
            
            <tag> Vue Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js 後端開發起手式 (一)</title>
      <link href="/uncategorized/20210816/22460/"/>
      <url>/uncategorized/20210816/22460/</url>
      
        <content type="html"><![CDATA[<p>[偷米騎巴哥] Node.js 後端開發起手式紀錄，Node.js 基本介紹</p><span id="more"></span><h3 id="目前已知的-JS-運用"><a href="#目前已知的-JS-運用" class="headerlink" title="目前已知的 JS 運用"></a>目前已知的 JS 運用</h3><ul><li>瀏覽器 ( Chrome、Firefox、Safari、IE、etc. )</li><li>前端工具 ( Webpack、Gulp、Grunt、etc. ) </li><li>後端開發 ( Express、Koa、etc. )</li><li>資料庫 ( MongoDB )</li><li>硬體版 ( Raspberry Pi、Webduino、etc. )</li><li>Google 雲端服務 ( Google Apps Script )</li></ul><h3 id="安裝-Node-js"><a href="#安裝-Node-js" class="headerlink" title="安裝 Node.js"></a>安裝 Node.js</h3><p>安裝具備以下兩種方式</p><h4 id="透過-NVM-安裝"><a href="#透過-NVM-安裝" class="headerlink" title="透過 NVM 安裝"></a>透過 NVM 安裝</h4><ul><li>優點<ul><li>快速切換不同版本</li><li>方便測試</li></ul></li><li>缺點<ul><li>占用較多磁碟空間 ( 但以當今的硬體規格其實可以忽略這一點安裝空間 )</li></ul></li></ul><p>可以透過到官方的 <a href="https://github.com/coreybutler/nvm-windows/releases">Github</a> 下載，一般下載 nvm-setup.zip 版本接下來一路按確認即可安裝。</p><p>安裝完 NVM 後接著就是打開 CML 透過 NVM 來安裝 Node.js，輸入 nvm 就會出現許多功能介紹。</p><p>安裝 Node.js 特定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install &lt;version&gt;</span><br></pre></td></tr></table></figure><p>使用、切換下載後的 Node.js 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use</span><br></pre></td></tr></table></figure><h4 id="直接安裝"><a href="#直接安裝" class="headerlink" title="直接安裝"></a>直接安裝</h4><ul><li>優點<ul><li>於官網直接安裝</li><li>版本固定</li></ul></li><li>缺點<ul><li>切換版本需重新安裝</li></ul></li></ul><p>Node.js 官網後會看到有兩個版本可以下載，方別是 LTS ( Long Time Support ) 長期支援的版本 &amp; Current 最新版本，如果沒有對於最新版本的需求，官方建議下載 LTS 版本即可，此版本大版號下官方宣稱會持續維護三年左右。</p><p>基於以上幾點比較，現在的環境較為推薦使用 NVM 進行安裝。</p><h3 id="基本介紹"><a href="#基本介紹" class="headerlink" title="基本介紹"></a>基本介紹</h3><p>Node.js 是 JS 在 Node 上執行的方式，也因為載體不再是瀏覽器，因此也缺乏 DOM &amp; BOM 的操控。但與前端瀏覽器相同的是，都採用 Chrome 團隊 V8 引擎，號稱地表最快 JS 引擎，原因在於一般程式語言需要被電腦讀取都需要進行編譯的動作轉成中介碼，最後再轉成電腦可直接讀取的機械碼，但 V8 省去中介碼的轉換因此能有較好的效能。<br>一般來說大版號基數為開發測試版，偶數則為正式版號，因此都以偶數版為下載版本。</p><h4 id="REPL-Read-Eval-Print-Loop-交互式命令"><a href="#REPL-Read-Eval-Print-Loop-交互式命令" class="headerlink" title="REPL (Read Eval Print Loop) 交互式命令"></a>REPL (Read Eval Print Loop) 交互式命令</h4><p>REPL 其實就和前端瀏覽器中的 console 一樣，可藉由輸入 console 印出對應訊息，作法是在 CML 中輸入 <code>node</code> 後，在顯示的 <code>&gt;</code> 符號後輸入以往在前端輸入的 console 訊息即可，但也因為不在瀏覽器中，所以同樣無法使用 DOM &amp; BOM。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node</span><br></pre></td></tr></table></figure><h5 id="執行-JS-檔案"><a href="#執行-JS-檔案" class="headerlink" title="執行 JS 檔案"></a>執行 JS 檔案</h5><p>亦可直接執行 JS 檔案，副檔名 <code>.js</code> 可以直接忽略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 執行 demo.js</span></span><br><span class="line">node demo</span><br></pre></td></tr></table></figure><h5 id="跳出-REPL"><a href="#跳出-REPL" class="headerlink" title="跳出 REPL"></a>跳出 REPL</h5><p>按一下 <code>ctrl + D</code> 或兩下 <code>ctrl + C</code> 都可以跳出 REPL 狀態</p><h3 id="全域"><a href="#全域" class="headerlink" title="全域"></a>全域</h3><p>在瀏覽器中如果直接印出 <code>this</code> 會出現 <code>Window</code> 物件，因為此物件為瀏覽中的最高級物件。一段最簡單的程式碼如下，宣告一個變數後，透過 <code>this</code> 呼叫會發現，透過 browser console &amp; REPL 都會出現期待的結過，但直接透過 node 呼叫會出現 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="comment">// browser console &amp; REPL</span></span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">global</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="global"><a href="#global" class="headerlink" title="global"></a>global</h4><p>其原因是在 node 中，為了避免全域之間彼此互相汙染，所以檔案內宣告的全域變數並不會直接掛載到全域 <code>global</code> 上，但 REPL 因為每次開啟相互獨立，所以不會有這個問題</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">global</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// node demo</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// REPL</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">global</span>)   <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="global-屬性"><a href="#global-屬性" class="headerlink" title="global 屬性"></a>global 屬性</h5><p>以下幾個屬性是專屬於 node.js，無法在瀏覽器中使用</p><ul><li><p>require()</p><ul><li><p>載入模組 ( <a href="https://nodejs.org/dist/latest-v14.x/docs/api/fs.html">Node.js 內建模組</a> )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abc.txt</span></span><br><span class="line">abcdef</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = fs.readFilesSync(<span class="string">&#x27;abc.txt&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure><p>載入後會發現出現一段 <code>buffer</code>，需要透過 <code>toString</code> Function 來將其轉成一般字串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = fs.readFilesSync(<span class="string">&#x27;abc.txt&#x27;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(data.toString());</span><br></pre></td></tr></table></figure></li><li><p>載入套件 ( 透過 NPM 下載 )<br>和前端一樣在專案底下執行指令即可安裝</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i &lt;plugin name&gt;</span><br></pre></td></tr></table></figure><p>載入後會發現所有 npm 相關套件都會被安裝在 <code>node_modules</code> 資料夾下</p><p><strong>package.json</strong></p><p>使用 npm 套件時，可透過以下指令來建構 package.json 作為專案套件的目錄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>輸入後會詢問一些專案基本資料，如果希望跳過這些問題使用預設值，在後方加上 <code>-y</code> 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p><strong>package.lock.json</strong></p><p>被記錄在這個檔案中的套件會使下次在下載專案時載入指定版本，避免有些套件橫跨大版號時語法不完全相容導致程式無法執行，因此這個檔案一般也會 commit 到 git 中。npm 5.0 版本開始就會自動產生這個檔案</p></li><li><p>載入自訂模組 ( 自己寫的模組 )</p></li></ul></li><li><p>exports<br>在製作一個模組時，可以透過 <code>exports</code> 供其他模組使用，模組預設為一個 ‘物件’，所以一般來說會在其之下新增屬性。需要特別注意的是，這裡的 require 需使用 ‘相對路徑’。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js</span></span><br><span class="line"><span class="built_in">exports</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>);</span><br><span class="line">m1.run();   <span class="comment">// run</span></span><br></pre></td></tr></table></figure><p><strong>module.exports</strong></p><p>然而如果不想從一個物件為起點，不能直接將 <code>exports</code> 賦予另一個物件，需使用 <code>module.exports</code> 來指向 <code>exports</code>，但 <code>require</code> 其實是指向 <code>module.exports</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;run&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;module1&#x27;</span>);</span><br><span class="line">m1();   <span class="comment">// run</span></span><br></pre></td></tr></table></figure></li><li><p>module<br>如同前面所述，每個 <code>exports</code> 的 .js 檔案都可以視為一個 module</p></li><li><p>__filename<br>目前正在執行的檔案</p></li><li><p>__dirname<br>目前正在執行的資料夾</p></li><li><p>process<br>提供全域資訊與訊息控制，以下為長裕資訊屬性</p><ul><li>process.argv<br>這個屬性會顯示執行時所代的參數，預設會有 node.js 和該檔案本身<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&#x27;C:\\Program Files\\nodejs\\node.exe&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;C:\\Users\\YA\\Desktop\\Node\\demo&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>如果在後方帶入額外參數則會往後新增，多個參數間只要透過空格方開即可<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">node demo xxx yyy</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  <span class="string">&#x27;C:\\Program Files\\nodejs\\node.exe&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;C:\\Users\\YA\\Desktop\\Node\\demo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>process.env<br>為一個代表環境變數的物件，包含路徑、OS.etc</li><li>process.cwd<br>代表執行當下的工作目錄</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> Back-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>運算子 operators</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210513/16622/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210513/16622/</url>
      
        <content type="html"><![CDATA[<p>運算子 (operators) 基本介紹</p><span id="more"></span><p>運算子是 JS 中的特殊函數，需要兩個參數回傳一個值，以最簡單的加法為例，JS 其實有一個名為 ‘+’ 的函數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> +(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="comment">// add the two #s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果是一般函數呼叫就會像是以下方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="number">3</span>, <span class="number">4</span>);   <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>但為了精簡這樣的寫法，就如同多數程式語言，使用 ‘中綴表示法’，也就是將函數名稱放在兩個變數之間，並去掉逗號, 和括號 () ，最終成為了我們常見的表示方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>http-server and browser local file</title>
      <link href="/browser/20210509/2556/"/>
      <url>/browser/20210509/2556/</url>
      
        <content type="html"><![CDATA[<p><code>http-server</code> 基礎應用與 <code>browser</code> 開啟本地端檔案</p><span id="more"></span><h3 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h3><p>在工作上遇到一個暫時性需求需要將前端 build 出來的檔案在本地端開啟，但無論是 webpack 或是基礎專案，只要不是全寫在 <code>html</code> 中，就會透過 link 或 script 來載入其他 <code>js</code> 或 <code>css</code> 檔案，或是嘗試使用 <code>ajax</code> 來取得本地端檔案，會發現網頁打開一片空白，開啟 console 會出現以下 error log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https, chrome-extension-resource.</span><br></pre></td></tr></table></figure><p>原因為該行為在 chrome 是被禁止的，是為了避免檔案內容被更改而載入惡意程式碼，網路上有些文章提及使用 firefox 可以解決，但我在這篇文章中的時間點使用 firefox 會出現相同的情況</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>透過 CMD 重新開啟 chrome ，但這個方法為一次性的，每次開啟 chrome 都要重新補上這段 CMD，以此來讓 chrome 忽略載入 local file 這個動作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome.exe --allow-file-access-from-file </span><br></pre></td></tr></table></figure><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>架一個最簡單的 <code>http-server</code>，透過 <code>npm</code> 即可安裝 <code>http-server</code> 這個套件，只要在對應資料夾路徑底下執行，就可以在該路徑開啟任何 <code>html</code> 檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install on global</span></span><br><span class="line">npm i http-server -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># open http server</span></span><br><span class="line">http-server</span><br></pre></td></tr></table></figure><p>接著就可以在 browser 開啟，預設為 <code>8080</code> port</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;index.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http-server </tag>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[下班後讀書會]EP3 演算法</title>
      <link href="/uncategorized/20210427/60460/"/>
      <url>/uncategorized/20210427/60460/</url>
      
        <content type="html"><![CDATA[<p>下班後讀書會筆記</p><span id="more"></span><h3 id="原始資料"><a href="#原始資料" class="headerlink" title="原始資料"></a>原始資料</h3><p><img src="%E5%8E%9F%E5%A7%8B%E8%B3%87%E6%96%99.PNG"></p><p>即為最一開始未經整理過的資料，而原始資料可透過以下兩個方法改變成為資料結構</p><h4 id="改變觀點"><a href="#改變觀點" class="headerlink" title="改變觀點"></a>改變觀點</h4><p>如果將上述的原始資料中的每筆資料看成每棵樹的根結點，在不改變資料順序的情況下即形成一個最基本的二元樹</p><p><img src="%E4%BA%8C%E5%85%83%E6%A8%B9.PNG"></p><h4 id="改變實際資料排序"><a href="#改變實際資料排序" class="headerlink" title="改變實際資料排序"></a>改變實際資料排序</h4><p>延續上面的方式進一步改變資料的順序，另每一層根節點的值都大於下方，形成一顆堆積二元樹</p><p><img src="%E5%A0%86%E7%A9%8D%E4%BA%8C%E5%85%83%E6%A8%B9.PNG"></p><h3 id="資料結構"><a href="#資料結構" class="headerlink" title="資料結構"></a>資料結構</h3><p>資料結構 = 資料 + 資料與資料的關係</p><p>常見的資料結構如下</p><ul><li>排列 Queue<br>先進的資料優先取出，並在每次資料的新增或刪除維持住這個原則</li></ul><p><img src="%E9%99%A3%E5%88%97.PNG"></p><ul><li>堆疊 Stack<br>後進的資料後出</li></ul><h3 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h3><p>演算法即為使用資料的策略，在這裡說的是’資料’而非’資料結構’，原因是根本的目的就是使用資料本身，但未經過處理的原始資料本身沒有任何規則，因此所能使用的演算法也很基本，所以一般都會進一步整理成資料結構，進而 ‘創造更多使用資料的策略’</p><p><img src="%E9%97%9C%E4%BF%82%E5%9C%96.PNG"></p><h4 id="常見的演算法"><a href="#常見的演算法" class="headerlink" title="常見的演算法"></a>常見的演算法</h4><p><img src="%E5%B8%B8%E8%A6%8B%E7%9A%84%E6%BC%94%E7%AE%97%E6%B3%95.PNG"></p><h4 id="泡沫排序法-Bubble-Sort"><a href="#泡沫排序法-Bubble-Sort" class="headerlink" title="泡沫排序法 Bubble Sort"></a>泡沫排序法 Bubble Sort</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>型別與純值</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210413/11502/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210413/11502/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 型別基礎介紹</p><span id="more"></span><h3 id="型別"><a href="#型別" class="headerlink" title="型別"></a>型別</h3><p>JavaScript 是一個動態型別的語言，也就是在賦值時才會知道型別</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c#</span></span><br><span class="line">bool isNew = <span class="string">&#x27;hello&#x27;</span>;   <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> isNew = <span class="literal">true</span>;   <span class="comment">// boolean and no errors</span></span><br><span class="line">isNew = <span class="string">&#x27;yup&#x27;</span>;      <span class="comment">// string and no errors</span></span><br><span class="line">isNew = <span class="number">1</span>;          <span class="comment">// number and no errors</span></span><br></pre></td></tr></table></figure><h3 id="純值-基本型別"><a href="#純值-基本型別" class="headerlink" title="純值 (基本型別)"></a>純值 (基本型別)</h3><p>純值是一種資料的型別，表示一個值，換句話說不是物件，因為物件是名稱/值的配對，JS 有以下六種值</p><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>JS 給所有變數的初始值，直到你主動賦值，這表示還未設定值，所以不應該使用它來設定值</p><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>這也表示沒有值，但與 undefined 的差異在於可使用它來定義變數沒有值</p><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>true 或 false 表示</p><h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><p>表示一個浮點數 float，所以永遠有小數點跟在後面，和其他程式語言分成整數和浮點數不同，JS 只有一種型別來表示數字</p><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>可使用單引號 ‘’ 或雙引號 “” 來括住任何字符</p><h4 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h4><p>symbol 代表一個唯一值，可透過 symbol() 函數來生成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s1;   <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2;   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>因為 symbol 為一個函數不是 constructor，所以使用關鍵字 <code>new</code> 會出錯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeError: Symbol is not a constructor</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure><p>symbol 函數可以給定一個字串參數來命名，藉此區別不同的 symbol 參數，但因為唯一特性，即使給定同一參數也是不同的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1.toString();   <span class="comment">// &#x27;Symbol(foo)&#x27;</span></span><br><span class="line">s2.toString();   <span class="comment">// &#x27;Symbol(bar)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s3;   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>由於 symbol 的唯一特性，所以 symbol 被拿來當物件屬性名稱時可以確保不會出現相同的名稱，也確保不會被覆蓋，物件的賦值有以下 3 種方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[mySymbol] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [mySymbol]: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, mySymbol, &#123;<span class="attr">value</span>: <span class="string">&#x27;Hello&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>這裡要注意的是，使用 symbol 作為物件的屬性時，只能透過 <code>computed property []</code> 語法，不能使用 <code>.</code> 運算子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">a[mySymbol];   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h5 id="Global-symbol"><a href="#Global-symbol" class="headerlink" title="Global symbol"></a>Global symbol</h5><p>如果希望共享同一個 <code>symbol</code> 可以透過 <code>Symbol.for()</code> 與 <code>Symbol.keyFor()</code> 來存取值</p><ul><li><p>Symbol.for(key)<br>取得名稱為 <code>key</code> 的值，如果該值不存在，則會建立一個新的值到 global symbol registry 再返回，另外 <code>key</code> 名稱也會被當成 <code>symbol</code> 名稱</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">a.toString();   <span class="comment">// &#x27;Symbol(foo)&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.keyFor()<br>用來取得 <code>global symbol key</code> 的名稱，如果沒有該名稱則返回 <code>undefined</code></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(a);   <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(b);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="Object-getOwnPropertySymbols-Symbol-遍歷"><a href="#Object-getOwnPropertySymbols-Symbol-遍歷" class="headerlink" title="Object.getOwnPropertySymbols() : Symbol 遍歷"></a>Object.getOwnPropertySymbols() : Symbol 遍歷</h5><p>物件的 symbol 屬性名稱無法被遍歷，如 <code>for....in</code>、<code>for...of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code> 和 <code>JSON.stringify()</code> 都不會返回 Symbol 屬性名稱</p><p>因此如果要取得 Symbol 屬性名稱可以使用 <code>Object.getOwnPropertySymbols()</code> 方法，此方法會返回一個陣列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;b&#x27;</span>)] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">obj[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">obj.d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols;   <span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>關於非同步回呼</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210403/45306/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210403/45306/</url>
      
        <content type="html"><![CDATA[<p>在章節的最前面有提到 JavaScript 會同步執行程式碼，而非同步指的就是在同一個時間不只執行一段程式碼</p><span id="more"></span><p>在瀏覽器中，JavaScript 並非唯一執行的引擎，還包括渲染引擎 (Rendering Engine) 和 HTTP Request ，彼此是非同步執行，不會因為一個卡住而使其他引擎停止運作，其中只有 JavaScript 使用同步執行</p><p><img src="%E5%BC%95%E6%93%8E.PNG"></p><p>JavaScript 的非同步其實是瀏覽器將事件放到事件佇列 (Event Queue) 中，原本的程式碼仍然一行行執行，當每個執行堆執行完清空後，才會繼續執行下一個事件，並創造其執行環境</p><p><img src="event-queue.PNG"></p><p>一段程式碼如下，首先執行一段 3 秒的 callback function，並宣告一個點擊事件，最後印出完成，如果在 3 秒內點擊會依照下方順序印出，原因是非同步只存在於 JavaScript 引擎外，所以非同步只是將事件加入 Event Queue，等到執行環境清空後才會依序執行 Event Queue 中的事件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// long runuing function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitThreeSeconds</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ms = <span class="number">3000</span> = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() &lt; ms)&#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;finished function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click event !&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listen for the click event</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler);</span><br><span class="line"></span><br><span class="line">waitThreeSeconds();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;finished execution&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// finished function</span></span><br><span class="line"><span class="comment">// finished execution</span></span><br><span class="line"><span class="comment">// click event</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Scope、ES6 &amp; let</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210403/41213/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210403/41213/</url>
      
        <content type="html"><![CDATA[<p>前面章節所提到變數環境、詞彙環境定義了 ‘範圍’，’範圍’是變數可以被取用的區域</p><span id="more"></span><p>下一版本的 JavaScript 稱作 ECMAScript 6、ECMAScript 2015 或 ES6，這個版本提供了新的變數宣告方式 <code>let</code></p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code> 並非完全取代 <code>var</code>，<code>var</code> 還是存在，但 <code>let</code> 讓 JavaScript 引擎使用一種叫做區塊範圍 (block scoping) 的東西，所謂區塊的定義包括 <code>if</code> &amp; <code>for</code> 的 大括號 {}，所以如果在執行 <code>for loop</code> 時，每次變數在記憶體都是指向不同的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>範圍鏈 (Scope Chain)</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210403/9017/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210403/9017/</url>
      
        <content type="html"><![CDATA[<p>延續上一章節的執行堆 (Execution Stack)，進一步介紹執行堆中的範圍鏈 (Scope Chain)，’範圍’代表我能取到變數的地方，而’鏈’則是外部環境參照的連結</p><span id="more"></span><p>在 JavaScript 中每個執行環境都有一個參照的外部環境，如果在函數執行時沒有找到該變數，JavaScript 就會往外向外部環境尋找，和這個函數的程式碼在哪裡被寫出來無關，只與執行環境被創造和你呼叫的時間點有關</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span></span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>如下圖所示，這整個執行堆就稱為範圍鏈 (Scope Chain)，’範圍’代表我能取到變數的地方，而’鏈’則是外部環境參照的連結，外部環境不一定是正下方的環境，正下方的環境只代表程式碼的物理位置，稱之為 ‘詞彙環境’;換個說法，外部參照會找到被函數創造的執行環境</p><p><img src="%E5%A4%96%E9%83%A8%E7%92%B0%E5%A2%83.PNG"></p><p>當我們將函數 b 換個環境如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(myVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line">a();   <span class="comment">// 2</span></span><br><span class="line">b();   <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure><p>b 會出現 <code>not defined</code>，原因是當程式碼執行時，a 在創造階段被創造後，並不會執行內部指令，而是會直接跳到該函數最後一行，所以 b 在全域環境中並不存在，直到 a 被呼叫後，才會在該執行環境創造 b 函數</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函數、環境與變數環境</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210325/37130/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210325/37130/</url>
      
        <content type="html"><![CDATA[<p>這章節針對變數的環境最一個簡單的介紹</p><span id="more"></span><h3 id="變數環境"><a href="#變數環境" class="headerlink" title="變數環境"></a>變數環境</h3><p>變數環境指的是變數創造時所在的環境，每個執行環境中的變數彼此式獨立的，並不會彼此影響，一段程式碼如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myVar = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(myVar);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myVar = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(myVar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>首先全域環境中的 myVar 變數被宣告，所以先取得 1，接著呼叫 a 函數加到執行堆上層並宣告該執行環境中的 myVar 變數取得 2 後同樣執行 b 函數加到執行堆上層並宣告該執行環境中的 myVar ，因為沒有賦值所以為 <code>undefined</code> ，最後 b 與 a 執行結束後離開執行堆，取得最後一個全域環境中的 1</p><p><img src="%E8%AE%8A%E6%95%B8%E7%92%B0%E5%A2%83.PNG"></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函數呼叫與執行堆</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/82/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/82/</url>
      
        <content type="html"><![CDATA[<p>函數呼叫 (Functoin Invocation) 與執行堆 (Execution Stack) 介紹</p><span id="more"></span><p>以下為一段最基礎的函示呼叫程式碼</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>首先，在創造階段的時，函式 a 和 b 會被創造並記錄在記憶體中，接著到了執行階段程式程式碼會由上而下依序執行，a 被呼叫，再藉由 a 來呼叫 b</p><h3 id="執行堆-Execution-Stack"><a href="#執行堆-Execution-Stack" class="headerlink" title="執行堆 (Execution Stack)"></a>執行堆 (Execution Stack)</h3><p>當函式被呼叫時，會創造一個獨立的執行環境放到執行堆的最上層，所以當 a 被呼叫時，就會基於全域環境放在其上層，如下圖所示</p><p><img src="%E5%9F%B7%E8%A1%8C%E5%A0%86a.PNG"></p><p>而當 a 被執行後呼叫內層的 b 又會再創造一個新的執行環境</p><p><img src="%E5%9F%B7%E8%A1%8C%E5%A0%86b.PNG"></p><p>直到 b 執行完畢離開執行堆後，繼續執行 a 尚未執行的任務，最後直到 a 也執行完畢離開執行堆，繼續由上而下依序執行全域環境的程式碼</p><p><img src="%E5%9F%B7%E8%A1%8C%E5%A0%86.PNG"></p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>單執行緒與同步執行</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/46242/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/46242/</url>
      
        <content type="html"><![CDATA[<p>基礎介紹單執行緒 (Single threaded) 和同步執行 (Synchronous execution)</p><span id="more"></span><h3 id="單執行緒-Single-threaded"><a href="#單執行緒-Single-threaded" class="headerlink" title="單執行緒 (Single threaded)"></a>單執行緒 (Single threaded)</h3><p>這個名詞指的是 JavaScript 一次只執行一件事，但並非瀏覽器一次只做一件事，而是以我們的角度看程式的執行</p><h3 id="同步執行-Synchronous-execution"><a href="#同步執行-Synchronous-execution" class="headerlink" title="同步執行 (Synchronous execution)"></a>同步執行 (Synchronous execution)</h3><p>和單執行緒有點類似，但是以程式的說法指一次只執行一件事，且由上而下依序執行</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程式執行</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/48119/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/48119/</url>
      
        <content type="html"><![CDATA[<p>延續前面章節所提到的，JavaScript 分成兩個階段，第一階段為創造階段 (Creation Context)，這個章節將介紹第二階段，執行階段 (Execution Context)</p><span id="more"></span><h3 id="執行階段"><a href="#執行階段" class="headerlink" title="執行階段"></a>執行階段</h3><p>在這個階段中，JavaScript 在創造變數與函式後，會 ‘逐行’ 執行你所寫的程式碼，執行範例結果如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hellow World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called b!</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// Hellow World!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次呼叫的 a 在宣告前呼叫，所以因為創造階段的 <code>hoisting</code> 而賦予一個預設值 <code>undefined</code>，第二次呼叫的 a 就如大家預期在執行階段被主動賦值為 ‘Hellow World!’</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript and undefined</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/27183/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210324/27183/</url>
      
        <content type="html"><![CDATA[<p>這章節會進一步套討變數的的預設值 undefined 與 not undefined 的差異</p><span id="more"></span><p>一段基本的變數宣告如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>, a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a undefined</span></span><br><span class="line"><span class="comment">// b not defined</span></span><br></pre></td></tr></table></figure><p>從以上結果來套討 undefined 與 not defined 的差異</p><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>在 JavaScript 中值為 <code>undefined</code> 的情況並非沒有值，而是在創造階段已被宣告且在記憶體中佔有空間，只是還未被主動賦予一個值，所以 JavaScript 預設都會賦予 <code>undefined</code> 這個特殊關鍵字</p><h3 id="not-defined"><a href="#not-defined" class="headerlink" title="not defined"></a>not defined</h3><p>而 not defined 就不同了，由上面的結果可以知道 b 完全沒有宣告，所以在執行階段找不到這個值所以出現 <code>not defined</code> 的提示</p><h3 id="主動賦予-undefined"><a href="#主動賦予-undefined" class="headerlink" title="主動賦予 undefined"></a>主動賦予 undefined</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="literal">undefined</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由上面的結果可以得知如果主動賦予變數 undefined 在 JavaScript 中是成立的，但這麼做是危險且不建議的，原因是 <code>undefined</code> 這個值為 JavaScript 在變數已宣告但未賦值時的預設值，所以如果這麼做就會難以區分這個變數為 <code>undefined</code> 的原因</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>創造與提升 (Creation and Hoisting)</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210323/16932/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210323/16932/</url>
      
        <content type="html"><![CDATA[<p>這個章節將延續前面的執行環境進一步探討 JS 在創造執行環境時做了什麼</p><span id="more"></span><p>一段簡單的變數與函式宣告如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hellow World&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called b!</span></span><br><span class="line"><span class="comment">// Hellow World</span></span><br></pre></td></tr></table></figure><p>結果可想而知會依序出現，但如果將呼叫的順序對調，會出現神奇的結果如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b();</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hellow World&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Called b!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called b!</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>原因是 JS 執行環境被分成以下兩階段創造</p><h3 id="Creation-Phase-創造階段"><a href="#Creation-Phase-創造階段" class="headerlink" title="Creation Phase 創造階段"></a>Creation Phase 創造階段</h3><p>在這個階段以下的東西會被創造</p><ul><li><p>Global Object</p></li><li><p>this</p></li><li><p>Outer Environment</p></li><li><p>Hoisting : Setup memory space for variables and functions<br>  在這個階段變數與函式會被定義且已經在記憶體中，函式的程式碼會被執行，但變數只會在記憶體中宣告但並不知道等號 (=) 右側所賦予的質為何，所以預設賦予他一個 ‘undefined’ 的值，而不是未宣告的 ‘not defined’</p></li></ul><h3 id="Execution-Phase-執行階段"><a href="#Execution-Phase-執行階段" class="headerlink" title="Execution Phase 執行階段"></a>Execution Phase 執行階段</h3><p>而在這個階段變數與函式都已經存在於記憶體中，接著 JS 會由上而下依序執行，直到出現等號 (=) 賦值才會出現我們期待的結果</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全域環境與全域物件</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210321/51637/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210321/51637/</url>
      
        <content type="html"><![CDATA[<p>在 JS 中，無論你寫的程式碼在何時、何處執行，都會被包在一個 JS 為你準備的執行環境之中，稱之為’全域環境’，全域顧名思義就是在任何區域都可以被取得，在其內所建立的物件也稱之為’全域物件’。</p><span id="more"></span><h2 id="何為全域"><a href="#何為全域" class="headerlink" title="何為全域 ?"></a>何為全域 ?</h2><p>在開發前端網頁時，我們基本會有一個 html 檔案，並載入如 app.js 的 JS 程式碼如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">scr</span>=<span class="string">&quot;app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在瀏覽器內打開這個檔案會發現，即使在 app.js 中沒有寫任何的內容也會在全域環境中看到以下兩項是 JS 幫你建立好的</p><ul><li><p>變數 - this<br>  this 是 JS 執行環境自動幫你產生的全域變數，開啟瀏覽器 console 即可查看其內容<br>  <img src="this.PNG"></p></li><li><p>Global Object - window<br>  打開瀏覽器，在 console 內輸入 this 並點選打開內層，就會發現裡面有一個 window 的全域物件，其所代表的就是瀏覽器這個畫面本身，所以在後端 node.js 中輸入 this 就不會是 window 這個全域物件，但仍會有一個 JS 幫你產生的全域物件，因為 JS 執行環境已被產生</p></li></ul><h2 id="建立變數"><a href="#建立變數" class="headerlink" title="建立變數"></a>建立變數</h2><p>接下來我們在 app.js 內寫一點程式碼如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;Hellow World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span> = </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>接著打開瀏覽器 console 可以透過輸入以下兩種方式找到我們宣告的變數</p><ul><li>a</li><li>window.a</li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>只要不是在函式內宣告的變數就是全域變數</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>名稱/值配對與物件</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210321/56938/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210321/56938/</url>
      
        <content type="html"><![CDATA[<p>JS 物件基本觀念</p><span id="more"></span><p>在 JS 中，物件是一個非常重要的觀念，一個名稱在執行環境中同時只會有一個值與之配對，但一個值可以是一至多組名稱與值的配對，如下基本範例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address = <span class="string">&#x27;100 Main St.&#x27;</span></span><br><span class="line"></span><br><span class="line">Address = &#123;</span><br><span class="line">    Street: <span class="string">&#x27;Main&#x27;</span>,</span><br><span class="line">    <span class="built_in">Number</span>: <span class="number">100</span>,</span><br><span class="line">    Apartment: &#123;</span><br><span class="line">        Floor: <span class="number">3</span>,</span><br><span class="line">        <span class="built_in">Number</span>: <span class="number">301</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>語法解析器、執行環境與詞彙環境</title>
      <link href="/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210321/38004/"/>
      <url>/%E5%85%8B%E6%9C%8Djs%E7%9A%84%E5%A5%87%E6%80%AA%E9%83%A8%E5%88%86/20210321/38004/</url>
      
        <content type="html"><![CDATA[<p>觀念小叮嚀</p><span id="more"></span><h3 id="語法解析器"><a href="#語法解析器" class="headerlink" title="語法解析器"></a>語法解析器</h3><p>當你寫完一段 JS 程式碼之後，並非直接交由電腦讀取，因為 JS 程式碼無法直接由電腦執行，所以中間會由程式設計師進行編譯，將你所寫的 JS 編譯成電腦可以讀取的格式，稱之為’語法解析器’</p><p><img src="%E8%AA%9E%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8.PNG"></p><h3 id="詞彙環境"><a href="#詞彙環境" class="headerlink" title="詞彙環境"></a>詞彙環境</h3><p>前面提到所寫的 JS 程式碼會被編譯成電腦看得懂的指令，而詞彙環境指的是這段程式碼被寫在哪與其環境為何，另外並非所有語言都在意其詞彙環境</p><h3 id="執行環境"><a href="#執行環境" class="headerlink" title="執行環境"></a>執行環境</h3><p>在一段程式碼中會有多個詞彙環境，而管理它們執行的就是執行環境。JS 是會被編譯的程式語言，所以在執行環境中所執行的被不是只有你所寫的 JS 程式碼而已，還包括程式設計師所寫的語法編譯器</p>]]></content>
      
      
      <categories>
          
          <category> 克服JS的奇怪部分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 前後端傳輸流程</title>
      <link href="/network/20200517/49993/"/>
      <url>/network/20200517/49993/</url>
      
        <content type="html"><![CDATA[<p>紀錄前端與後端之間的基本傳輸原理</p><span id="more"></span><h2 id="什麼是伺服器"><a href="#什麼是伺服器" class="headerlink" title="什麼是伺服器 ?"></a>什麼是伺服器 ?</h2><ul><li><p>提供服務的電腦</p><p>  ex: 網頁伺服器、檔案伺服器、郵件伺服器…</p></li><li><p>和一般電腦有什麼不一樣</p><ul><li>一般家用電腦重顯示效果，遊戲電玩或 3D 繪圖都需要強大的顯示卡運算能力</li><li>伺服器重運算及資料安全，CPU 需要非常強大, RAM 插好插滿, 磁碟陣列保護資料, 24 小時不關機</li></ul></li><li><p>網頁伺服器軟體</p><p>  ex: Apache、Micorsoft IIS、NGINX…</p></li><li><p>建立網頁伺服器</p><p>  安裝 node 後可以透過 express 來建立簡易網頁伺服器，首先檢查是否已安裝 node 並確認版本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>  安裝 express</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express-generator -g</span><br></pre></td></tr></table></figure><p>  接著可以在桌面新建立一個放置檔案的新資料夾 demo ，並進入到資料輸入以下指令來查找 express 指令</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express -h</span><br></pre></td></tr></table></figure><p>  接著建立 ejs 樣板引擎</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express -e</span><br></pre></td></tr></table></figure><p>  依照指示的步驟執行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>  最後在 <a href="http://localhost:3000/">http://localhost:3000</a> 開啟伺服器網頁</p></li><li><p>網址是如何產生畫面的 ?</p><p>  因為 HTTP 通訊協定，通訊協定就好比人溝通的語言</p></li></ul><h2 id="什麼是-HTTPS"><a href="#什麼是-HTTPS" class="headerlink" title="什麼是 HTTPS ?"></a>什麼是 HTTPS ?</h2><ul><li>http 是沒有加密的，只要攔截到封包就可以看到傳送的內容，來路不明的 wifi 就有可能藉此攔截訊息</li></ul><h2 id="localhost-是什麼"><a href="#localhost-是什麼" class="headerlink" title="localhost 是什麼 ?"></a>localhost 是什麼 ?</h2><ul><li>指向自己電腦的名稱，網址會先透過 DNS 伺服器將網址解析成 IP，但 localhost 預設指向 127.0.0.1 的 IP，網址是給人看並具有意義的，而電腦則是夠過 IP 來傳遞資料的</li></ul><p><img src="DNS.png"></p><h2 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h2><p>表示自己電腦的 IP 位置</p><h2 id="IPv4-v-s-IPv6"><a href="#IPv4-v-s-IPv6" class="headerlink" title="IPv4 v.s IPv6"></a>IPv4 v.s IPv6</h2><ul><li><p>以往都是使用 IPv4 的規則來產生 IP，但隨著 IP 不斷增加，IPv4 開始遇到 IP 不夠用的問題，因此就出現了 IPv6 來解決 IP 不夠用的問題</p><ul><li>IPv4 : 0.0.0.0 ~ 255.255.255.255 共有 2**32 組</li><li>IPv6 : 0000:0000:0000:0000:0000:0000:0000:0000 ~ FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF 共有 2n**128n 組 (n 可以突破 javascipt 位數限制)</li></ul></li></ul><h2 id="通訊阜號"><a href="#通訊阜號" class="headerlink" title="通訊阜號"></a>通訊阜號</h2><ul><li>http 預設是 80, https 預設是 443, 預設的 port 可以不加, 每個 port 只能給一支應用程式監聽, 另外 FTP 檔案傳輸協定是 21, SMTP 簡單郵件傳輸協定為 25</li></ul><h2 id="怎麼查-PORT-被誰使用"><a href="#怎麼查-PORT-被誰使用" class="headerlink" title="怎麼查 PORT 被誰使用 ?"></a>怎麼查 PORT 被誰使用 ?</h2><ul><li>透過以下指令可以查詢現在正被使用的 port</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr LISTENING</span><br></pre></td></tr></table></figure><ul><li>接著可以查詢指定的 port</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | findstr &#123;&#123;port&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="何謂-TCP-IP"><a href="#何謂-TCP-IP" class="headerlink" title="何謂 TCP/IP ?"></a>何謂 TCP/IP ?</h2><ul><li>TCP : 如同寄送大型包裹時，會拆分成許多小件以方便寄送，TCP 會將傳輸物件拆分成許多封包來運送</li><li>IP : 可以則如同寄送包裹的地址，唯有標註 IP 才會知道要傳輸的位置</li></ul><h2 id="產生-Request-封包"><a href="#產生-Request-封包" class="headerlink" title="產生 Request 封包"></a>產生 Request 封包</h2><ul><li>瀏覽器 (client) 產生 Request 封包傳送給伺服器 (server), 等待伺服器回傳 response 封包解讀裡面的內容</li></ul><h2 id="Method-請求方法"><a href="#Method-請求方法" class="headerlink" title="Method 請求方法"></a>Method 請求方法</h2><ul><li>Get : 如同寄信片，大小限制約 2 KB，</li><li>Post : 如同將大物件拆分成許多包裹來寄送，傳輸內容沒有上限</li></ul><h2 id="常見的-Request-Header"><a href="#常見的-Request-Header" class="headerlink" title="常見的 Request Header"></a>常見的 Request Header</h2><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><ul><li>瀏覽器存取的 Host 名稱，因為一個 IP 可以綁定多個 Domain ，此時就須要 Host 知道要對應哪一個伺服器</li></ul><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><ul><li>瀏覽器名稱和版本 &amp; 作業系統名稱和版本 (讓伺服器知道)</li></ul><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><ul><li>瀏覽器接受的類型 ex: text/plain、text/html</li></ul><h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><ul><li>瀏覽器接受的語言，q 值表示語言優先的權重 ex:zh-TW,zh;q=0.9,en-US;q=0.8,en;q=0.7</li></ul><h3 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h3><ul><li>瀏覽器支援的壓縮格式，大部分瀏覽器都支援 gzip 壓縮，伺服器則會壓縮內容後傳給瀏覽器，節省下載時間和頻寬</li></ul><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul><li>傳送瀏覽器時間給伺服器，讓伺服器知道瀏覽器目前的時間</li></ul><h3 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h3><ul><li>要求伺服器回應特定的結果，期望可以給想要的結果，但最終結果還是由伺服器決定 ex: 100-continue</li></ul><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><ul><li>瀏覽器 cache 檔案，下一次 request 則會發送此 header，伺服器使用這個時間來判斷是否修改過檔案，沒有則回傳 <ul><li>If-Modified-Since (時間)</li><li>If-None-Match (Hash Code)</li></ul></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>把瀏覽器的 cookie 傳給伺服器，”每一個” request 都會包含 cookie，所以盡可能減少 cookie 的使用，避免過度增加傳輸頻寬 </li></ul><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><ul><li>瀏覽器前一個瀏覽頁面的網址，可用此 header 判斷 request 的來源，但是不可靠，因為可能遭到串改 (原應為 referrer 因為拼錯了只好將錯就錯)</li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul><li>可以設定 Keep-Alive 保持連線時間，減少重新連接 TCP 連線次數，提高傳輸效率</li></ul><h3 id="Content-type"><a href="#Content-type" class="headerlink" title="Content-type"></a>Content-type</h3><ul><li>指傳送內容的格式，常見格式為 :  <ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data;boundary=–xxx</li><li>text/plain</li></ul></li></ul><h3 id="Authorizationpn"><a href="#Authorizationpn" class="headerlink" title="Authorizationpn"></a>Authorizationpn</h3><ul><li>HTTP 連線的身分驗證</li></ul><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><ul><li>升級到另外一個協定 ex: websocket</li></ul><h2 id="伺服器回應什麼"><a href="#伺服器回應什麼" class="headerlink" title="伺服器回應什麼 ?"></a>伺服器回應什麼 ?</h2><p><img src="Http_Request&Response.png"></p><ul><li><p>Header 一定放在內容前面，傳送除了內容以外的資訊</p><ul><li>內容格式 (圖檔、文字檔、HTML、JSON)</li><li>內容大小 (KB…)</li><li>內容多久後過期</li><li>內容從哪來等…</li></ul></li><li><p>內容不一定是 HTML，但 HTML 一定是內容之一 (內容還包括圖片、字型、CSS、Javascript、JSON…)</p></li></ul><h2 id="狀態碼"><a href="#狀態碼" class="headerlink" title="狀態碼"></a>狀態碼</h2><ul><li><p>1XX: 訊息類 (收到請求，請求者既徐執行操作)</p><ul><li>100 continue : server 期待收到更多訊息，以進行完整處理，多半是 Request 的 header 有待 Expect 要求回應 100</li><li>101 Switching Protocols : 用在 websocket 初始化，進行雙向資料傳輸</li></ul></li><li><p>2XX: 成功類 (操作被成功接受並處理)</p><ul><li>200 OK : 最常見的狀態碼，表示請求正常</li></ul></li><li><p>3XX: 重定向類 (需進一步操最才能完成)</p><ul><li>301 Moved Permanently : 永久移動到新的網址，同時需要有 Lfocation 的 header，SEO 會被更新</li><li>302 Found : 找到網址，同時需要有 Location 的 header，SEO 不會被更新</li><li>304 Not Modefied : 未修改，回應不包含 Content</li><li>307 Temporary Redirect : 暫時重新導向，與 302 類似，但 302 如果從 POST 進來會給從 GET 導向網址，307 則不會變更請求方法</li><li>308 Permanent Redirect : 永久重新導向，類似於 301，就好比 302 &amp; 307 之間的關係，不會變更請求方法</li></ul></li><li><p>4XX: 客戶端錯誤類 (請求語法錯誤或無法完成請求)</p><ul><li>401 Unauthorized : 未驗證拒絕存取</li><li>403 Forbidden : 伺服器接受請求，但被拒絕處理</li><li>404 Not Found : 伺服器找不到要求的網頁</li><li>413 Request Entity Too Large : 通常是 GET 傳送超過 URL 上限大小，伺服器無法處理</li></ul></li><li><p>5XX: 伺服器錯誤類 (後端問題)</p><ul><li>500 Internal Server Error : 伺服器發生錯誤，通常是後端的問題</li><li>503 Service Unavailable : 伺服器維護或者過載，伺服器當前無法處理請求</li></ul></li></ul><h2 id="常見的-Response-Header"><a href="#常見的-Response-Header" class="headerlink" title="常見的 Response Header"></a>常見的 Response Header</h2><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><ul><li>產生檔案的 Hash Code 給瀏覽器，下一次瀏覽器可以傳送 If-None-Match 給伺服器判斷是否有修改過檔案，沒有則回傳 304 且不會包含 Content</li></ul><h3 id="Lash-Modified"><a href="#Lash-Modified" class="headerlink" title="Lash-Modified"></a>Lash-Modified</h3><ul><li>回傳檔案最後的修改時間，下一次瀏覽器可以傳送 If-Modified-Since 給伺服器判斷是否有修改過檔案，沒有則回傳 304 且不會包含 Content</li></ul><h3 id="Catch-Control"><a href="#Catch-Control" class="headerlink" title="Catch-Control"></a>Catch-Control</h3><ul><li>快取檔案的策略，max-afe 則表示該檔案有效的 cache 秒數，no-cache 則表示不使用 cache</li></ul><h3 id="HTTP-1-1-快取機制"><a href="#HTTP-1-1-快取機制" class="headerlink" title="HTTP 1.1 快取機制"></a>HTTP 1.1 快取機制</h3><ul><li><a href="https://blog.toright.com/posts/3414/%E5%88%9D%E6%8E%A2-http-1-1-cache-%E6%A9%9F%E5%88%B6.htmlype">參考資料</a></li></ul><h3 id="Content-type-1"><a href="#Content-type-1" class="headerlink" title="Content-type"></a>Content-type</h3><ul><li>回傳 Content 的 mime 類型，當 content-type 設為 text/html 和 text/plain 可同時設定 charset 文字編碼格式，若無 content-type 瀏覽器自動判斷</li></ul><h3 id="Content-Disposition"><a href="#Content-Disposition" class="headerlink" title="Content-Disposition"></a>Content-Disposition</h3><ul><li>瀏覽器可以打開下載視窗並且指定檔案名稱，Ex: Content-Disposition: attachment; filename=”download.zip”</li></ul><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><ul><li>取得傳送內容的大小，讓瀏覽器可以判斷下載的進度</li></ul><h3 id="Date-1"><a href="#Date-1" class="headerlink" title="Date"></a>Date</h3><ul><li>傳送伺服器時間給瀏覽器，讓瀏覽器知道伺服器目前的時間，可以藉此計算兩者之間的時差</li></ul><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><ul><li>當狀態碼為 301 或 302 時，瀏覽器會重新導向到 Location 這個位置</li></ul><h3 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h3><ul><li>設定瀏覽器 Cookie，當瀏覽器收到此 header 則會建立 cookie 在瀏覽器中</li></ul><h3 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h3><ul><li>回傳內容的壓縮格式，讓瀏覽器知道該如何解壓縮內容</li></ul><h3 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h3><ul><li>允許跨網域存取的 Domain，全部網域使用 * 字號表示，script 和 link 標籤不再此限</li></ul><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><ul><li>是否能夠在 <frame> , <frame> 以及 <object> 載入，網站可以利用此 header 來確保本身內容不會遭受惡意嵌入到其他網站，避免 clickjacking 攻擊</li></ul><h3 id="Upgrade-1"><a href="#Upgrade-1" class="headerlink" title="Upgrade"></a>Upgrade</h3><ul><li>確認升級到新的協定，此時 connection 也會同時回應 Upgrade ex: Connection: Upgrade; Upgrade: websocket</li></ul>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typescript 環境下使用未更新的 library</title>
      <link href="/uncategorized/20191219/13747/"/>
      <url>/uncategorized/20191219/13747/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode Extensions</title>
      <link href="/vscode/20191114/7433/"/>
      <url>/vscode/20191114/7433/</url>
      
        <content type="html"><![CDATA[<p>這篇文章記錄一下目前在 VSCode 中使用到的擴充插件</p><span id="more"></span><h2 id="Chinese-Traditional-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Traditional-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Traditional) Language Pack for Visual Studio Code"></a>Chinese (Traditional) Language Pack for Visual Studio Code</h2><p>VSCode 中提供了許多符合本地化語言的擴充插件，這個插件可以將整個 VSCode 環境改成繁體中文，只需要按照以下官方說明的使用方式即可更改，更改後只要重啟 VSCode 就能完成</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>安裝好之後，在 <code>locale.json</code> 裡面設定 “locale”: “zh-tw” 即可載入中文 (繁體) 的語言套件。要修改 <code>locale.json</code>，可以按下 <code>Ctrl+Shift+P</code> 來呼叫 命令選擇區，輸入 “config” 以從其他可用命令裡面篩選出 <code>Configure Language</code> 命令。詳細步驟請參考文件 。</p><h2 id="favorites"><a href="#favorites" class="headerlink" title="favorites"></a>favorites</h2><p>這個插件提供開發者一個獨立的區域將指定檔案加到其中，就可以快速的找到指定檔案，只要對目標檔案案右鍵選取 <code>add to favorites (添加到收藏)</code></p><h2 id="indent-rainbow"><a href="#indent-rainbow" class="headerlink" title="indent-rainbow"></a>indent-rainbow</h2><p>這個插件會將程式碼前的空白透過顏色來區分，如此一來就可以快速的對齊飛相鄰的程式碼</p><h2 id="Live-Sass-Compiler"><a href="#Live-Sass-Compiler" class="headerlink" title="Live Sass Compiler"></a>Live Sass Compiler</h2><p>當我們使用 CSS 預處理器 <code>Sass</code> 時，這個插件可以即時將 <code>.scss</code> 與 <code>.sass</code> 編譯成瀏覽器可以讀取得 <code>.css</code> 檔案格式</p><h2 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a>Live Server</h2><p>安裝完此插件後，會在 VSCode 下方出現 Go Live 的選項，點選後我們在編輯網頁時就會及時在瀏覽器上改變，使我們快速的看到效果更動，不需要再次重新整理整個網頁</p><h2 id="Path-Intellisense"><a href="#Path-Intellisense" class="headerlink" title="Path Intellisense"></a>Path Intellisense</h2><p>這個插件提供我們再輸入 “相對路徑” 時，出現對應的路徑選項，不需要將整個路徑從頭到尾完整輸入</p>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模組化資料運用</title>
      <link href="/vue/20191114/12197/"/>
      <url>/vue/20191114/12197/</url>
      
        <content type="html"><![CDATA[<p><code>Veux</code> 最大的好處在於可以將原先獨立於各原件中的行為統一放到 <code>store</code> 中管理，並提供其他原件取用，但當專案變大時，如果所有的行為都放到同一支檔案中管理，這隻檔案將會變得非常龐大，因此 <code>Vuex</code> 提供了模組化的方式來拆分其中的行為</p><span id="more"></span><p>假設專案中有別有產品與購物車兩大類，在這裡我們將產品類拆分出來，首先在 <code>store</code> 中新增一支 <code>product.js</code> ，並將所有與產品有關的行為都放到這之檔案中，同理在 <code>index.js</code> 中移除與產品相關的行為，如有有使用到 <code>AJAX axios</code> 也要在這裡載入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in product.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    products: [],</span><br><span class="line">    categories: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">getProducts</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">PRODUCTS</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.products = payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">CATEGORIES</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.categories = payload;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    products: <span class="function"><span class="params">state</span> =&gt;</span> state.products,</span><br><span class="line">    categories: <span class="function"><span class="params">state</span> =&gt;</span> state.categories,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="載入拆分出去的檔案"><a href="#載入拆分出去的檔案" class="headerlink" title="載入拆分出去的檔案"></a>載入拆分出去的檔案</h2><p>拆分出去後，在 <code>index.js</code> 中透過 <code>import</code> 的方式在入拆分出去的 <code>product.js</code>，並新增一個 <code>modules</code> 的物件來取得檔案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in index.js</span></span><br><span class="line"><span class="keyword">import</span> productsModules <span class="keyword">from</span> <span class="string">&#x27;./products&#x27;</span>;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;,</span><br><span class="line">  modules: &#123; productsModules &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="區域與全域"><a href="#區域與全域" class="headerlink" title="區域與全域"></a>區域與全域</h2><p>在這裡有一個很重要的觀念要注意，當我們拆分檔案時，模組中每個屬性的預設作用域並不相同</p><ul><li><code>state</code>: 屬於模組區域變數</li><li><code>actions</code>, <code>mutations</code>, <code>getters</code>: 屬於模組全域變數</li></ul><p>所以當不同模組在 <code>state</code> 以外存在相同名稱時，就可能會出現錯誤</p><h2 id="取得模組中變數"><a href="#取得模組中變數" class="headerlink" title="取得模組中變數"></a>取得模組中變數</h2><p>如果要取得拆分出去的模組中的 <code>state</code> 變數就要在前方指定模組名稱才能取得</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">addtoCart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$store.state.productModules.products);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="將-“全域變數”-轉換成-“區域變數”"><a href="#將-“全域變數”-轉換成-“區域變數”" class="headerlink" title="將 “全域變數” 轉換成 “區域變數”"></a>將 “全域變數” 轉換成 “區域變數”</h2><p>先前提到，<code>state</code> 以外的屬性預設都是全域變數，所以如果在不同模組出現相同的名稱就會出現錯誤，在這裡可以新增一個屬性來將 “全域變數” 轉換成模組內的”區域變數”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指定模組行為"><a href="#指定模組行為" class="headerlink" title="指定模組行為"></a>指定模組行為</h2><p>但如果將模組內的行為轉換成區域變數，就會出現無法直接取得的情況，所以在元件取得模組中的行為時，要在前方指定模組名稱</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;<span class="keyword">return</span>&#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters(<span class="string">&#x27;productsModules&#x27;</span>, [<span class="string">&#x27;categories&#x27;</span>, <span class="string">&#x27;products&#x27;</span>]),</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions(<span class="string">&#x27;productsModules&#x27;</span>, [<span class="string">&#x27;getProducts&#x27;</span>]),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模組間取得全域變數"><a href="#模組間取得全域變數" class="headerlink" title="模組間取得全域變數"></a>模組間取得全域變數</h2><p>將模組中 <code>state</code> 以外的屬性區域化後，如果有取得其他模組中的屬性，就要在後方標註全域 <code>&#123; root: true &#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in products.js</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">getProducts</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    context.commit(<span class="string">&#x27;LOADING&#x27;</span>, <span class="literal">true</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元件中透過-dispatch-呼叫模組方法"><a href="#元件中透過-dispatch-呼叫模組方法" class="headerlink" title="元件中透過 dispatch 呼叫模組方法"></a>元件中透過 dispatch 呼叫模組方法</h2><p>如果是在元件中呼叫拆分出去的模組中的方法，在指定模組名稱時，直接加在前方即可，並透過斜線 <code>/</code> 隔開</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">removeCart</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;cartModules/removeCart&#x27;</span>, id);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取得其他區域化元件中的-actions-行為"><a href="#取得其他區域化元件中的-actions-行為" class="headerlink" title="取得其他區域化元件中的 actions 行為"></a>取得其他區域化元件中的 actions 行為</h2><p>如果要取得的是其他區域化元件 <code>actions</code> 中的行為，不僅要在前方指定模組，還要在後方加上 <code>&#123; root: true &#125;</code> 代表從根節點開始查找</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in one.js</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">test</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    context.dispatch(<span class="string">&#x27;two/event&#x27;</span>, parameter, &#123; <span class="attr">root</span>: <span class="literal">true</span> )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex 中的 Getters、mapGetters 與 mapActions</title>
      <link href="/vue/20191114/26866/"/>
      <url>/vue/20191114/26866/</url>
      
        <content type="html"><![CDATA[<p>在先前有提到，<code>store</code> 中有一個類似原件中的 <code>computed</code> 的方法叫做 <code>getters</code>，當有多個原件要用到這個屬性時，可以將其放到 <code>store</code> 中供其他原件使用，同樣會在其依賴的值發生變化時重新計算</p><span id="more"></span><h2 id="getters-與-mapGetters"><a href="#getters-與-mapGetters" class="headerlink" title="getters 與 mapGetters"></a>getters 與 mapGetters</h2><p>延續上一章節，我們將原先在原件 <code>computed</code> 中的屬性移到 <code>store</code> 中，<code>getters</code> 中的方法同樣在一個個參數可以帶入 <code>state</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">categories</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.categories;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">products</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.products;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment">// in store</span></span><br><span class="line">getters: &#123;</span><br><span class="line">  <span class="function"><span class="title">categories</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.categories;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">products</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.products;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>將 <code>computed</code> 中的方法移到 <code>store</code> 中後，透過 <code>import</code> 解構的方式從 <code>Vuex</code> 中取得 <code>mapGetters</code> 這個方法，再透過展開 <code>...</code> 的方式在 <code>computed</code> 中載入 <code>getters</code> 屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;categories&#x27;</span>, <span class="string">&#x27;products&#x27;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="actions-與-mapActions"><a href="#actions-與-mapActions" class="headerlink" title="actions 與 mapActions"></a>actions 與 mapActions</h2><p>同樣的，<code>actions</code> 也可以透過 <code>mapActions</code> 這個方法載入，但這裡要注意的是，<code>mapActions</code> 只能應用在 “沒有參數” 的方法上，如果原件中的方法有地入參數，就只能透過 <code>methods</code> 來呼叫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in compontent</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters, mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addtoCart</span>(<span class="params">id, qty = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addtoCart&#x27;</span>, &#123; id, qty &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    ...mapActions([<span class="string">&#x27;getProducts&#x27;</span>]);</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;categories&#x27;</span>, <span class="string">&#x27;products&#x27;</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>payload 傳遞參數</title>
      <link href="/vue/20191113/32048/"/>
      <url>/vue/20191113/32048/</url>
      
        <content type="html"><![CDATA[<p>當我們要從元件傳遞參數到 <code>actions</code> 時，如果原先在元件中的事件就有一個以上的參數，則第二個以後的參數就會出現 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"><span class="function"><span class="title">addtoCart</span>(<span class="params">id, qty = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addtoCart&#x27;</span>, id, qty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in store</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">addtoCart</span>(<span class="params">context, id, qty</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(context, id, qty);   <span class="comment">// &#x27;預設 context 內容&#x27; &#x27;id&#x27; undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="物件形式傳遞多個參數"><a href="#物件形式傳遞多個參數" class="headerlink" title="物件形式傳遞多個參數"></a>物件形式傳遞多個參數</h2><p>如果原先事件就有一個以上的參數，就可以透過物件 <code>&#123;&#125;</code> 的形式將所有參數包起來傳遞，再透過 “解構” 的方式取出參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"><span class="function"><span class="title">addtoCart</span>(<span class="params">id, qty = <span class="number">1</span></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addtoCart&#x27;</span>, &#123; id, qty &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in store</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">addtoCart</span>(<span class="params">context, &#123; id, qty &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(context, id, qty);   <span class="comment">// &#x27;預設 context 內容&#x27; &#x27;id&#x27; &#x27;qty&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 actions 取得遠端資料</title>
      <link href="/vue/20191113/7550/"/>
      <url>/vue/20191113/7550/</url>
      
        <content type="html"><![CDATA[<p><code>Vuex</code> 最大的特色就是可以將 “重複” 使用到的變數與方法統一放到 <code>store</code> 來管理，而其管理的流程是透過元件來呼叫 <code>actions</code> 來觸發 “非同步” 的事件，再透過 <code>commit</code> 呼叫 <code>mutations</code> 中的同步事件來改變 <code>state</code> 中的資料狀態，進而影響畫面的呈現</p><span id="more"></span><p>在這個章節中，我們將原先各自放在元件中的事件拉到 <code>store</code> 中統一管理，以下是原先在元件中的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      products: [],</span><br><span class="line">      categories: [],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">getProducts</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> vm = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;process.env.APIPATH&#125;</span>/api/<span class="subst">$&#123;process.env.CUSTOMPATH&#125;</span>/products/all`</span>;</span><br><span class="line">      vm.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">      <span class="built_in">this</span>.$http.get(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        vm.products = response.data.products;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;取得產品列表:&#x27;</span>, response);</span><br><span class="line">        vm.getUnique();</span><br><span class="line">        vm.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">getUnique</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> vm = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">const</span> categories = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">      vm.products.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        categories.add(item.category);</span><br><span class="line">      &#125;);</span><br><span class="line">      vm.categories = <span class="built_in">Array</span>.from(categories);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getProducts();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先將 <code>getProducts</code> 事件整個拉到 <code>actions</code> 中，並帶入第一個參數 <code>context</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">getProducts</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;process.env.APIPATH&#125;</span>/api/<span class="subst">$&#123;process.env.CUSTOMPATH&#125;</span>/products/all`</span>;</span><br><span class="line">    vm.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">this</span>.$http.get(url).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      vm.products = response.data.products;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;取得產品列表:&#x27;</span>, response);</span><br><span class="line">      vm.getUnique();</span><br><span class="line">      vm.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著修改以下項目 :</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>原先在元件中的 <code>this</code> 指的是元件本身，在這裡並不指向元件，所以先將其刪除</p><h2 id="this-store-dispatch-方法"><a href="#this-store-dispatch-方法" class="headerlink" title="this.$store.dispatch 方法"></a>this.$store.dispatch 方法</h2><p>原先透過 <code>dispatch</code> 這個方法來觸發 <code>actions</code> 中方法的方式，可以改成直接呼叫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原先方法</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">true</span>);   </span><br><span class="line">vm.getUnique();</span><br><span class="line">vm.products = response.data.products;</span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">false</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接呼叫</span></span><br><span class="line">context.commit(<span class="string">&#x27;LOADING&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">context.commit(<span class="string">&#x27;CATEGORITES&#x27;</span>, response.data.products);</span><br><span class="line">context.commit(<span class="string">&#x27;PRODUCTS&#x27;</span>, response.data.products);</span><br><span class="line">context.commit(<span class="string">&#x27;LOADING&#x27;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="儲存資料"><a href="#儲存資料" class="headerlink" title="儲存資料"></a>儲存資料</h2><p>而原先儲存資料的行為則放到 <code>mutations</code> 中管理，在這裡透過 “常數” 命名，所以名稱上不會有衝突</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">matations: &#123;</span><br><span class="line">  <span class="function"><span class="title">PRODUCTS</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    state.products = payload;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">CATEGORITES</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> categories = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    payload.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      categories.add(item.categories);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="從元件呼叫-store-事件"><a href="#從元件呼叫-store-事件" class="headerlink" title="從元件呼叫 store 事件"></a>從元件呼叫 store 事件</h2><p>原先在元件中的事件因為其中的非同步語同步都各自搬到 <code>actions</code> 與 <code>mutations</code> 中統一管理，所以在這裡只要呼叫 <code>store</code> 中的事件即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">getProducts</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;getProducts&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="axios-取得遠端資料"><a href="#axios-取得遠端資料" class="headerlink" title="axios 取得遠端資料"></a>axios 取得遠端資料</h2><p>在原先的元件中，我們透過 <code>axios</code> 這個套件中的方法來取得遠端資料，在 <code>Vue</code> 元件中，透過 <code>vue-axios</code> 的方法 <code>this.$http</code> 來操做，但是在 <code>store</code> 中只能透過 <code>axios</code> 原始的方法來操作，所以在這裡要先載入 <code>axios</code> 這個套件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$http.get(api).then();   <span class="comment">// 元件中方法</span></span><br><span class="line">axios.get(api).then();   <span class="comment">// 直接使用 axios 方法</span></span><br></pre></td></tr></table></figure><h2 id="將資料呈現畫面上"><a href="#將資料呈現畫面上" class="headerlink" title="將資料呈現畫面上"></a>將資料呈現畫面上</h2><p>最後再透過 <code>computed</code> 監控資料，在資料改變時同步改變畫面呈現，並刪除原先在元件中的變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      products: [],   <span class="comment">// delete</span></span><br><span class="line">      categories: [],   <span class="comment">// delete</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">categories</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.categories;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">products</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.products;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex 嚴謹模式</title>
      <link href="/vue/20191113/36215/"/>
      <url>/vue/20191113/36215/</url>
      
        <content type="html"><![CDATA[<p>在 <code>Vuex</code> 中，一直重複提到一個很重要的觀念就是 <code>mutations</code> 只負責同步的行為，非同步的行為如 <code>AJAX</code> 與 <code>setTimeout</code> 等都是由 <code>actions</code> 來負責</p><span id="more"></span><h2 id="錯誤的開發方式"><a href="#錯誤的開發方式" class="headerlink" title="錯誤的開發方式"></a>錯誤的開發方式</h2><p>以下分別示範兩種 <code>Vuex</code> 中 錯誤 的開發方式</p><h3 id="mutations-中設定-“非同步事件”"><a href="#mutations-中設定-“非同步事件”" class="headerlink" title="mutations 中設定 “非同步事件”"></a>mutations 中設定 “非同步事件”</h3><p>如果在 <code>mutations</code> 中建立非同步事件，透過開發者工具會發現 <code>mutations</code> 與更改的變數 <code>state</code> 會無法對上，進而造成除錯上的困難</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  <span class="function"><span class="title">LOADING</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      state.isLoading = status;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="Vuex-actions-error.png"></p><p>如果有非同步的行為應該直接加在 <code>actions</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">updateLoading</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;LOADING&#x27;</span>, payload);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mutations-外修改變數狀態"><a href="#mutations-外修改變數狀態" class="headerlink" title="mutations 外修改變數狀態"></a>mutations 外修改變數狀態</h3><p>如果在 <code>mutations</code> 以外修改變數狀態也會造成結果無法呈現，透過開發者工具察看也會發現沒有偵測到狀態</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">updateLoading</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.state.isLoading = status;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="Vuex-mutations-error.png"></p><h2 id="嚴謹模式"><a href="#嚴謹模式" class="headerlink" title="嚴謹模式"></a>嚴謹模式</h2><p>在使用 <code>Vuex</code> 開發時，加上以下指令就會在不符合規範時跳出錯誤提示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  strict: ture,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Actions 與 Mutations 改變資料狀態</title>
      <link href="/vue/20191113/2212/"/>
      <url>/vue/20191113/2212/</url>
      
        <content type="html"><![CDATA[<p>在第一個章節中有提到，在 <code>vuex</code> 中，<code>actions</code> 處理非同步的事件或取得遠端的資料，但不處理資料的狀態，而 <code>mutation</code> 則是改變資料內容的方法，所以上一章節直接更改變數的方式在 <code>vuex</code> 中並不完全正確</p><span id="more"></span><p>在這裡可以透過開發者工具中的 <code>Vue</code> 並在其中找到 <code>Vuex</code> 的選項，可以看到裡面有我們剛才在 <code>state</code> 中新增的變數 <code>isLoading</code></p><p><img src="Vuex-devtool.png"></p><h2 id="新增-Actions-與-Mutation"><a href="#新增-Actions-與-Mutation" class="headerlink" title="新增 Actions 與 Mutation"></a>新增 Actions 與 Mutation</h2><p>在官方資料中我們可以得到以下資訊 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">updateLoading</span>(<span class="params">context, payload</span>)</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">LOADING</span>(<span class="params">state, payload</span>)</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>處理非同步的事件或取得遠端的資料，但不處理資料的狀態</p><ul><li><p>第一個參數 <code>context</code>: 為預設值，包含以下屬性</p><ul><li>state</li><li>rootState</li><li>commit</li><li>dispatch</li><li>getters</li><li>rootGetters</li></ul></li><li><p>第二個參數 <code>payload</code> : 從外部傳進來的數值，由使用者所自訂</p></li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>改變資料內容的方法，並建議使用 “常數” 的變數名稱來命名，也就是全部大寫以區分其他變數，但並沒有強制性</p><p>而其中的方法同樣具有兩個參數</p><ul><li>第一個參數 <code>state</code>: 即為設定參數的 <code>state</code></li><li>第二個參數 <code>payload</code>: 同為從外部傳進來的數值，由使用者所自訂，所以可以直接透過 <code>action</code> 中的 <code>payload</code> 傳入</li></ul><h2 id="設定方法"><a href="#設定方法" class="headerlink" title="設定方法"></a>設定方法</h2><p>首先透過 <code>mutations</code> 來設定更改變數的 “方法”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  <span class="function"><span class="title">LOADING</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    state.isLoading = payload;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="觸發方法"><a href="#觸發方法" class="headerlink" title="觸發方法"></a>觸發方法</h2><p>設定方法後，透過 <code>actions</code> 來觸發 <code>mutations</code> 中的方法，觸發的方式會使用第一個參數 <code>context</code> 中的 <code>commit</code>，而其第一個參數就是要觸發的 “方法名稱”，第二個參數就是要帶入的載荷 <code>status</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">updateLoading</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    context.commit(<span class="string">&#x27;LOADING&#x27;</span>, payload);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="更改變數"><a href="#更改變數" class="headerlink" title="更改變數"></a>更改變數</h2><p>上一章節中，我們直接透過 <code>this.$store.state</code> 來改變變數的值並不完全正確，正確的方式是透過 <code>this.$store.dispatch</code> 來呼叫 <code>actions</code> 中的方法，第一個參數就是 “方法名稱”，第二個參數是要 “帶入的值”，再進一步呼叫 <code>mutations</code> 來更改變數的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 錯誤方式</span></span><br><span class="line"><span class="built_in">this</span>.$store.state.isLoading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正確方式</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;updateLoading&#x27;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>在這裡要注意的是，<code>dispatch</code> 是用來 “賦予值” 的，所以 <code>computed</code> 中還是直接 <code>return state</code> 中的變數 <code>isLoading</code> 就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">isLoading</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.isLoading;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="開發者工具"><a href="#開發者工具" class="headerlink" title="開發者工具"></a>開發者工具</h2><p>將 <code>vuex</code> 改成正確的方式後，打開開發者工具中的 <code>Vue/Vuex</code>，每次呼叫 <code>mutations</code> 中的方法都會保有紀錄，將游標移到上方就會顯示幾個按鈕，按下 <code>Time Travel to This State</code> 會可回到該狀態檢視</p><p><img src="Vuex-devtool-timeTravel.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://vuex.vuejs.org/zh/api/#mutations">官方資料</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新增一個 store 來管理網站資料狀態</title>
      <link href="/vue/20191113/33419/"/>
      <url>/vue/20191113/33419/</url>
      
        <content type="html"><![CDATA[<p>這章節會將兩個各自透過變數 <code>Loading</code> 管理 <code>vue-loading-overlay</code> 的元件統一由 <code>store</code> 來管理</p><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loading</span> <span class="attr">:active.sync</span>=<span class="string">&quot;isLoading&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Loading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span></span><br><span class="line">    data ()&#123;    </span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;      </span></span><br><span class="line"><span class="javascript">        isLoading: <span class="literal">false</span>,    </span></span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="安裝-Vuex"><a href="#安裝-Vuex" class="headerlink" title="安裝 Vuex"></a>安裝 Vuex</h2><p>首先透過以下指令安裝 <code>Vuex</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vuex</span><br></pre></td></tr></table></figure><h2 id="在進入點-main-js-啟用"><a href="#在進入點-main-js-啟用" class="headerlink" title="在進入點 main.js 啟用"></a>在進入點 main.js 啟用</h2><p>下載後在進入點 <code>main.js</code> 啟用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in main.js</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><h2 id="新增-store-管理檔案"><a href="#新增-store-管理檔案" class="headerlink" title="新增 store 管理檔案"></a>新增 store 管理檔案</h2><p>可以透過新增一個 <code>store</code> 資料夾，並在其內新增一個 <code>index.js</code> 檔案來彙整所有 <code>vuex</code> 的行為，同樣的，需要先載入 <code>vue &amp; vuex</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in store/index.js</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure><p>載入 <code>vue &amp; vuex</code> 後就可以透過 <code>ES6</code> 的 <code>export default</code> 來輸出資料內容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="從進入點載入管理檔案"><a href="#從進入點載入管理檔案" class="headerlink" title="從進入點載入管理檔案"></a>從進入點載入管理檔案</h2><p>存檔後就可以在進入點 <code>main.js</code> 載入這支彙整 <code>vuex</code> 的檔案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="新增管理變數"><a href="#新增管理變數" class="headerlink" title="新增管理變數"></a>新增管理變數</h2><p><code>vuex</code> 會將原先由各自元件管理的變數統一由一個檔案來彙整，在這個範例中會將 <code>isLoading</code> 這個變數拉到 <code>state</code> 中管理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in store/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="載入管理變數"><a href="#載入管理變數" class="headerlink" title="載入管理變數"></a>載入管理變數</h2><p>改由 <code>vuex</code> 管理變數後，原先在各元件中的變數就可以移除，並透過 <code>compoted</code> 來載入由 <code>vuex</code> 檔案來統一管理的變數 ; 而在這裡可以使用與原先相同的變數名稱 <code>isLoading</code> 來建立函式，就可以不用該改 <code>HTML</code> 元素中的設定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  isLoading ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.isLoading</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更改變數的值"><a href="#更改變數的值" class="headerlink" title="更改變數的值"></a>更改變數的值</h2><p>過往透過更改變數的值來控制呈現狀態的方式，在這裡要更改的變數也要改成 <code>vuex</code> 檔案中的變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in component</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  getProducts ()&#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">const</span> api = <span class="string">`test.api`</span>;</span><br><span class="line">    </span><br><span class="line">    vm.$store.state.isLoading = <span class="literal">true</span>;</span><br><span class="line">    vm.$http.get(api).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      vm.$store.state.isLoading = <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刪除子元件元素"><a href="#刪除子元件元素" class="headerlink" title="刪除子元件元素"></a>刪除子元件元素</h2><p>透過 <code>vuex</code> 統一管理變數的方式，子元件中的元素就可以刪除，並統一由父元件與 <code>vuex</code> 檔案來管理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- in child component --&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loading</span> <span class="attr">:active.sync</span>=<span class="string">&quot;isLoading&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Loading</span>&gt;</span>  <span class="comment">&lt;!-- delete --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://vuex.vuejs.org/zh/installation.html">官方資料</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex 是什麼 ?</title>
      <link href="/vue/20191113/2839/"/>
      <url>/vue/20191113/2839/</url>
      
        <content type="html"><![CDATA[<p>Vuex 是用來管理前端網站的資料狀態，適用於規模較大的網站，如果網站規模不夠大，反而是多了限制</p><span id="more"></span><h2 id="以往的資料傳遞方式"><a href="#以往的資料傳遞方式" class="headerlink" title="以往的資料傳遞方式"></a>以往的資料傳遞方式</h2><p>以往的資料傳遞方式分別是透過以下方法來達成</p><ul><li><code>emit</code>: 內層元件傳遞至外層元件</li><li><code>props</code>: 外層元件傳遞至內層元件</li><li><code>$eventbus</code>: 同層元件或跨層元件間的傳遞，但僅適用於資料量較小的情況，如果資料量過大，容易造成管理上的混亂</li><li><code>全域變數</code>: 無法發揮 Vue 雙向綁定的特色</li></ul><h2 id="Vuex-的特色"><a href="#Vuex-的特色" class="headerlink" title="Vuex 的特色"></a>Vuex 的特色</h2><p>將所有資料和方法都拉進來統一管理，每個階層的元件都可以呼叫 <code>Vuex</code> 內的方法，並維持 <code>Vue</code> 雙向綁定的特性，而存在於其中的方法稱為 <code>store</code></p><h2 id="Vuex-的方法"><a href="#Vuex-的方法" class="headerlink" title="Vuex 的方法"></a>Vuex 的方法</h2><p>Vuex 的方法都有其相對的元件方法，但又不完全相同</p><table>  <thead>    <tr>      <th>元件方法</th>      <th>Vuex 方法</th>      <th>功能</th>    </tr>  </thead>  <tbody>    <tr>      <td>data</td>      <td>state</td>      <td>管理資料的位置與資料的狀態</td>    </tr>    <tr>      <td>methods</td>      <td>action</td>      <td>處理非同步的事件或取得遠端的資料，但不處理資料的狀態</td>    </tr>    <tr>      <td>computed</td>      <td>getter</td>      <td>在資料呈現於畫面前過濾或是進行運算</td>    </tr>    <tr>      <td></td>      <td>mutation</td>      <td>改變資料內容的方法</td>    </tr>  </tbody></table><h2 id="Vuex-流程"><a href="#Vuex-流程" class="headerlink" title="Vuex 流程"></a>Vuex 流程</h2><ul><li>首先透過 <code>Dispatch</code> 這個方法來觸發 <code>Actions</code> 事件</li><li>接著 <code>Actions</code> 就會取得遠端的資料或處理非同步的行為，但並不會改變資料的狀態</li><li>再來 <code>Actions</code> 會透過 <code>Commit</code> 這個方法來呼叫 <code>Mutations</code>，並透過 <code>Mutations</code> 來改變資料的狀態</li><li>最後回傳給 <code>Vue</code> 元件來做畫面的繪製，其中 <code>Mutations</code> 與開法者工具 <code>Vue Devtools</code> 有很大的關係，所以在 <code>Mutations</code> 不會再取得資料，而在 <code>Actinos</code> 不會改變資料內容</li></ul><p><img src="Vuex-process.png"></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://vuex.vuejs.org/zh/guide/">官方文件</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 同步與非同步</title>
      <link href="/javascript/20191105/37805/"/>
      <url>/javascript/20191105/37805/</url>
      
        <content type="html"><![CDATA[<p><code>synchronous</code> 和 <code>asynchronous</code> 如果將其翻譯成中文的 “同步” 與 “非同步” 反而很容易誤解其含義，同步 <code>synchronous</code> 指的是 <code>one at a time</code>，一次執行一列程式碼並依序執行，非同步 <code>asynchronous</code> 指的是 <code>more than one at a time</code>，同時執行不只一列程式碼</p><span id="more"></span><h2 id="同步與非同步簡介"><a href="#同步與非同步簡介" class="headerlink" title="同步與非同步簡介"></a>同步與非同步簡介</h2><p>JavaScript 執行的方式 “同步” <code>synchronous</code> 的，也就是從上到下一次執行一列程式碼並依序執行，但 JavaScript 是一個 “非同步” <code>asynchronous</code> 的語言，因為其含有許多非同步的事件，避免因為其中一列程式碼卡住就影響其他程式碼和渲染</p><h2 id="堆疊-stack-與-佇列-queue"><a href="#堆疊-stack-與-佇列-queue" class="headerlink" title="堆疊 stack 與 佇列 queue"></a>堆疊 stack 與 佇列 queue</h2><p>JavaScript 是一個單線程 <code>single threaded</code> 的程式語言，所有程式碼都會依序在堆疊 <code>stack</code> 中執行，而且一次只會執行一列程式碼</p><h3 id="堆疊-stack"><a href="#堆疊-stack" class="headerlink" title="堆疊 stack"></a>堆疊 stack</h3><p>堆疊 <code>stack</code> 是 “後進先出” 的方式，在 JavaScript 中會記錄當下執行到哪段程式碼，如果進入一個函式，就會將該函式放到堆疊的最上方，在執行到 <code>return</code> 或結尾時將該函式從堆疊最上方抽離</p><h3 id="佇列-queue"><a href="#佇列-queue" class="headerlink" title="佇列 queue"></a>佇列 queue</h3><p>佇列 <code>queue</code> 是先進先出的方式，也是 javascript 能進行非同步的關鍵，所有的 “事件”、<code>Http request</code> 都會依照觸發順序被加入到 “佇列” <code>queue</code> 中，等到 “堆疊” <code>stack</code> 內是空的時，就會將佇列中的第一個物件加入到堆疊中開始依序執行</p><h3 id="JavaScript-執行非同步事件-asynchronous-callback"><a href="#JavaScript-執行非同步事件-asynchronous-callback" class="headerlink" title="JavaScript 執行非同步事件 asynchronous callback"></a>JavaScript 執行非同步事件 asynchronous callback</h3><ol><li>首先建立了一個函式 <code>waitThreeSeconds</code> ，這個函式透過 <code>while</code> 來延遲 3 秒出現 <code>finished function</code> 字串</li><li>接著添加了一個事件監聽器 <code>EventListener</code>，當點擊滑鼠時會出現 <code>click event</code> 字串</li><li>在程式執行的一開始我們就透過點擊來觸發事件</li><li>結果是 <code>started execution</code> 最先出現</li><li>3 秒後出現接著 <code>finished function 和 finished execution</code></li><li>最後才是我們點擊所觸發的 <code>click event</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitThreeSeconds</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ms = <span class="number">3000</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() &lt; ms)&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;finished function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;click event!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;started execution&quot;</span>);</span><br><span class="line">waitThreeSeconds();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;finished execution&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// started execution</span></span><br><span class="line"><span class="comment">// finished function </span></span><br><span class="line"><span class="comment">// finished execution</span></span><br><span class="line"><span class="comment">// click event</span></span><br></pre></td></tr></table></figure><p>從以上範例可以驗證 JavaScript 中會先依序執行完堆疊 <code>stack</code> 中的程式碼，才會執行 <code>queue</code> 中的點擊事件</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h3><p>當有一個以上的非同步事件，我們希望他們是透過安排好的順序依序執行時，最直覺的做法就是在事件執行完後 <code>callback</code> 下一個事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    b();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>看似沒有什麼問題，但是當使用大量的非同步事件又希望依照固定的順序執行時，就會出現以下經典圖，<code>callback hell</code></p><p><img src="callback-hell.png"></p><h3 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h3><p>為了解決以上同步與非同步的問題，ES6 開始新增了 promise 物件</p><p><code>promise</code> 顧名思義是承諾、約定的意思，其內函式的兩個參數分別為 <code>resolve</code> 傳遞成功訊息，<code>reject</code> 傳遞失敗訊息，以下為 <code>promise</code> 的三種狀態</p><ul><li><code>pending</code>: 一進入 promise 的初始等待狀態</li><li><code>fulfilled</code> : 表示操作成功的狀態</li><li><code>rejected</code> : 表示操作失敗的狀態</li></ul><p>以下圖片表示整個 promise 流程</p><p><img src="promise.png"></p><p>如果要解決上方的 <code>callback hell</code> ，可以使用 <code>then()</code> 來串接多個非同步事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a().then(b).then(c);</span><br></pre></td></tr></table></figure><p>除此之外，<code>then()</code> 可以用來接收成功的訊息，<code>catch()</code> 可以用來接收失敗的訊息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onePiece = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> choice = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;起跑&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(choice)&#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span> 抵達終點`</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">`<span class="subst">$&#123;name&#125;</span> 跌倒了...`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">onePiece(<span class="string">&#x27;跑得快&#x27;</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p><code>Promise.all()</code> 會 “同時執行” 以下的 <code>pormise</code>，並在完成後統一回傳陣列，這個陣列內容就是 <code>promise</code> 的 <code>resolve</code> 結果，但如果 <code>all()</code> 其中有任何一個事件 <code>reject</code>，那麼整個 <code>promise</code> 就會被視為 <code>reject</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([onePiece(<span class="string">&#x27;跑得快&#x27;</span>), onePiece(<span class="string">&#x27;電話蟲&#x27;</span>)]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p>而 <code>Promise.race()</code> 僅會回傳第一個完成的結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([onePiece(<span class="string">&#x27;跑得快&#x27;</span>), onePiece(<span class="string">&#x27;電話蟲&#x27;</span>)]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="asyne-與-await"><a href="#asyne-與-await" class="headerlink" title="asyne 與 await"></a>asyne 與 await</h3><p><code>asyne</code> 與 <code>await</code> 的配合也可以和 <code>promise</code> 達到相同的效果，在一個函式執行完後才會接著執行下一個</p><h4 id="async-非同步"><a href="#async-非同步" class="headerlink" title="async 非同步"></a><code>async</code> 非同步</h4><p><code>async</code> 又稱為非同步函式，用來包住 <code>await</code>，其用法類似 <code>Promise</code>，也可以在後方加上 <code>then()</code> 和 <code>catch()</code> 分別接收 <code>resolve</code> 和 <code>reject</code> 的結果</p><h4 id="await-等待"><a href="#await-等待" class="headerlink" title="await 等待"></a><code>await</code> 等待</h4><p>使用 <code>await</code> 會將後面的函式卡住，直到這個函式完成才會執行下一個函式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onePiece = <span class="function">(<span class="params">name, timer, success = <span class="literal">true</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span> 開始起跑`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(success)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span> 10 公分花了 <span class="subst">$&#123;timer / <span class="number">1000</span>&#125;</span> 秒`</span>);</span><br><span class="line">      &#125;, timer);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">`<span class="subst">$&#123;name&#125;</span> 跌倒了...`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> relay = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> mushi1 = <span class="keyword">await</span> onePiece(<span class="string">&#x27;電話蟲1&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> mushi2 = <span class="keyword">await</span> onePiece(<span class="string">&#x27;電話蟲2&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> Karoo = <span class="keyword">await</span> onePiece(<span class="string">&#x27;跑得快&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;mushi1&#125;</span>, <span class="subst">$&#123;mushi2&#125;</span>, <span class="subst">$&#123;Karoo&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">relay().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 電話蟲1 開始起跑</span></span><br><span class="line"><span class="comment">// 電話蟲2 開始起跑</span></span><br><span class="line"><span class="comment">// 跑得快 開始起跑</span></span><br><span class="line"><span class="comment">// 電話蟲1 10 公分花了 2 秒, 電話蟲2 10 公分花了 2 秒, 跑得快 10 公分花了 0.001 秒</span></span><br></pre></td></tr></table></figure><p>同樣的，如果其中有函式執行失敗 <code>reject</code>，就會執行失敗結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> relay = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> mushi1 = <span class="keyword">await</span> onePiece(<span class="string">&#x27;電話蟲1&#x27;</span>, <span class="number">2000</span>);</span><br><span class="line">  <span class="keyword">let</span> mushi2 = <span class="keyword">await</span> onePiece(<span class="string">&#x27;電話蟲2&#x27;</span>, <span class="number">2000</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">let</span> Karoo = <span class="keyword">await</span> onePiece(<span class="string">&#x27;跑得快&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;mushi1&#125;</span>, <span class="subst">$&#123;mushi2&#125;</span>, <span class="subst">$&#123;Karoo&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">relay().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 電話蟲1 開始起跑</span></span><br><span class="line"><span class="comment">// 電話蟲2 開始起跑</span></span><br><span class="line"><span class="comment">// 電話蟲2 跌倒了...</span></span><br></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://pjchender.blogspot.com/2016/01/javascriptasynchronousevent-queue.html">談談JavaScript中的asynchronous和event queue</a><br><a href="https://ithelp.ithome.com.tw/articles/10194569">同步與非同步</a><br><a href="https://ithelp.ithome.com.tw/articles/10194622">使用 Promise 處理非同步</a><br><a href="https://blog.kdchang.cc/2016/06/24/javascript-data-structure-algorithm-stack/">用 JavaScript 學習資料結構和演算法：堆疊（Stack）篇</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 物件與原型鍊</title>
      <link href="/javascript/20191105/49319/"/>
      <url>/javascript/20191105/49319/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 是一門 “物件導向” 的程式語言，但物件彼此是透過 “原型” 來繼承屬性，在介紹原型鍊之前，會先透過 “串聯” <code>Cascade</code> 與物件來了解背後的觀念</p><span id="more"></span><h2 id="Cascade-串聯"><a href="#Cascade-串聯" class="headerlink" title="Cascade 串聯"></a>Cascade 串聯</h2><p>在 javascript 的函式 function 中，如果沒有設定 <code>return</code> 的值，那麼預設就會回傳 <code>undefined</code>，而 <code>function</code> 中的 <code>this</code> 會指向 “呼叫這個函式的物件” ，如果將 <code>return</code> 的值設為 <code>this</code>，就可以達到串聯 <code>Cascade</code> 的方式，也是 <code>jQuery</code> 可以串聯許多方法背後的觀念</p><h3 id="一般寫法"><a href="#一般寫法" class="headerlink" title="一般寫法"></a>一般寫法</h3><p>以下為一個運算的範例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.num = num;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">newNum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.num += newNum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.sub = <span class="function"><span class="keyword">function</span>(<span class="params">newNum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.num -= newNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接著透過 <code>new</code> 來新增物件，要注意的是，如果沒有 <code>new</code>，該新增變數的值就會是函式 <code>count</code> 回傳的值，也就是預設的 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> count(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> b = count(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(typeOf(a));   <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(typeOf(b));   <span class="comment">// undefinde</span></span><br></pre></td></tr></table></figure><p>建立物件後，就可以呼叫物件內的函式，又稱為方法 <code>Method</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.add(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.num);   <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line">a.sub(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.num);   <span class="comment">// 150</span></span><br></pre></td></tr></table></figure><h3 id="Cascade-的方式"><a href="#Cascade-的方式" class="headerlink" title="Cascade 的方式"></a>Cascade 的方式</h3><p>一般的寫法如上，在呼叫物件中的多個方法 <code>Method</code> 時，需要個別呼叫 ; 如果將原物件中的方法都加上 <code>return this</code>，回傳 <code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span> num = num;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">newNum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.num += newNum;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.sub = <span class="function"><span class="keyword">function</span>(<span class="params">newNum</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.num -= newNum;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這時候就會發現可以將多個方法 <code>Method</code> 在一行程式碼一起呼叫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> count(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">a.add(<span class="number">100</span>).sub(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.num);   <span class="comment">// 150</span></span><br></pre></td></tr></table></figure><p>拆開來看的話，<code>a.add(100)</code> 在運算完後會 <code>return this</code>，其中 this 就是屬性 <code>num</code> 變成 <code>200</code> 的 <code>a</code> 物件，而不是預設的 <code>undefined</code>，所以就可以接著呼叫下一個方法 <code>Method</code></p><p>這就是 <code>jQuery</code> 常見的方法鍊</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).addClass(<span class="string">&#x27;is-active&#x27;</span>).removeClass(<span class="string">&#x27;is-hide&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="物件-Object"><a href="#物件-Object" class="headerlink" title="物件 Object"></a>物件 Object</h2><h3 id="型別-Type"><a href="#型別-Type" class="headerlink" title="型別 Type"></a>型別 Type</h3><p>在 javascript 中，主要區分為兩大型別，基本型別 <code>Primitives</code> 與 物件型別 <code>Object</code>，除了基本型別外，都可以歸類為物件型別</p><h4 id="基本型別"><a href="#基本型別" class="headerlink" title="基本型別"></a>基本型別</h4><ul><li>字串 <code>string</code></li><li>數字 <code>number</code></li><li>布林 <code>boolean</code></li><li>空值 <code>null</code></li><li>未定義 <code>undefined</code></li><li>ES6 新增的 <code>stymbol</code></li></ul><h3 id="自訂物件"><a href="#自訂物件" class="headerlink" title="自訂物件"></a>自訂物件</h3><p>在 javascript 中，有兩種方式可以自訂物件</p><ul><li><p>使用 <code>new</code> 關鍵字來建立</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">preson.name = <span class="string">&#x27;Jerry&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用大括號 <code>&#123; &#125;</code> 直接建立新物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;Jerry&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="建構式-Constructor"><a href="#建構式-Constructor" class="headerlink" title="建構式 Constructor"></a>建構式 Constructor</h3><p>javascript 不像其他物件導向的語言具有 <code>class</code> 語法，但可以透過建構式來建立各種對應的物件，要注意的是建構式是使用 “函式” <code>function</code> 來建立物件樣板，不能使用 <code>ES6</code> 的 “箭頭函式”</p><ul><li><p><code>function</code> 中的 <code>this</code> 代表物件的屬性</p></li><li><p>可以透過參數來傳入數值</p></li><li><p>使用關鍵字 <code>new</code> 來建立新物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name, age, gender </span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.gender = gender;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.greeting = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello!&#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Jerry = <span class="keyword">new</span> Person( <span class="string">&#x27;Jerry&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;male&#x27;</span> );</span><br><span class="line">Jerry.greeting();   <span class="comment">// &#x27;Hello! Jerry&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Tom = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line">Tom.greeting();   <span class="comment">// &#x27;Hello! Tom&#x27;</span></span><br></pre></td></tr></table></figure><p>將建構式拆開來看，其實是先建立一個空物件 <code>&#123; &#125;</code>，再透過 <code>call</code> 方法將 <code>this</code> 指向這個物件，並傳入參數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Jerry = &#123;&#125;;</span><br><span class="line">Person.call(Jerry, <span class="string">&#x27;Jerry&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;male&#x27;</span>);</span><br></pre></td></tr></table></figure><p>透過建構式建立的物件，還是可以透過 <code>.</code> 來存取屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Jerry.age);   <span class="comment">// 24</span></span><br><span class="line">Jerry.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Jerry.age);   <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="屬性描述器-Property-descriptor"><a href="#屬性描述器-Property-descriptor" class="headerlink" title="屬性描述器 Property descriptor"></a>屬性描述器 Property descriptor</h3><p>從 ES5 開始，我們可以透過新的物件模型來靠至物件屬性的存取、刪除、列舉等。這些特殊的屬性就稱為 “屬性描述器” <code>Property descriptor</code></p><p>屬性描述器分為六種 :</p><ul><li><code>value</code> : 屬性的值</li><li><code>writable</code> : 定義屬性是否可以改變，如果是 <code>false</code> 就是唯讀屬性</li><li><code>enumerable</code> : 定義屬性是否可以透過 <code>for-in</code> 語法來迭代</li><li><code>configurable</code> : 定義屬性是否可以被刪除、或修改屬性的 <code>writable</code>、<code>enumerable</code> 和 <code>configurable</code> 設定</li><li><code>get</code> : 屬性的 <code>getter function</code>，預設為 <code>undefined</code></li><li><code>set</code> : 屬性的 <code>setter function</code>，預設為 <code>undefined</code></li></ul><p>這些 “屬性描述器” 都必須透過 ES5的 <code>Object.defineProperty</code> 來處理</p><h4 id="定義屬性-Object-defineProperty-與-查詢屬性描述-Object-getOwnPropertyDescriptor"><a href="#定義屬性-Object-defineProperty-與-查詢屬性描述-Object-getOwnPropertyDescriptor" class="headerlink" title="定義屬性 Object.defineProperty 與 查詢屬性描述 Object.getOwnPropertyDescriptor"></a>定義屬性 <code>Object.defineProperty</code> 與 查詢屬性描述 <code>Object.getOwnPropertyDescriptor</code></h4><ul><li><p><code>Object.defineProperty(object, property, descriptor)</code> : 用來定義物件屬性的描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person, <span class="string">&#x27;name&#x27;</span>, &#123;<span class="attr">value</span>: <span class="string">&#x27;Jerry&#x27;</span>&#125;);</span><br><span class="line">              </span><br><span class="line"><span class="comment">// resault</span></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>當然也可以一次定義多個屬性描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.definedProperty(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>Object.getOwnPropertyDescriptor(Object, Property)</code> : 用來檢查物件屬性描述器的狀態</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(Person, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &#x27;Jerry&#x27;, writable: false, enumerable: false, configuarable: false&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>要注意的是，使用兩種物件屬性的定義方式在 <code>writable</code>、<code>enumerable</code> 和 <code>configurable</code> 這三種屬性描述器上會有不同的預設值，使用 <code>Object.definedProperty</code> 定義的物件屬性的預設值會是 <code>false</code>，直接定義物件的預設值則會是 <code>true</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// Jerry</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>));   </span><br><span class="line"><span class="comment">// &#123;value: &quot;Jerry&quot;, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">Person.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(Person.name);   <span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(Person, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123;value: &quot;Jerry&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><h4 id="屬性描述器-get-與-set"><a href="#屬性描述器-get-與-set" class="headerlink" title="屬性描述器 get 與 set"></a>屬性描述器 get 與 set</h4><p>我們可以透過 屬性描述器 <code>get</code> 與 <code>set</code> 來追蹤物件屬性的更新，以下範例透過屬性 <code>_name_</code> 來作為 <code>name</code> 屬性的封裝，物件屬性更新時會執行 <code>set</code>，讀取物件屬性則會執行 <code>get</code>，且在自定義 <code>get</code> 和 <code>set</code> 後，就無法再透過 <code>Object.defineProperty</code> 來更改屬性描述器，並將其他屬性描述器設定為 <code>false</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name_;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>._name_ = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">person.name = <span class="string">&quot;Jerry&quot;</span>;   <span class="comment">// set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); </span><br><span class="line"><span class="comment">// get  </span></span><br><span class="line"><span class="comment">// Jerry</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><h2 id="基本型別包裹器-Primitive-Wrapper"><a href="#基本型別包裹器-Primitive-Wrapper" class="headerlink" title="基本型別包裹器 Primitive Wrapper"></a>基本型別包裹器 Primitive Wrapper</h2><h3 id="物件型別"><a href="#物件型別" class="headerlink" title="物件型別"></a>物件型別</h3><p>上文提到，除了基本型別以外都可以歸類在物件型別，而在物件型別中，又可以細分為以下幾種 “建構器” <code>Constructor</code></p><ul><li>String()</li><li>Number()</li><li>Boolean()</li><li>Array()</li><li>Object</li><li>Function</li><li>RegExp</li><li>Date</li><li>Error</li><li>Symbol</li></ul><p>以上這些建構器都可以透過關鍵字 <code>new</code> 來建立對應的物件</p><h3 id="基本型別包裹器-Primitive-Wrapper-1"><a href="#基本型別包裹器-Primitive-Wrapper-1" class="headerlink" title="基本型別包裹器 Primitive Wrapper"></a>基本型別包裹器 Primitive Wrapper</h3><p>物件中的 “變數” 稱為 “屬性”，而物件中的 “函式” 稱為 “方法”，但在基本型別中卻有 “屬性” 和 “方法” 可以呼叫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.length);   <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase());   <span class="comment">// &#x27;HELLO&#x27;</span></span><br></pre></td></tr></table></figure><p>因為在存取字串 <code>String</code>、數字 <code>Number</code> 和布林 <code>Boolean</code> 的那一刻會被 “自動轉型” 為該類別的物件，這就是基本型別包裹器 <code>Primitive Wrapper</code></p><p>當我們在呼叫基本型別的屬性和方法時，背後的原理是透過對應的物件建構器包裝成 “物件”，再回傳對應的屬性後銷毀並回復成基本型別</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">str.length;</span><br><span class="line"></span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">str = <span class="string">&#x27;Hello&#x27;</span>;</span><br></pre></td></tr></table></figure><p>基本型別並沒有 “屬性” 和 “方法”，在設定完後仍會回傳 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(typeOf(str));   <span class="comment">// &quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(typeOf(strObj));   <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">str.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">strObj.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.color);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(strObj.color);   <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="物件與原型鍊-Object-amp-Prototype-Chain"><a href="#物件與原型鍊-Object-amp-Prototype-Chain" class="headerlink" title="物件與原型鍊 Object &amp; Prototype Chain"></a>物件與原型鍊 Object &amp; Prototype Chain</h2><p>JavaScript 是一門物件導向的程式語言，它的繼承方法是透過 “原型” <code>Prototype</code> 來操作</p><h3 id="原型鍊-Prototype-Chain"><a href="#原型鍊-Prototype-Chain" class="headerlink" title="原型鍊 Prototype Chain"></a>原型鍊 Prototype Chain</h3><p>原型繼承的基本概念就是讓沒有該屬性的物件去存取其他物件的屬性，原型物件是物件的內部屬性，無法直接存取，通常直接標示為 <code>[[prototype]]</code></p><h4 id="Object-setPrototypeOf-“繼承者”-“原型”"><a href="#Object-setPrototypeOf-“繼承者”-“原型”" class="headerlink" title="Object.setPrototypeOf(“繼承者”, “原型”)"></a>Object.setPrototypeOf(“繼承者”, “原型”)</h4><p>透過 <code>Object.setPrototypeOf()</code> 可以指定物件之間的原型關係，第一個參數為繼承者物件，第二個為要繼承的原型物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// &#x27;Jerry&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, person2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// &#x27;Jerry&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name);   <span class="comment">// &#x27;Jerry&#x27;</span></span><br></pre></td></tr></table></figure><p>延續上方範例，同一物件無法指定兩個原型物件，如果繼承超過一個原型物件，只會繼承最後一個</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = &#123;</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, age);</span><br><span class="line"><span class="built_in">console</span>.log(person.age);   <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>這時候就需要 “原型鍊” 的概念了，延續上方範例，先讓 <code>person2</code> 去繼承 <code>age</code>，再讓 <code>person</code> 繼承 <code>person2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = &#123;</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person2, age);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, person2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age);   <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">// &#x27;Jerry&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="最頂層原型物件-Object-prototype"><a href="#最頂層原型物件-Object-prototype" class="headerlink" title="最頂層原型物件 Object.prototype"></a>最頂層原型物件 Object.prototype</h3><p>當我們嘗試存取不存在的物件屬性時，就會自動往該物件的 “原型物件” <code>[[prototype]]</code> 去尋找，順著原型鍊一直找，直到 “最頂層原型物件” <code>Object.prototype</code></p><p>最頂層原型物件 <code>Object.prototype</code> 是所有物件的起源，我們以往呼叫卻未定義的 “方法” <code>Method</code> 就是透過 “原型鍊” 繼承自這個 “最頂層原型物件” <code>Object.prototype</code> 的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.hasOwnPrototype()</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString()</span><br><span class="line"><span class="built_in">Object</span>.prototype.valueOf()</span><br></pre></td></tr></table></figure><h3 id="建構式與原型"><a href="#建構式與原型" class="headerlink" title="建構式與原型"></a>建構式與原型</h3><p>因為函式也是物件的一種，所以也可以透過 <code>prototype</code> 來擴充每個透過這個函式所建構出來的物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi !&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p2);   <span class="comment">// Person &#123;sayHello: f&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.sayHello());   <span class="comment">// &quot;Hi !&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.sayHello());   <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>這裡一一解析以上的結果以釐清觀念</p><ul><li><code>p1</code>: 直接呼叫 <code>Person</code> 這個函式，所以就會是這個函式回傳的結果，因為沒有設定 return ，自然也就是預設的 undefined</li><li><code>p2</code>: 透過 <code>Person</code> 這個函式物件所建構出來的 “物件”</li><li><code>p2.sayHello()</code>: 函式被建立時，都會有原型物件，當我們透過這個函式建構一個新物件時，這個函式的原型物件就會被當作新物件的 “原型”</li><li><code>Person.sayHello()</code>: 因為 <code>Person</code> 本身是一個函式，所以並不會存取物件屬性</li></ul><p>如果新建構出來的物件實體和原型具有相同的 “屬性” 和 “方法” 時，會優先存取自己的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello !&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi !&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p);   <span class="comment">// Person &#123;sayHello: function ()&#123;return &quot;Hello !&quot;&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.sayHello);   <span class="comment">// &quot;Hello !&quot;</span></span><br></pre></td></tr></table></figure><h3 id="繼承判斷"><a href="#繼承判斷" class="headerlink" title="繼承判斷"></a>繼承判斷</h3><p>透過 <code>hasOwnProperty()</code> 可以判斷該屬性是物件本身所有還是繼承而來的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Jerry&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person;</span><br><span class="line"><span class="built_in">console</span>.log(p.name);   <span class="comment">// &quot;Jerry&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age);   <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(p.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="物件的-proto-屬性"><a href="#物件的-proto-屬性" class="headerlink" title="物件的 __proto__ 屬性"></a>物件的 <code>__proto__</code> 屬性</h3><p>從上方的 <a href="#%E5%BB%BA%E6%A7%8B%E5%BC%8F%E8%88%87%E5%8E%9F%E5%9E%8B">建構式與原型</a> 中可以知道，當透過函式建構出一個新的物件時，這個新物件的原型會自動指向函式的原型物件 <code>prototype</code></p><p>在 JavaScript 中，所有物件都有 <code>__proto__</code> 這個特殊屬性，這個屬性會指向這個物件的原型物件 ; 在 ES5 中，也可以透過 <code>Object.getPropertyOf()</code> 這個方法來取得物件的原型物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi! &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.sayHello());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(p) === Person.prototype);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(p) === <span class="built_in">Function</span>.prototype);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(Person) === <span class="built_in">Function</span>.prototype);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === <span class="built_in">Function</span>.prototype);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要注意的是，當一個函是被建立的時候，會產生一個 <code>prototype</code> 屬性，但 <code>prototype</code> “並非” 這個函式的原型物件，而是透過這個函式所建構的新物件才會將原型指向函式的 <code>prototype</code> 屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">sayHello</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.sayHello = sayHello;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.sayHello);   <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.sayHello);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="物件與原型繼承"><a href="#物件與原型繼承" class="headerlink" title="物件與原型繼承"></a>物件與原型繼承</h3><p>前面都是透過建構式來介紹，但直接透過物件來繼承是比較常見的做法</p><ul><li><p>第一種是上方所提到的 Object.setPropertyOf()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPropertyOf(p, Person);</span><br></pre></td></tr></table></figure></li><li><p>第二種是透過 <code>Object.create()</code> 來建立一個新物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi! &quot;</span> + <span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(Person);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.sayHello());   <span class="comment">// &quot;Hi! Jerry&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>而 <code>Object.create()</code> 背後的原理是將物件作為參數帶入，先建立一個新函式，再將這個函式的原型指向這個物件，最後回傳一個 <code>new</code> 的新物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">proto</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  F.prototype = proto;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proto-amp-prototype"><a href="#proto-amp-prototype" class="headerlink" title="proto &amp; prototype"></a><strong>proto</strong> &amp; prototype</h3><p>總結一下<code> __proto__</code> &amp; <code>prototype</code> 的關係，JavaScript 的內建物件 <code>Array``、Function</code> 等，這些物件的 <code>prototype</code> 屬性本身也是一個物件，而這些屬性實際上都是繼承自最頂層物件 <code>Object.prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Function</span>.prototype) === <span class="built_in">Object</span>.prototype);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由此可知下層物件的 <code>__proto__</code> 屬性都會指向上層物件的 <code>prototype</code> 屬性，這就是 JavaScript 的繼承關係</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://ithelp.ithome.com.tw/articles/10194154">物件與原型鏈</a><br><a href="https://chupainotebook.blogspot.com/2019/01/js.html">【克服 JS 】第四章（上）物件與函式</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 中的傳值與傳址</title>
      <link href="/javascript/20191105/30734/"/>
      <url>/javascript/20191105/30734/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 的變數再賦予不同型別的時候，會有同的傳遞方式，以 “基本型別” <code>Primitive</code> 和 “物件型別” <code>Object</code> 作為區分 </p><span id="more"></span><h2 id="型別-Types"><a href="#型別-Types" class="headerlink" title="型別 Types"></a>型別 Types</h2><h3 id="基本型別-Primitive-type"><a href="#基本型別-Primitive-type" class="headerlink" title="基本型別 Primitive type"></a>基本型別 Primitive type</h3><p>當宣告兩個變數並賦予相同的基本型別時，兩個變數的會是 “相等” 的，這似乎很直觀</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&quot;String&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="string">&quot;String&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a === b );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( c === d );   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="物件型別-Object-type"><a href="#物件型別-Object-type" class="headerlink" title="物件型別 Object type"></a>物件型別 Object type</h3><p>但是當宣告兩個變數並賦予相同屬性與值的物件時，兩個變數卻是 “不相等” 的，因為 javascript 中的物件可以看成是個別的 “實體”，兩個物件雖然可以看成 “等值”，但卻不是同一個 “實體”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log( obj1 === obj2 );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="傳值與傳址"><a href="#傳值與傳址" class="headerlink" title="傳值與傳址"></a>傳值與傳址</h2><ul><li>傳值 <code>pass by value</code> </li><li>傳址 <code>pass by reference</code></li></ul><h3 id="傳值-pass-by-value"><a href="#傳值-pass-by-value" class="headerlink" title="傳值 pass by value"></a>傳值 pass by value</h3><p>在基本型別的變數中，當我們複製變數時，取得的是原先變數的 “值”，而不是這個變數本身</p><p>因為當指定 <code>b</code> 的值等於 <code>a</code> 時，會建立一個新的記憶體來存放相同的值，彼此不會互相干擾，這種情況稱為 “傳值” <code>pass by value</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><img src="%E5%82%B3%E5%80%BC-1.png"></p><p>所以我們更改原先變數 <code>a</code> 的值時，並不會影響新變數 <code>b</code> 的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 100</span></span><br><span class="line">consolg.log(b);   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><img src="%E5%82%B3%E5%80%BC-2.png"></p><h3 id="傳址-pass-by-reference"><a href="#傳址-pass-by-reference" class="headerlink" title="傳址 pass by reference"></a>傳址 pass by reference</h3><p>當我們建立一個物件型別的變數 a 時，一樣會建立一個位置在記憶體中;但是當我們另建立一個變數 b 並賦予他的值等於 a，這時和基本型別不一樣的是，並不會建立一個新的位置在記憶體中，而是讓變數 b 指向和 a 同一個記憶體中的位置，稱為 “傳址” <code>pass by reference</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// &#123;value: 10&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// &#123;value: 10&#125;</span></span><br></pre></td></tr></table></figure><p><img src="%E5%82%B3%E5%9D%80-1.png"></p><p>所以當我們更改 <code>a</code> 的內容時，<code>b</code> 自然會跟著更改</p><p><img src="%E5%82%B3%E5%9D%80-2.png"></p><h3 id="例外情況"><a href="#例外情況" class="headerlink" title="例外情況"></a>例外情況</h3><p>有一些例外的情況透過傳值的方式複製物件，而複製又分為 “深度複製” <code>Deep copy</code> 和 “淺度複製” <code>Shallow copy</code>，”深度複製” 全部透過 “傳值” 的方式複製，而 “淺度複製” 只有 “第一層傳值”，內層還是 “傳址”</p><ul><li><p>重新賦值</p><p>凡事都有例外，當物件型別的變數被重新賦值時，就會在記憶體中產生一個新的位置來存放這個內容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">value</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"></span><br><span class="line">a = &#123;<span class="attr">value</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// &#123;value: 100&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// &#123;value: 10&#125;</span></span><br></pre></td></tr></table></figure><p><img src="%E5%82%B3%E5%80%BC%E8%88%87%E5%82%B3%E5%9D%80%E7%9A%84%E4%BE%8B%E5%A4%96.png"></p></li><li><p>手動賦值 (淺度複製)</p><p>手動賦值很直接的把 “物件傳址” 改用 “傳值” 的方式傳遞，傳值的部分就會完全獨立 ; 但要注意的是，”內層物件” 還是 “傳址”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">  bwh: &#123;</span><br><span class="line">    strength: <span class="number">34</span>,</span><br><span class="line">    agility: <span class="number">25</span>,</span><br><span class="line">    intelligence: <span class="number">96</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person2 = &#123;</span><br><span class="line">  name: Person.name, </span><br><span class="line">  bwh: Person.bwh,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">Person.bwh.strength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person2.name);   <span class="comment">// 還是 &quot;Jerry&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person2.bwh.strength);    <span class="comment">// 一起改成 0  </span></span><br></pre></td></tr></table></figure><ul><li>for…in (淺度複製)</li></ul><p>透過 for…in 將原本的物件屬性的值傳到新的物件</p><ul><li>轉字串</li></ul><p>將物件轉型成字串，再將字串轉回物件，兩個物件會 “完全無關”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(Person);</span><br><span class="line"><span class="keyword">var</span> P = <span class="built_in">JSON</span>.parse(Person);</span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">Person.bwh.strength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name);   <span class="comment">// 還是 &quot;Jerry&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.bwh.strength);    <span class="comment">// 還是 34</span></span><br></pre></td></tr></table></figure><ul><li>jQuery</li></ul><p>jQuery 中可以透過 <code>extend()</code> 來複製物件，可以透過更改第一個參數來調整深度或淺度複製</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = jQuery.extend(&#123;&#125;, Person);       <span class="comment">// 淺度複製</span></span><br><span class="line"><span class="keyword">var</span> p2 = jQuery.extend(<span class="literal">true</span>, &#123;&#125;, Person); <span class="comment">// 深度複製</span></span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">Person.bwh.strength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);   <span class="comment">// 還是 &quot;Jerry&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.bwh.strength);    <span class="comment">// 改成 0</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name);   <span class="comment">// 還是 &quot;Jerry&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.bwh.strength);    <span class="comment">// 還是 34</span></span><br></pre></td></tr></table></figure><ul><li>ES6</li></ul><p>在原生 JavaScript 中 ES6 也推出 <code>Object.assign()</code> 新的方法，但只適用於 “淺度複製”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Object</span>.assign(&#123;&#125;, Person);</span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">Person.bwh.strength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name);   <span class="comment">// 還是 &quot;Jerry&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.bwh.strength);    <span class="comment">// 改成 0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html">[筆記] 談談JavaScript中by reference和by value的重要觀念</a><br><a href="https://ithelp.ithome.com.tw/articles/10191057">JavaScript 是「傳值」或「傳址」？</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - 閉包 Closure</title>
      <link href="/javascript/20191024/33578/"/>
      <url>/javascript/20191024/33578/</url>
      
        <content type="html"><![CDATA[<p>閉包 <code>Closure</code> 是 JavaScript 中一種透過函式包住函式的技巧，透過這種技巧可以避免函式中的變數汙染到全域，而出現相同變數名稱互相干擾的情況</p><span id="more"></span><h2 id="範圍鏈-Scope-Chain"><a href="#範圍鏈-Scope-Chain" class="headerlink" title="範圍鏈 Scope Chain"></a>範圍鏈 Scope Chain</h2><p>了解閉包前，先來了解範圍鏈的概念 ; 切分變數有效範圍的最小單位是 <code>function</code>，所以當 <code>function</code> 在自己的層級找不到變數時，就會一層一層往外找，直到全域範圍 <code>Global Environment</code>，這種行為就稱為 “範圍鏈” <code>Scope Chain</code></p><p>從以下範例可以看到在當個層級中找不到變數，所以一層一層往外找，直到全域範圍</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">funcion outer ()&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);   <span class="comment">// 1 2 6</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><h2 id="閉包-Closure"><a href="#閉包-Closure" class="headerlink" title="閉包 Closure"></a>閉包 Closure</h2><p>先了解範圍鏈的原因在於充分理解作用域之後，就能理解為什麼要使用閉包的概念</p><h3 id="什麼是閉包"><a href="#什麼是閉包" class="headerlink" title="什麼是閉包 ?"></a>什麼是閉包 ?</h3><ul><li>呼叫函式中的函式</li><li>內層函式中的變數不會汙染到全域</li><li>內層函式的變數可以在內部重複使用，不被釋放到全域</li><li>內層函式可以記錄當時的變數值</li></ul><h3 id="沒有使用閉包的情況"><a href="#沒有使用閉包的情況" class="headerlink" title="沒有使用閉包的情況"></a>沒有使用閉包的情況</h3><p>以下透過常見的 “計數器” 來了解閉包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( count() );   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( count() );   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log( count() );   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>一個全域變數的宣告似乎沒什麼問題，但是當多人協作或是自己在多行程式碼後又建立一個計數器來記錄時，就容易發生變數名稱相同的衝突</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countDog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行程式碼後</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countCat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( countDog() );   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log( countDog() );   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log( countCat() );   <span class="comment">// 3   預期是 1 </span></span><br></pre></td></tr></table></figure><h3 id="閉包寫法"><a href="#閉包寫法" class="headerlink" title="閉包寫法"></a>閉包寫法</h3><p>透過閉包的概念，使上述範例中各自的變數 <code>count</code> 成為區域變數，並將真正要執行的函式放到內層，藉由 <code>return</code> 回傳後呼叫外層函式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogsHouse</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&#x27;dogs&#x27;</span> );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catsHouse</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countCats</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&#x27;cats&#x27;</span> );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> countCats</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dogCounter = dogsHouse();</span><br><span class="line"><span class="keyword">const</span> catCounter = catsHouse();</span><br><span class="line">dogCounter();   <span class="comment">// 1 dogs</span></span><br><span class="line">dogCounter();   <span class="comment">// 2 dogs</span></span><br><span class="line">catCounter();   <span class="comment">// 1 cats</span></span><br><span class="line">catCounter();   <span class="comment">// 2 cats</span></span><br></pre></td></tr></table></figure><h3 id="進一步使用閉包"><a href="#進一步使用閉包" class="headerlink" title="進一步使用閉包"></a>進一步使用閉包</h3><p>即使將函式賦予不同的宣告變數，彼此都是獨立執行不會互相干擾</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogsHouse</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&#x27;dogs&#x27;</span> );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> l = dogsHouse();</span><br><span class="line"><span class="keyword">const</span> m = dogsHouse();</span><br><span class="line"><span class="keyword">const</span> s = dogsHouse();</span><br><span class="line"></span><br><span class="line">l();   <span class="comment">// 1dogs</span></span><br><span class="line">l();   <span class="comment">// 2dogs</span></span><br><span class="line">m();   <span class="comment">// 1dogs</span></span><br><span class="line">m();   <span class="comment">// 2dogs</span></span><br><span class="line">s();   <span class="comment">// 1dogs</span></span><br><span class="line">s();   <span class="comment">// 2dogs</span></span><br></pre></td></tr></table></figure><h3 id="將參數帶入閉包"><a href="#將參數帶入閉包" class="headerlink" title="將參數帶入閉包"></a>將參數帶入閉包</h3><p>還可以將參數帶入閉包，使每個變數回傳不同結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogsHouse</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countDogs</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&#x27; &#x27;</span> + s );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> countDogs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> l = dogsHouse(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> m = dogsHouse(<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> s = dogsHouse(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line"></span><br><span class="line">l();   <span class="comment">// 1 l</span></span><br><span class="line">l();   <span class="comment">// 2 l</span></span><br><span class="line">m();   <span class="comment">// 1 m</span></span><br><span class="line">m();   <span class="comment">// 2 m</span></span><br><span class="line">s();   <span class="comment">// 1 s</span></span><br><span class="line">s();   <span class="comment">// 2 s</span></span><br></pre></td></tr></table></figure><h3 id="簡化程式碼"><a href="#簡化程式碼" class="headerlink" title="簡化程式碼"></a>簡化程式碼</h3><p>在閉包運用中，都會回傳 <code>return</code> 內層的函式，這時就可以簡化成 <code>return</code> 後面直接接上 “匿名函式”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dogsHouse</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&#x27; &#x27;</span> + s );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catsHouse</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&#x27; &#x27;</span> + s );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而透過上方的 “進一步使用閉包”，將函式賦予到不同變數上，再透過不同參數加以區分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&#x27;&#x27;</span> + s );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dogCounter = counter(<span class="string">&#x27;dogs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> catCounter = counter(<span class="string">&#x27;cats&#x27;</span>);</span><br><span class="line">dogCounter();   <span class="comment">// 1 dogs</span></span><br><span class="line">catCounter();   <span class="comment">// 1 cats</span></span><br><span class="line">dogCounter();   <span class="comment">// 2 dogs</span></span><br><span class="line">catCounter();   <span class="comment">// 2 cats</span></span><br></pre></td></tr></table></figure><h3 id="ES6-寫法"><a href="#ES6-寫法" class="headerlink" title="ES6 寫法"></a>ES6 寫法</h3><p>透過 ES6 使函式更精簡</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter =  <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( count + <span class="string">&quot; &quot;</span> + s );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10193009">重新認識 JavaScript: Day 19 閉包 Closure</a><br><a href="https://ithelp.ithome.com.tw/articles/10191515">另一種方式介紹 JavaScript 閉包</a><br><a href="https://pjchender.blogspot.com/2017/05/javascript-closure.html">深入淺出瞭解 JavaScript 閉包（closure）</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 中的 this</title>
      <link href="/javascript/20191024/42922/"/>
      <url>/javascript/20191024/42922/</url>
      
        <content type="html"><![CDATA[<ul><li><code>this</code> 是 JavaScript 中的一個關鍵字</li><li><code>this</code> 是 <code>function</code> 執行時，自動生成的一個內部物件</li><li>隨著執行的場合不同， <code>this</code> 所指向的值也會有所不同</li><li>影響 <code>this</code> 的是 “函式的呼叫方法”，而非函式宣告的時機</li></ul><span id="more"></span><p>大多數情況 <code>this</code> 就代表 “呼叫函式 <code>function</code> 的物件”</p><h2 id="直接呼叫"><a href="#直接呼叫" class="headerlink" title="直接呼叫"></a>直接呼叫</h2><p>如果是直接呼叫函式，此函式中的 <code>this</code> 都會指向 <code>window</code>，即使是在 <code>function</code> 中的 <code>function</code> 也是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">&#x27;我是全域&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);   <span class="comment">// &#x27;我是全域&#x27;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callName2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);   <span class="comment">// 我是全域</span></span><br><span class="line">  &#125;</span><br><span class="line">  callName2();</span><br><span class="line">&#125;</span><br><span class="line">callName();</span><br></pre></td></tr></table></figure><h2 id="物件呼叫"><a href="#物件呼叫" class="headerlink" title="物件呼叫"></a>物件呼叫</h2><p>如果函式 <code>function</code> 是在物件下呼叫，函式中的 <code>this</code> 就會指向該物件，無論 <code>function</code> 是在那裡宣告</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;我是全域&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);   <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  name: <span class="string">&#x27;我是區域&#x27;</span>,</span><br><span class="line">  callName2: callName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callName();         <span class="comment">// &#x27;我是全域&#x27; </span></span><br><span class="line">test.callName2();   <span class="comment">// &#x27;我是區域</span></span><br></pre></td></tr></table></figure><p>如果將物件內的 <code>function</code> 賦予到變數上並呼叫，這個 <code>this</code> 就會指向全域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">callName3 = test.callName2;</span><br><span class="line">callName3();    <span class="comment">// &#x27;我是全域&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="DOM-元素呼叫"><a href="#DOM-元素呼叫" class="headerlink" title="DOM 元素呼叫"></a>DOM 元素呼叫</h2><p>透過 DOM 元素的事件監聽來呼叫 <code>function</code>，此 <code>function</code> 中的 <code>this</code> 就會指向該 DOM 元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>我是 DOM 元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">// &lt;p class=&quot;test&quot;&gt;我是 DOM 元素&lt;/p&gt;</span></span><br><span class="line">&#125;;</span><br><span class="line">              </span><br><span class="line">list.addEventListener(<span class="string">&#x27;click&#x27;</span>, test);</span><br></pre></td></tr></table></figure><h2 id="建構式呼叫"><a href="#建構式呼叫" class="headerlink" title="建構式呼叫"></a>建構式呼叫</h2><p>在建構式下會使用 <code>new</code> 來生成一個新物件( 物件被建構出來 )，而 <code>function</code> 中的 <code>this</code> 會指向這個物件，而且可以在生成的物件上重新定義</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;我是全域&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span> (<span class="params">newName</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = newName || <span class="string">&#x27;我是區域&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callName2 = <span class="keyword">new</span> callName(<span class="string">&#x27;我是新的區域&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> callName3 = <span class="keyword">new</span> callName();</span><br><span class="line"><span class="built_in">console</span>.log(callName2.name);   <span class="comment">// 我是新的區域</span></span><br><span class="line"><span class="built_in">console</span>.log(callName3.name);   <span class="comment">// 我是區域</span></span><br></pre></td></tr></table></figure><h2 id="內建函式來呼叫"><a href="#內建函式來呼叫" class="headerlink" title="內建函式來呼叫"></a>內建函式來呼叫</h2><p>透過內建函式 <code>call</code>、<code>bind</code>、<code>apply</code> 來呼叫函式，第一個參數會成為這個函式的 <code>this</code>，只是這三個內建函式在使用時機上有所不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;我是全域&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">callName();   <span class="comment">// &#x27;我是全域&#x27;</span></span><br><span class="line">callName.call(&#123;<span class="attr">name</span>: <span class="string">&#x27;我是區域&#x27;</span>&#125;);   <span class="comment">// &#x27;我是區域&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="重新指向-this"><a href="#重新指向-this" class="headerlink" title="重新指向 this"></a>重新指向 this</h2><p>在實際操作時，遇到 “立即函式” IIFE 或 “非同步事件” 如 <code>setTimeout</code>，<code>this</code> 大多會指向 全域 <code>window</code>，如果要調用的是物件本身，可以先設定一個變數指向這個物件，再將這個變數帶入函式中</p><p>常見的變數名稱有 <code>that</code>、<code>vm</code>、<code>self</code> 等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;我是全域&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);     <span class="comment">// 我是區域</span></span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);   <span class="comment">// 我是全域</span></span><br><span class="line">    <span class="built_in">console</span>.log(that.name);   <span class="comment">// 我是區域</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  name: <span class="string">&#x27;我是區域&#x27;</span>,</span><br><span class="line">  callName2: callName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.callName2();</span><br></pre></td></tr></table></figure><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ul><li>如果 <code>function</code> 是透過物件來呼叫，那麼其中的 <code>this</code> 就會指向該物件</li><li>如果 <code>function</code> 是透過 DOM 元素的事件監聽來呼叫，那麼其中的 <code>this</code> 就會指向該 DOM 元素</li><li>如果 <code>function</code> 是透過建構式 <code>new</code> 生成的物件來呼叫，那麼其中的 <code>this</code> 就會指向該物件</li><li>如果 <code>function</code> 是透過內建函式 <code>call</code>、<code>apply</code>、<code>bind</code> 來呼叫，那麼其中的 <code>this</code> 就會指向內建函式的第一個參數</li><li>如果沒有滿足以上條件，那麼 <code>function</code> 的 <code>this</code> 就會指向全域物件 <code>window</code></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/articles/10193193">What’s “THIS” in JavaScript</a><br><a href="https://ithelp.ithome.com.tw/articles/10191393">JavaScript 的 this 到底是誰？</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - class 建構式語法糖</title>
      <link href="/javascript/20191023/6199/"/>
      <url>/javascript/20191023/6199/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 與其他物件導向的語言不太一樣，是以 “原型” <code>prototype</code> 為基礎的物件導向，ES6 新增了 <code>class</code> 這個語法糖 <code>syntactical sugar</code>，使得原型的建構更簡潔好閱讀</p><span id="more"></span><p>以下列出 <code>class</code> 與原先建構原型的差異</p><h2 id="class-用法"><a href="#class-用法" class="headerlink" title="class 用法"></a>class 用法</h2><ul><li><code>function</code> 改成 <code>class</code></li><li>初始化的物件屬性都寫在 <code>constructor()</code> 內，一個 <code>class</code> 只能有一個 <code>constructor</code></li><li>原型的 “方法” 也可以一併寫在 <code>class</code> 內</li></ul><p>以下先列出 ES6 以前的寫法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strawHat</span>(<span class="params">name, position, devilFruit</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.position = position;</span><br><span class="line">  <span class="built_in">this</span>.devilFruit = devilFruit || <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">strawHat.prototype.capability = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.devilFruit)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 是能力者`</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 不是能力者`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">strawHat.prototype.defeat = <span class="function"><span class="keyword">function</span> (<span class="params">person</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> k.o <span class="subst">$&#123;person&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Luffy = <span class="keyword">new</span> strawHat(<span class="string">&#x27;魯夫&#x27;</span>, <span class="string">&#x27;船長&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> zoro = <span class="keyword">new</span> strawHat(<span class="string">&#x27;索隆&#x27;</span>, <span class="string">&#x27;戰鬥員&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">Luffy.capability();   <span class="comment">// 魯夫 是能力者</span></span><br><span class="line">zoro.defeat(<span class="string">&#x27;卡古&#x27;</span>);   <span class="comment">// 索隆 k.o 卡古</span></span><br></pre></td></tr></table></figure><p>將上述範例換成 ES6 寫法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strawHat</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, position, devilFruit</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="built_in">this</span>.devilFruit = devilFruit || <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  capability ()&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.devilFruit)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 是能力者`</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 不是能力者`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  defeat (person)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> k.o <span class="subst">$&#123;person&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="靜態方法-static"><a href="#靜態方法-static" class="headerlink" title="靜態方法 static"></a>靜態方法 static</h2><p>靜態方法 <code>static</code> 是原型專屬的方法，不會繼承到新物件上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">strawHat</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, position, devilFruit</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">    <span class="built_in">this</span>.devilFruit = devilFruit || <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  capability ()&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.devilFruit)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 是能力者`</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 不是能力者`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> solgan  ()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我要成為海賊王 !`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zoro.solgan();   <span class="comment">// Error</span></span><br><span class="line">strawHat.solgan();  <span class="comment">// 我要成為海賊王 !</span></span><br></pre></td></tr></table></figure><h2 id="屬性的-get-amp-set-方法"><a href="#屬性的-get-amp-set-方法" class="headerlink" title="屬性的 get &amp; set 方法"></a>屬性的 get &amp; set 方法</h2><p>在 ES6 的 <code>class</code> 也可以一併將屬性的 讀入 <code>set</code> 和 “傳出” <code>get</code></p><ul><li><code>set</code> : 只能傳入一個參數，這個參數就是讀入的屬性值，通常都會加上下底線 <code>_</code> 將屬性值進行 “封裝”</li><li><code>get</code> : 用來回傳 <code>set</code> 封裝好的屬性值</li></ul><p>所以如果只有 <code>get</code> 就無法將屬性值修改，而只有 <code>set</code> 則是修改後無法回傳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, position</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.position = position;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get name ()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>._name = <span class="string">`我是 <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoro = <span class="keyword">new</span> Person;</span><br><span class="line"></span><br><span class="line">zoro.name = <span class="string">&#x27;索隆&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name);   <span class="comment">// 我是索隆</span></span><br></pre></td></tr></table></figure><h2 id="extends-擴增原型"><a href="#extends-擴增原型" class="headerlink" title="extends 擴增原型"></a>extends 擴增原型</h2><p>當我們以這個物件為原型建立了許多新物件，其中有新物件想要修改屬性或是新增方法，但又不希望影響到其他的新物件，這時候我們就可以透過 <code>extends</code> 來擴增新的原型，有點像是 <code>git</code> 建立分支的概念</p><ul><li><code>extends</code> : 用來指定要繼承的原型</li><li><code>super</code> : 要沿用的屬性可以放在這裡</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">slogan</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, position</span>)&#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.position = <span class="string">`位置 : <span class="subst">$&#123;position&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  solgan ()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我要成為海賊王&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoro = <span class="keyword">new</span> person(<span class="string">&#x27;索隆&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> Luffy = <span class="keyword">new</span> slogan(<span class="string">&#x27;魯夫&#x27;</span>, <span class="string">&#x27;船長&#x27;</span>);</span><br><span class="line">Luffy.solgan();   <span class="comment">// 我要成為海賊王</span></span><br><span class="line">zoro.solgan();   <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 陣列方法</title>
      <link href="/javascript/20191023/25937/"/>
      <url>/javascript/20191023/25937/</url>
      
        <content type="html"><![CDATA[<p>ES6 以前在處理陣列都是使用 <code>for</code> 迴圈，以陣列元素的數量來設定 <code>for 迴圈</code> 的次數，ES6 新增了許多方法來搭配 箭頭函式 <code>=&gt;</code>、樣板字串 <code>template-string</code> 使程式碼更精簡、直覺</p><span id="more"></span><p>以下是以往處理陣列中的資料時，透過 <code>for 迴圈</code> 一一取出資料的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wanted = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;魯夫&#x27;</span>,</span><br><span class="line">    price: <span class="number">15</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;索隆&#x27;</span>,</span><br><span class="line">    price: <span class="number">3.2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;香吉士&#x27;</span>,</span><br><span class="line">    price: <span class="number">3.3</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; wanted.length; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( wanted[i].name + <span class="string">&#x27; 懸賞 &#x27;</span> + wanted[i].price + <span class="string">&#x27; 億貝利&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 魯夫 懸賞 15 億貝利</span></span><br><span class="line"><span class="comment">// 索隆 懸賞 3.2 億貝利</span></span><br><span class="line"><span class="comment">// 香吉士 懸賞 3.3 億貝利</span></span><br></pre></td></tr></table></figure><p>而 jQuery 當然也有對應的方法來處理陣列，就是 <code>$.each(array, function(index, item)&#123;&#125;)</code>，結果同上</p><ul><li><code>array</code> : 要帶入的陣列</li><li><code>index</code> : 索引</li><li><code>item</code> : 陣列中的元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.each(wanted, <span class="function"><span class="keyword">function</span> (<span class="params">i, person</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person.name + <span class="string">&#x27; 懸賞 &#x27;</span> + person.price + <span class="string">&#x27; 億貝利&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以下一一介紹 ES6 所新增的陣列方法</p><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p>ES6 的 <code>array.forEach((item, index, array) =&gt; &#123;&#125;)</code> 和 jQuery 的方法很類似，只是帶入的參數位置不太一樣，以下範例同時加入 “箭頭函式” 和 “樣板字串”</p><ul><li><code>item</code> : 陣列中的元素</li><li><code>index</code> : 索引</li><li><code>array</code> : 整個陣列，也較少用到</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wanted.forEach(<span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> 懸賞 <span class="subst">$&#123;person.price&#125;</span> 億貝利`</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line"></span><br><span class="line">魯夫 懸賞 <span class="number">15</span> 億貝利</span><br><span class="line">索隆 懸賞 <span class="number">3.2</span> 億貝利</span><br><span class="line">香吉士 懸賞 <span class="number">3.3</span> 億貝利</span><br></pre></td></tr></table></figure><h3 id="無法被中斷"><a href="#無法被中斷" class="headerlink" title="無法被中斷"></a>無法被中斷</h3><p><code>forEach()</code> 無法被中斷，如果加入 <code>break</code> 會出現錯誤 <code>Error</code>，所以如果需要中斷還是要使用 <code>for 迴圈</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wanted.forEach(<span class="function"><span class="params">person</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.price &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> 懸賞 <span class="subst">$&#123;person.price&#125;</span> 億貝利`</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="無法使用的陣列"><a href="#無法使用的陣列" class="headerlink" title="無法使用的陣列"></a>無法使用的陣列</h3><p>在物件中，有許多物件有著陣列的外觀但不能使用陣列的所有方法稱為 “類陣列” <code>Array-like</code>，其中有部分的類陣列 “不能” 使用 <code>forEach()</code></p><ul><li><code>arguments</code> : 無法使用 <code>forEach()</code>，會跳錯</li><li><code>DOM 陣列</code> : 可以使用 <code>forEach()</code></li></ul><p>判斷物件是否有指定的方法可以從 <code>console</code> 中的原型 <code>__proto__</code> 來查看</p><p><img src="forEach.png"></p><h3 id="不會回傳"><a href="#不會回傳" class="headerlink" title="不會回傳"></a>不會回傳</h3><p>在 <code>forEach()</code> 中不會有回傳值，所以將其賦予一個變數會得到 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forEachReturn = wanted.forEach(<span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> 懸賞 <span class="subst">$&#123;person.price&#125;</span> 億貝利`</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(forEachReturn);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p>顧名思義 <code>filter()</code> 可以用來過濾陣列中符合條件的元素，但並不會對元素進行修改，將條件寫在 <code>return</code> 中就會回傳，如果沒有設定條件就會回傳空陣列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filterEmpty = wanted.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filterEmpty);   <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filter = wanted.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.price &gt; <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filter);   <span class="comment">// [&#123;name: &#x27;魯夫&#x27;, price: 15]</span></span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h2><p>用來搜尋陣列中符合條件的物件，但 “只能有一個”，如果符合條件的物件大於一個，就只會回傳第一個 ; 同樣的，如果沒有設定條件就會回傳 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findEmpty = wanted.find(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(findEmpty);   <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> find = wanted.find(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.price &lt; <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line">          </span><br><span class="line"><span class="built_in">console</span>.log(find);   <span class="comment">// [&#123;name: &#x27;索隆&#x27;, price: 3.2&#125;]</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p><code>map()</code> 與 <code>forEach</code> 最大的不同就是可以回傳新陣列，並透過新的變數來接收，如下範例因為是透過展開 <code>...</code> 賦值，所以兩個陣列並沒有任何關聯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newWanted = people.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...item,</span><br><span class="line">    newPrice: item.price + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newPeople);</span><br><span class="line">[</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&quot;魯夫&quot;</span>, <span class="attr">price</span>: <span class="number">15</span>, <span class="attr">newPrice</span>: <span class="number">16</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&quot;索隆&quot;</span>, <span class="attr">price</span>: <span class="number">3.2</span>, <span class="attr">newPrice</span>: <span class="number">4.2</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">&quot;香吉士&quot;</span>, <span class="attr">price</span>: <span class="number">3.3</span>, <span class="attr">newPrice</span>: <span class="number">4.3</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>回傳的新陣列與原陣列長度相同，不符合的物件會出現 <code>undeined</code>，如果沒有寫 <code>return</code> 還是全部都會回傳 <code>undefined</code>，所以如果要過濾元素，就不適合使用 <code>map</code>，<code>map</code> 適合單純調整元素的內容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapEmpty = wanted.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mapEmpty);   <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapAdd = wanted.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.price = item.price + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mapAdd);   [<span class="number">16</span>, <span class="number">4.2</span>, <span class="number">4.3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapTenUp = wanted.map(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item.price &gt; <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">          </span><br><span class="line"><span class="built_in">console</span>.lgo(mapTenUp);   <span class="comment">// [&#123;name: &#x27;魯夫&#x27;, price: 15&#125;, undefined, undefined]</span></span><br></pre></td></tr></table></figure><h2 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h2><p>用來驗證全部的結果</p><ul><li>如果全部為 <code>true</code>，回傳 <code>true</code></li><li>如果有一為 <code>false</code>，回傳 <code>false</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tenUp = wanted.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.price &gt; <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tenUp);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> threeUp = wanted.every(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.price &gt; <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(threeUp);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h2><p>同樣用來驗證全部結果，但條件與 <code>every()</code> 不一樣</p><ul><li>只要有一為 <code>true</code>，回傳 <code>true</code></li><li>如果全部為 <code>false</code>，回傳 <code>false</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tenUp = wanted.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.price &gt; <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tenUp);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> threeDown = wanted.some(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item.price &lt; <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(threeDown);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><p><code>reduce()</code> 是 ES6 陣列方法當中最特別的一個，其參數函先前的方法不一樣，他會將前一個回傳的值和下一個物件再做計算，很適合用在累加上，該方法可以拆解成以下方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4);</span><br></pre></td></tr></table></figure><ul><li><code>previousValue</code> : 前一個參數，如果是第一個元素，那這個值就是另外傳入或初始化的值</li><li><code>currentValue</code> : 當下這個參數</li><li><code>index</code> : 當下這個索引</li><li><code>array</code> : 整個陣列</li><li><code>initialValue</code> : 初始化的值</li></ul><p>同樣的，如果沒有回傳結果會是 <code>undefined</code>，其中 <code>0</code> 就是 <code>initialValue</code></p><h3 id="加總"><a href="#加總" class="headerlink" title="加總"></a>加總</h3><p>加總是 <code>reduce</code> 很常用到的技巧，只要將前一個值與當下的值相加，就會得到加總</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wanted = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;魯夫&#x27;</span>,</span><br><span class="line">    price: <span class="number">15</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;索隆&#x27;</span>,</span><br><span class="line">    price: <span class="number">3.2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;香吉士&#x27;</span>,</span><br><span class="line">    price: <span class="number">3.3</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reduceEmpty = wanted.reduce(<span class="function">(<span class="params">previousValue, currentValue, currentIndex, array</span>) =&gt;</span> &#123;&#125;, initialValue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reduceEmpty);   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reduce = wanted.reduce(<span class="function">(<span class="params">previousValue, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(previousValue, currentValue.price, currentIndex);</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue.price;   <span class="comment">// 21.5</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reduce);   </span><br><span class="line"><span class="comment">// 0 15 0 </span></span><br><span class="line"><span class="comment">// 15 3.2 1 </span></span><br><span class="line"><span class="comment">// 18.2 3.3 2</span></span><br></pre></td></tr></table></figure><h3 id="取最大值"><a href="#取最大值" class="headerlink" title="取最大值"></a>取最大值</h3><p><code>reduce</code> 是前一個值與當下的值不斷循環，所以透過 <code>max</code> 取較大值就可以取得最大值，同理最小值 <code>min</code> 也可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxPrice = wanted.reduce(<span class="function">(<span class="params">pre, cur, i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(pre, cur.price);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maxPrice);   <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 解構賦值 deconstructing</title>
      <link href="/javascript/20191023/13442/"/>
      <url>/javascript/20191023/13442/</url>
      
        <content type="html"><![CDATA[<p>過去陣列和物件內的元素在賦值時，都是透過一一給值的方式達成，在 ES6 中，可以透過解構的方式一次賦值，有效減少程式碼</p><span id="more"></span><h2 id="陣列解構賦值-Array-deconstructing"><a href="#陣列解構賦值-Array-deconstructing" class="headerlink" title="陣列解構賦值 Array deconstructing"></a>陣列解構賦值 Array deconstructing</h2><p>以往陣列賦值都是直接給值如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onePiece = [<span class="string">&quot;魯夫&quot;</span>, <span class="string">&quot;索隆&quot;</span>, <span class="string">&quot;娜美&quot;</span>, <span class="string">&quot;香吉士&quot;</span>, <span class="string">&quot;騙人布&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> captain = onePiece[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> fighter = onePiece[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(captain);   <span class="comment">// 魯夫</span></span><br></pre></td></tr></table></figure><h3 id="ES6-一般用法"><a href="#ES6-一般用法" class="headerlink" title="ES6 一般用法"></a>ES6 一般用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [captain, fighter, navigator, chef, sniper] = onePiece;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(captain);   <span class="comment">// 魯夫</span></span><br></pre></td></tr></table></figure><h3 id="輸入的變數量-“少於”-給得值或遇到空變數"><a href="#輸入的變數量-“少於”-給得值或遇到空變數" class="headerlink" title="輸入的變數量 “少於” 給得值或遇到空變數"></a>輸入的變數量 “少於” 給得值或遇到空變數</h3><p>如果輸入的變數量 “少於” 給得值或遇到空變數，只有指定到的變數有值，其餘都會直接跳過</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [captain, fighter, , chef] = onePiece;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fighter);   <span class="comment">// 索隆</span></span><br><span class="line"><span class="built_in">console</span>.log(chef);   <span class="comment">// 香吉士</span></span><br></pre></td></tr></table></figure><h3 id="輸入的變數量-“多於”-給得值"><a href="#輸入的變數量-“多於”-給得值" class="headerlink" title="輸入的變數量 “多於” 給得值"></a>輸入的變數量 “多於” 給得值</h3><p>而如果輸入的變數量 “多於” 給得值就會賦予 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [captain, fighter, navigator, chef, sniper, doctor] = onePiece</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doctor);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="賦予預設值"><a href="#賦予預設值" class="headerlink" title="賦予預設值"></a>賦予預設值</h3><p>在輸入的變數中也可以賦予預設值，如果變數沒有取得對應的值，就會直接帶入預設值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [captain = <span class="string">&#x27;從缺&#x27;</span>, fighter, navigator, chef, sniper, doctor = <span class="string">&#x27;喬巴&#x27;</span>] = onePiece</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(captain);   <span class="comment">// 魯夫</span></span><br><span class="line"><span class="built_in">console</span>.log(doctor);   <span class="comment">// 喬巴</span></span><br></pre></td></tr></table></figure><h3 id="互換變數"><a href="#互換變數" class="headerlink" title="互換變數"></a>互換變數</h3><p>傳值是有順序性的，且傳遞是及時的，不需要第三方變數來取代，所以可以直接透過解構賦值的方式互換變數順序以交換變數值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> captain = <span class="string">&#x27;魯夫&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> fakeCaptain = <span class="string">&#x27;迪馬爾·布拉克&#x27;</span>;</span><br><span class="line">          </span><br><span class="line">[captain, fakeCaptain] = [fakeCaptain, captain];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(captain);   <span class="comment">// 迪馬爾·布拉克</span></span><br></pre></td></tr></table></figure><h3 id="賦予字串"><a href="#賦予字串" class="headerlink" title="賦予字串"></a>賦予字串</h3><p>如果解構方法所賦予的值是字串時，就會將字串一一拆解成單一字元賦予到變數上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="string">&quot;3D2Y&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [three, day, two, year] = promise;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(three);   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(year);   <span class="comment">// Y</span></span><br></pre></td></tr></table></figure><h2 id="物件解構賦值-Object-deconstructing"><a href="#物件解構賦值-Object-deconstructing" class="headerlink" title="物件解構賦值 Object deconstructing"></a>物件解構賦值 Object deconstructing</h2><p>物件解構和陣列解構有相同的解構概念，不同的地方在於對應的值，陣列解構是透過索引的 “順序” 對應，而物件解構是透過 “屬性名稱” 來對應</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onePiece = &#123;</span><br><span class="line">  captain: <span class="string">&#x27;魯夫&#x27;</span>,</span><br><span class="line">  fighter: <span class="string">&#x27;索隆&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;captain, fighter&#125; = onePiece;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(captain);   <span class="comment">// 魯夫</span></span><br></pre></td></tr></table></figure><p>要注意的是新的物件屬性名稱必須和原物件屬性名稱相同，因為以上寫法其實是屬性和值的名稱相同時的 “縮寫”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">captain</span>: captain, <span class="attr">fighter</span>:fighter&#125;</span><br></pre></td></tr></table></figure><p>冒號 <code>:</code> 前的屬性名稱只是對應，真正賦值的是冒號 <code>:</code> 後的值，從改變值的名稱就可以了解其中概念</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">captain</span>: cap, <span class="attr">fighter</span>: fight&#125; = onePiece;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(captain);   <span class="comment">// Error</span></span><br><span class="line"><span class="built_in">console</span>.log(cap);   <span class="comment">// 魯夫</span></span><br></pre></td></tr></table></figure><h3 id="輸入的變數量與給得值-“不同”-或遇到空變數"><a href="#輸入的變數量與給得值-“不同”-或遇到空變數" class="headerlink" title="輸入的變數量與給得值 “不同” 或遇到空變數"></a>輸入的變數量與給得值 “不同” 或遇到空變數</h3><p>與陣列不同的是，因為物件是採屬性名稱對應而不是順序對應，所以遇到空變數會出現錯誤 <code>Error</code>，變數量與給得值也沒有數量對應問題，沒有對應到相同屬性就是 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;captain, , navigator&#125; = onePiece;   <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(navigator);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="賦予預設值-1"><a href="#賦予預設值-1" class="headerlink" title="賦予預設值"></a>賦予預設值</h3><p>同樣的物件解構也可以賦予預設值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;captain = <span class="string">&#x27;魯夫&#x27;</span>, fighter&#125; = &#123;<span class="attr">fighter</span>: <span class="string">&#x27;索隆&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(captain);   <span class="comment">// &#x27;魯夫&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(fighter);   <span class="comment">// &#x27;索隆&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h2><p>以下介紹幾個在 ES6 解構賦值常使用到的情境</p><h3 id="指定參數"><a href="#指定參數" class="headerlink" title="指定參數"></a>指定參數</h3><p>解構賦值有許多實際的應用，若將其運用到函式參數中，就能 “指定” 要帶入的參數而不是直接按照順序帶入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">&#123;fighter1 = <span class="string">&#x27;魯夫&#x27;</span>, fighter2 &#125;</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;fighter1&#125;</span> k.o <span class="subst">$&#123;fighter2&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">battle(&#123;&#125;);   <span class="comment">// 魯夫 k.o undefined</span></span><br><span class="line">battle(&#123;<span class="attr">fighter2</span>: <span class="string">&#x27;大仔&#x27;</span>&#125;);   <span class="comment">// 魯夫 k.o 大仔</span></span><br><span class="line">battle(&#123;<span class="attr">fighter2</span>: <span class="string">&#x27;龍馬&#x27;</span>, <span class="attr">fighter1</span>: <span class="string">&#x27;索隆&#x27;</span>&#125;);    <span class="comment">// 索隆 k.o 龍馬</span></span><br></pre></td></tr></table></figure><h3 id="解構賦值搭配縮寫與展開"><a href="#解構賦值搭配縮寫與展開" class="headerlink" title="解構賦值搭配縮寫與展開"></a>解構賦值搭配縮寫與展開</h3><p>在前面提到，如果直接將物件賦予到新物件上，是透過 “傳址” 的方式複製，如果改變其一，兩者都會更改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onePiece = &#123;</span><br><span class="line">  captain: &#123;</span><br><span class="line">    name: <span class="string">&#x27;魯夫&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  fighter: &#123;</span><br><span class="line">    name: <span class="string">&#x27;索隆&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newTeam = onePiece;</span><br><span class="line">newTeam.navigator = &#123;<span class="attr">name</span>: <span class="string">&#x27;娜美&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(onePiece.navigator.name);   <span class="comment">// &#x27;娜美&#x27;</span></span><br></pre></td></tr></table></figure><p>這時候就可以透過 “解構賦值” 與 “縮寫” 的方式賦予新物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newTeam = &#123;</span><br><span class="line">  onePiece</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但這樣的結果形式和原來的不一樣，因為是將物件直接帶入，所以內容是物件 onePiece 和 變數 navigator，所以要透過展開 <code>...</code> 將物件內容釋放出來</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newTeam = &#123;</span><br><span class="line">  ...onePiece</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他應用可以參考以下連結</p><p><a href="http://es6.ruanyifeng.com/#docs/destructuring">变量的解构赋值</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 展開與其餘參數</title>
      <link href="/javascript/20191023/13950/"/>
      <url>/javascript/20191023/13950/</url>
      
        <content type="html"><![CDATA[<p>在 ES6 中增加了一個新的方法來展開陣列中的值，這個方法就是展開 <code>...</code></p><span id="more"></span><h2 id="展開-Spread-…"><a href="#展開-Spread-…" class="headerlink" title="展開 Spread …"></a>展開 Spread …</h2><p>如下範例，我們將一班的陣列在前方加上 <code>...</code> 後，陣列的資料內容就會被一一展示開來 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> groupA = [<span class="string">&#x27;魯夫&#x27;</span>, <span class="string">&#x27;索隆&#x27;</span>, <span class="string">&#x27;娜美&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> groupB = [<span class="string">&#x27;香吉士&#x27;</span>, <span class="string">&#x27;騙人布&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...groupA);   <span class="comment">// 魯夫 喬巴 索隆</span></span><br></pre></td></tr></table></figure><p>透過展開這個方法，我們還可以連接陣列 ; 順便比較 ES6 以前的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onePiece = [...groupA, ...groupB];</span><br><span class="line"><span class="keyword">const</span> onePiece2 = groupA.concat(groupB);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(onePiece);   <span class="comment">// [&quot;魯夫&quot;, &quot;索隆&quot;, &quot;娜美&quot;, &quot;香吉士&quot;, &quot;騙人布&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(onePiece2);   <span class="comment">// [&quot;魯夫&quot;, &quot;索隆&quot;, &quot;娜美&quot;, &quot;香吉士&quot;, &quot;騙人布&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="淺層複製-Shallow-copy"><a href="#淺層複製-Shallow-copy" class="headerlink" title="淺層複製 Shallow copy"></a>淺層複製 Shallow copy</h3><p>一般來說因為陣列也是物件，所以直接賦值會透過 “傳址” 的方式來傳遞，而展開方法是一種 “淺層複製” shallow copy，因為是將原陣列先拆開再放入新陣列中，所以是透過 “傳值” 的方式複製第一層資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> groupA = [<span class="string">&#x27;魯夫&#x27;</span>, <span class="string">&#x27;索隆&#x27;</span>, <span class="string">&#x27;娜美&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> groupB = groupA;</span><br><span class="line">ler groupC = [...groupA]</span><br><span class="line"></span><br><span class="line">groupA.push(<span class="string">&#x27;香吉士&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(groupA);   <span class="comment">// [&quot;魯夫&quot;, &quot;索隆&quot;, &quot;娜美&quot;, &quot;香吉士&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(groupB);   <span class="comment">// [&quot;魯夫&quot;, &quot;索隆&quot;, &quot;娜美&quot;, &quot;香吉士&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(groupC);   <span class="comment">// [&#x27;魯夫&#x27;, &#x27;索隆&#x27;, &#x27;娜美&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="類陣列-Array-like-轉陣列-Array"><a href="#類陣列-Array-like-轉陣列-Array" class="headerlink" title="類陣列 Array-like 轉陣列 Array"></a>類陣列 Array-like 轉陣列 Array</h3><p>在 JavaScript 中，有許多有著陣列外觀卻無法使用所有陣列方法的物件我們稱為 “類陣列” <code>Array-like</code>，類陣列並不與一般陣列共用同一個原型，常見的類陣列如 <code>DOM 陣列</code> 和 <code>Argument</code> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doms = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arg(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">// Arguments(3) [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>這些類陣列 <code>Array-like</code> 可以透過 “展開” <code>...</code> 轉為真正的陣列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spreadDoms = [...doms];</span><br><span class="line"><span class="keyword">let</span> spreadArg = [...arg(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(spreadArg);   <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="其餘參數"><a href="#其餘參數" class="headerlink" title="其餘參數"></a>其餘參數</h2><p>如果帶入的參數數量大於預設的數量，可以透過展開 <code>...</code> 的方式將多餘的參數集合到陣列中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onePiece</span>(<span class="params">caption, ...crew</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(caption, crew);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onePiece(<span class="string">&#x27;魯夫&#x27;</span>, <span class="string">&#x27;索隆&#x27;</span>, <span class="string">&#x27;娜美&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line"><span class="string">&#x27;魯夫&#x27;</span> [<span class="string">&#x27;索隆&#x27;</span>, <span class="string">&#x27;娜美&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 函式預設值</title>
      <link href="/javascript/20191022/3401/"/>
      <url>/javascript/20191022/3401/</url>
      
        <content type="html"><![CDATA[<p>在 ES6 中，可以很簡單的給予函式參數預設值，只要在參數的位置加上等號 <code>=</code> 賦值即可，可以避免沒有帶入參數出現的錯誤</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add();   <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">x = <span class="number">1</span>, y = <span class="number">2</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x+y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add();   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>呼叫函式的參數都是 “由前往後”，當代入的參數數量未達到函式預設的參數數量，會優先帶入前面的參數</p><p>如果只帶入一個參數，而且只有預設第一個參數，還是會出現錯誤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x = <span class="number">1</span>, y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>);   <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>如果只帶入一參數，但有預設後面的參數，就會順利完成函式呼叫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y = <span class="number">3</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>);   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 縮寫</title>
      <link href="/javascript/20191022/54708/"/>
      <url>/javascript/20191022/54708/</url>
      
        <content type="html"><![CDATA[<p>ES6 提供了所多縮寫的方式，使程式碼更為簡潔</p><span id="more"></span><h2 id="物件縮寫"><a href="#物件縮寫" class="headerlink" title="物件縮寫"></a>物件縮寫</h2><p>以往物件要賦予到另一個物件的相同名稱屬性上時，需要寫成相同的 <code>屬性:物件</code>， ES6 開始可以不用重複撰寫，只要寫一次即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;草帽黑賊團&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> team = &#123;</span><br><span class="line">  船長: <span class="string">&#x27;魯夫&#x27;</span>,</span><br><span class="line">  船醫: <span class="string">&#x27;喬巴&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以往寫法 </span></span><br><span class="line"><span class="keyword">const</span> newTeam = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  team: team</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 縮寫</span></span><br><span class="line"><span class="keyword">const</span> newTeam = &#123;</span><br><span class="line">  name,</span><br><span class="line">  team</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="物件函式縮寫"><a href="#物件函式縮寫" class="headerlink" title="物件函式縮寫"></a>物件函式縮寫</h2><p>當物件屬性的值是一個函式時，可以省略 <code>:function</code>，語意上不會有變化，並不會轉為箭頭函式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以往寫法</span></span><br><span class="line"><span class="keyword">const</span> team = &#123;</span><br><span class="line">  slogan: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我要成為海賊王&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 縮寫</span></span><br><span class="line"><span class="keyword">const</span> team = &#123;</span><br><span class="line">  slogan ()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我要成為海賊王&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="變數作為物件屬性"><a href="#變數作為物件屬性" class="headerlink" title="變數作為物件屬性"></a>變數作為物件屬性</h2><p>ES6 開始可以使用 “中括號” <code>[]</code> 來包住變數作為物件的屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;海賊團名稱&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;草海賊團&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> team = &#123;</span><br><span class="line">  [name]: value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 會等於以下結果</span></span><br><span class="line"><span class="keyword">let</span> team = &#123;</span><br><span class="line">  海賊團名稱: <span class="string">&#x27;草帽海賊團&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 樣板字串</title>
      <link href="/javascript/20191022/30921/"/>
      <url>/javascript/20191022/30921/</url>
      
        <content type="html"><![CDATA[<p>以往在組字串時，都是透過 引號 <code>&#39;</code>、<code>&quot;</code> 和 加號 <code>+</code> 來組合，換行也必須在結尾加上 反斜線 <code>\</code>，撰寫上容易混亂，閱讀也不夠自然，因此 ES6 新增了組字串的新方法，組起來也較為接近原生的 HTML</p><span id="more"></span><h2 id="ES6-字串基本寫法"><a href="#ES6-字串基本寫法" class="headerlink" title="ES6 字串基本寫法"></a>ES6 字串基本寫法</h2><p>ES6 新增的方法如下</p><ul><li><p>使用 重音符 ` 來取代引號包住字串</p></li><li><p>使用 <code>$&#123; &#125;</code> 來包住 “變數” 或 “函式”，取代加號 <code>+</code> 來連接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是標題<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是內容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> title = <span class="string">&#x27;我是標題&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> imgUrl = <span class="string">&#x27;logo.png&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;我是內容&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 傳統寫法</span></span><br><span class="line">list.innerHTML = <span class="string">&#x27;&lt;li&gt;\</span></span><br><span class="line"><span class="string">  &lt;h2&gt;&#x27;</span> + title + <span class="string">&#x27;&lt;/h2&gt;\</span></span><br><span class="line"><span class="string">  &lt;img src=&quot;&#x27;</span> + imgUrl + <span class="string">&#x27;&quot; alt=&quot;&quot;&gt;\</span></span><br><span class="line"><span class="string">  &lt;p&gt;&#x27;</span> + func() + <span class="string">&#x27;&lt;/p&gt;\</span></span><br><span class="line"><span class="string">&lt;/li&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">list.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;li&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;<span class="subst">$&#123;title&#125;</span>&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;img src=&quot;<span class="subst">$&#123;imgUrl&#125;</span>&quot; alt=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;<span class="subst">$&#123;func()&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/li&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><ul><li>如果需要插入重音符 ` 或其他特殊字元，可以使用 “反斜線” \ 來進行轉義</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">`\`Hello\` World`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(text);   <span class="comment">// `Hello` World</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="插入-JavaScript-原始碼"><a href="#插入-JavaScript-原始碼" class="headerlink" title="${} 插入 JavaScript 原始碼"></a>${} 插入 JavaScript 原始碼</h2><p>在 ES6 新增的 <code>$&#123;&#125;</code> 還可以直接插入 JavaScript 原始碼 ; 如下範例要將陣列的中的值帶到字串中，以下是一般寫法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;魯夫&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;索隆&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&#x27;娜美&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> originUl = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt; <span class="subst">$&#123;people[<span class="number">0</span>].name&#125;</span> &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt; <span class="subst">$&#123;people[<span class="number">1</span>].name&#125;</span> &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt; <span class="subst">$&#123;people[<span class="number">2</span>].name&#125;</span> &lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>這裡我們透過 <code>map()</code> 將陣列做迴圈處理，並回傳處理後的結果，但處理後的結果因為原本是陣列，所以會用逗號 <code>,</code> 隔開，要再透過 <code>join()</code> 取消逗號 ,，而 <code>join()</code> 這個方法的預設是 <code>join(&#39;,&#39;)</code>，所以帶入空值 <code>join(&#39;&#39;)</code> 會取消逗號</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newUl = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;people.map(person =&gt; <span class="string">`&lt;li&gt; <span class="subst">$&#123;person.name&#125;</span> &lt;/li&gt;`</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 箭頭函式</title>
      <link href="/javascript/20191014/33154/"/>
      <url>/javascript/20191014/33154/</url>
      
        <content type="html"><![CDATA[<p><code>ES6</code> 開始可以使用箭頭 <code>=&gt;</code> 來定義涵式，但與原先的函式在某些情況並不完全相同，在這篇文章中會探討箭頭函式的寫法與傳統函式的差異</p><span id="more"></span><h2 id="基本寫法"><a href="#基本寫法" class="headerlink" title="基本寫法"></a>基本寫法</h2><ul><li><p>正常寫法，省略 <code>function</code> ，使用箭頭 <code>=&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnc = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span> + e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fnc = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span> + e ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果只有內容只有一行，可以省略 “大括號” <code>&#123; &#125;</code> 和 <code>return</code>，並且自動回傳</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnc = <span class="function">(<span class="params">e</span>) =&gt;</span> <span class="string">&#x27;Hello&#x27;</span> + e;</span><br></pre></td></tr></table></figure></li><li><p>如果只有 “一個參數”，可以省略 “小括號” <code>( )</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnc = <span class="function"><span class="params">e</span> =&gt;</span> <span class="string">&#x27;Hello&#x27;</span> + e;</span><br></pre></td></tr></table></figure></li><li><p>如果 “沒有參數” 或 “多個參數”，就一定要有 “小括號” <code>( )</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnc = <span class="function">() =&gt;</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> fnc2 = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br></pre></td></tr></table></figure></li></ul><h2 id="沒有-arguments-參數"><a href="#沒有-arguments-參數" class="headerlink" title="沒有 arguments 參數"></a>沒有 arguments 參數</h2><p>一般函式被呼叫時，都會產生一個 <code>argument</code> 物件，這個物件的內容就是我們帶入的 “參數”，而箭頭函式中是沒有 <code>arguments</code> 物件的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnc = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">arguments</span>.length );</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fuc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="this-差異"><a href="#this-差異" class="headerlink" title="this 差異"></a>this 差異</h2><ul><li><p>傳統函式 : <code>this</code> 的值是動態的，由呼叫這個函式的擁有物件 <code>object</code> 而定</p></li><li><p>箭頭函式 : <code>this</code> 的值綁定到其定義時所在的物件而定，也就是由周邊的作用域而定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;我是全域&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  name: <span class="string">&#x27;我是作用域&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  callName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>, <span class="built_in">this</span>.name);     <span class="comment">// 1 我是作用域</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>, <span class="built_in">this</span>.name);   <span class="comment">// 2 我是作用域</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>, <span class="built_in">this</span>);        <span class="comment">// 3 test 這個物件</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  callName2: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;4&quot;</span>, <span class="built_in">this</span>.name);          <span class="comment">// 4 我是全域</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;5&quot;</span>, <span class="built_in">this</span>.name);   <span class="comment">// 5 我是全域</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;6&quot;</span>, <span class="built_in">this</span>);        <span class="comment">// 6 window 物件</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.callName();</span><br><span class="line">test.callName2();</span><br></pre></td></tr></table></figure><p>由以上範例可以看到，傳統函式 <code>function</code> 的 <code>this</code> 指的是這個函式的擁有物件 <code>test</code>，而箭頭函式在全域被宣告定義，所以其 this 自然指向最高級物件 window</p><p>而外層的 “函式” 並不回影響箭頭函式的 <code>this</code> 原先指向的 <code>window</code>，外層的 “物件” 才會使箭頭函式的 <code>this</code> 指向這個物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;, <span class="number">10</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> func3 = &#123;</span><br><span class="line">    func4: func2</span><br><span class="line">  &#125;</span><br><span class="line">  func2();         <span class="comment">// window 物件</span></span><br><span class="line">  func3.func4();   <span class="comment">// func3 這個物件</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>由上範例可以看到，如果 “不是” 建立在 “物件” 內的箭頭函式，就不會影響箭頭函式的 <code>this</code></p><ul><li>func() : 最外層的函式，不會影響內部箭頭函式的 <code>this</code></li><li>func2() : 第二層的函式，也不會影響內部箭頭函式的 <code>this</code></li><li>func3() : 為一個物件，內部箭頭函式的 <code>this</code> 就會指向這個物件</li></ul></li></ul><h2 id="特殊的情況"><a href="#特殊的情況" class="headerlink" title="特殊的情況"></a>特殊的情況</h2><p>內建函式 <code>call</code>、<code>apply</code> 和 <code>bind</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func5 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1.call(obj);   <span class="comment">// obj </span></span><br><span class="line">func2.call(obj);   <span class="comment">// window </span></span><br><span class="line">func3.call(obj);   <span class="comment">// window </span></span><br><span class="line">func4.call(obj);   <span class="comment">// obj </span></span><br><span class="line">func5.call(obj);   <span class="comment">// window</span></span><br></pre></td></tr></table></figure><ul><li><code>func1</code> : 透過 <code>call</code> 呼叫給定 <code>this</code> ，所以 <code>this</code> 自然指向 <code>obj</code> 這個物件</li><li><code>func2</code> : 箭頭函式沒有宣告在物件內部，所以 <code>this</code> 還是指向 <code>window</code></li><li><code>func3</code> : 傳統函式的 <code>this</code> 依據呼叫的方式，可以看成是 <code>window.setTimeout</code>，所以 <code>this</code> 指向 <code>window</code></li><li><code>func4</code> : 因為外層 <code>func4</code> 的 <code>this</code> 被指定為 <code>obj</code>，所以 <code>setTimeout</code> 內的箭頭函式會在 <code>obj</code> 中被宣告</li><li><code>func5</code> : 因為外層 <code>func5</code> 在全域宣告，所以 <code>this</code> 自然指向 <code>window，setTimeout</code> 內箭頭函式的 <code>this</code> 也會指向 window`</li></ul><h3 id="不能用在建構式函式"><a href="#不能用在建構式函式" class="headerlink" title="不能用在建構式函式"></a>不能用在建構式函式</h3><p>由於箭頭函式的 <code>this</code> 是在其所定義的物件下建立，所以不能像 <code>function</code> 一樣作為建構式的函式，直接使用 <code>new</code> 會出現錯誤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.text = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testAgain = <span class="keyword">new</span> test(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: test is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="DOM-事件的監聽"><a href="#DOM-事件的監聽" class="headerlink" title="DOM 事件的監聽"></a>DOM 事件的監聽</h3><p>在 <code>DOM</code> 事件監聽的情況下，函式的 <code>this</code> 應該指向這個 <code>DOM</code> 元素本身，但箭頭函式的 <code>this</code> 依然會指向定義其所在的物件 <code>window</code>，所以不適用於這類情況</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> addSomething = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">// window 物件</span></span><br><span class="line">  <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;AddSomething&#x27;</span>;   <span class="comment">// Error</span></span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, addSomething);</span><br></pre></td></tr></table></figure><h2 id="使用建議"><a href="#使用建議" class="headerlink" title="使用建議"></a>使用建議</h2><ul><li>物件內的函式可以優先使用，因為傳統函式以往的做法會先將 <code>this</code> 賦予再另一個變數上，以記錄當下的 <code>this</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  callName ()&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(that);   <span class="comment">// test 這個物件</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  callName2 ()&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">// test 這個物件</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>雖然只有一個參數時可以省略 “小括號” <code>( )</code>，但還是建議都加上，避免意外錯誤</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - ES6 - 變數</title>
      <link href="/javascript/20191013/50209/"/>
      <url>/javascript/20191013/50209/</url>
      
        <content type="html"><![CDATA[<p>在 ES6 中多了兩種變數的宣告方式，<code>let</code> 與 <code>const</code>，其最大的目的在於盡量避免汙染到全域，原因在於載入多個模組或進行多人協作時，如果遇到相同名稱的全域變數就會發生衝突，也減少了程式的靈活性</p><span id="more"></span><h2 id="window-與-var"><a href="#window-與-var" class="headerlink" title="window 與 var"></a>window 與 var</h2><p>在 ES6 以前，都使用 <code>var</code> 來進行變數的宣告，而切分 <code>var</code> 有效範圍的最小單位是 函式 function，所以在 <code>function</code> 外使用 <code>var</code> 宣告的變數都會成為全域變數，也就是 最高級物件 <code>window</code> 的屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> b =<span class="number">0</span>; b &lt; <span class="number">2</span>; b++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);   <span class="comment">// 0, 1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(c);   <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// c is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);   <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="let-與-var"><a href="#let-與-var" class="headerlink" title="let 與 var"></a>let 與 var</h2><p>與 <code>var</code> 不同的是，<code>let</code> 是一個 區塊 <code>block</code> 變數，<code>block</code> 意指 大括號 <code>&#123; &#125;</code>， 也就是說切分 let 有效範圍的最小單位是 大括號 <code>&#123; &#125;</code>，且使用 let 宣告的全域變數不會成為全域物件 <code>window</code> 的屬性</p><p>同上範例，我們將 <code>var</code> 都改成 <code>let</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b =<span class="number">0</span>; b &lt; <span class="number">2</span>; b++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);   <span class="comment">// 0, 1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// b is not defined</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c = <span class="number">3</span></span><br><span class="line">  <span class="built_in">console</span>.log(c);   <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// c is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="let-與-for-的用法"><a href="#let-與-for-的用法" class="headerlink" title="let 與 for 的用法"></a>let 與 for 的用法</h2><p>如下範例，我們要讓每一個 <code>li</code> 被點擊時都能顯示自己的數字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.list li&#x27;</span>)[i].addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但結果並不如預期，在點擊每個 <code>li</code> 都會是 <code>4</code>，因為這裡的變數 <code>i</code> 使用 <code>var</code> 來宣告，所以是全域變數，當跑完 for 迴圈的時候，所有 <code>console.log(i + 1)</code> 中的 <code>i</code> 都會被全域的 <code>i = 3</code> 取代</p><p>如果將上述範例的 <code>var</code> 改成 <code>let</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.list li&#x27;</span>)[i].addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成 <code>let</code> 來宣告的結果會如預期一樣，點擊每個 <code>li</code> 都是自己的數字，因為變數 <code>i</code> 並不會成為全域變數，所以 <code>console.log(i + 1)</code> 中的 <code>i</code> 都會是迴圈執行時當下取得的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.list li&#x27;</span>)[i].addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i + <span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成 let 來宣告的結果會如預期一樣，點擊每個 li 都是自己的數字，因為變數 i 並不會成為全域變數，所以 console.log(i + 1) 中的 i 都會是迴圈執行時當下取得的值</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li><p>使用 <code>const</code> 宣告的變數又稱為 “常數” 或 “唯讀變數”</p></li><li><p>宣告完的變數無法再進行修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 錯誤</span></span><br></pre></td></tr></table></figure></li><li><p>但使用 <code>const</code> 宣告的 物件 <code>&#123; &#125;</code> 和 陣列 <code>[]</code> 依然可以修改其內容，因為物件型別是 “傳址” <code>pass by reference</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  url: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.url = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.url);   <span class="comment">// b</span></span><br></pre></td></tr></table></figure></li><li><p>如果要使宣告的物件連屬性也無法修改，可以使用 <code>Object.freeze()</code> 來將物件凍結</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  url: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">obj.url = b;</span><br><span class="line"><span class="built_in">console</span>.log(obj.url);   <span class="comment">// a</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="let-與-const-的注意事項"><a href="#let-與-const-的注意事項" class="headerlink" title="let 與 const 的注意事項"></a>let 與 const 的注意事項</h2><p>ES6 變數的宣告與以往使用 <code>var</code> 有一些性質上的不同，以下一一介紹</p><ul><li><p>不會向上提升 Hoisting，從宣告的那一行開始成立</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="built_in">console</span>.log(c);   <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="built_in">console</span>.log(d);   <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>同一個 “區塊” <code>block</code> 內不能重複命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;   <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">2</span>;   <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure></li><li><p>在全域宣告的變數不會成為最高級物件 <code>window</code> 的屬性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);   <span class="comment">// undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c);   <span class="comment">// undefined </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><ul><li><a href="https://www.udemy.com/javascript-learning/">JavaScript 入門篇 - 學徒的試煉</a></li><li><a href="https://ithelp.ithome.com.tw/users/20083608/ironman/1354">邁向 JavaScript 勇者之路</a></li><li><a href="http://es6.ruanyifeng.com/#docs/intro">ECMAScript 6 入門</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - localStorage</title>
      <link href="/javascript/20191004/8109/"/>
      <url>/javascript/20191004/8109/</url>
      
        <content type="html"><![CDATA[<p><code>Web storage</code> 為 <code>HTML 5</code> 問世後提供的新技術，提供比 <code>cookie</code> (每條 <code>cookie</code> 的儲存空間為 <code>4K</code>) 更大 (<code>localStorage</code> 為 <code>5M</code>) 更安全的本地端儲存空間，也不會影響到網頁效能</p><span id="more"></span><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p><code>Web storage</code> 物件分為以下兩種，兩種物件的唯一差異是 “生命週期”，所以以下都已 <code>localStorage</code> 來做介紹</p><ul><li><p><code>window.localStorage</code><br>儲存到這裡的資料會 “永久” 保存於本地端，除非使用者主動使用 <code>JavaScript</code> 語法 或 “網頁瀏覽器功能” 來刪除</p></li><li><p><code>window.sessionStorage</code><br>保存資料於頁面 “尚未關閉” 或使用 “還原” 時，但在頁面關閉時清空儲存在內的所有資料</p></li></ul><h2 id="localStorage-基本操作"><a href="#localStorage-基本操作" class="headerlink" title="localStorage 基本操作"></a>localStorage 基本操作</h2><h3 id="locarStorage-裡的-key-與-value"><a href="#locarStorage-裡的-key-與-value" class="headerlink" title="locarStorage 裡的 key 與 value"></a><code>locarStorage</code> 裡的 <code>key</code> 與 <code>value</code></h3><p>開啟開發人員工具，我們可以從裡面的 <code>Application</code> 找到 <code>localStorage</code>，點開 <code>localStorage</code>，會看到兩個欄位 <code>Key</code> 與 <code>Value</code>，在沒有任何動作前，兩個欄位是空的</p><p><img src="localStorage-key&value.png"></p><ul><li><p>Key</p><p><code>Key</code> 是 <code>localStorage</code> 物件的屬性，也是存入這筆資料的 “名稱”</p></li><li><p>Value</p></li></ul><p>而 <code>Value</code> 是 <code>Key</code> 屬性的值，也是存入這筆資料的 “內容”，特別要注意的是，<code>Key</code> 的型態都是 字串 <code>string</code></p><h3 id="localStorage-操作方法"><a href="#localStorage-操作方法" class="headerlink" title="localStorage 操作方法"></a>localStorage 操作方法</h3><ul><li><p><code>localStorage.setItem(&#39;Key&#39;, &#39;Value&#39;)</code> 存入</p><p>透過這個方法可以將資料存入 <code>localStorage</code></p></li><li><p><code>localStorage.getItem(&#39;Value&#39;)</code> 取出</p><p>透過這個方法可以取出 <code>localStorage</code> 中指定屬性的值</p></li><li><p><code>localStorage.removeItem(&#39;Key&#39;)</code> 刪除</p><p>透過這個方法可以刪除 <code>localStorage</code> 中指定的屬性</p><p><a href="https://codepen.io/Jerry-Yeh/pen/RzObON?editors=1010">範例程式碼</a></p></li><li><p><code>localStorage.key()</code> 取得屬性</p><p>透過這個方法可以取得指定順序的屬性 <code>key</code>，此順序也是從 <code>0</code> 開始</p></li><li><p><code>localStorage.clear()</code> 清除全部屬性</p><p>這個方法會清除 <code>localStorage</code> 中所有屬性 <code>key</code></p></li></ul><h2 id="JSON-資料編譯"><a href="#JSON-資料編譯" class="headerlink" title="JSON 資料編譯"></a>JSON 資料編譯</h2><h3 id="為什麼我們需要編譯資料"><a href="#為什麼我們需要編譯資料" class="headerlink" title="為什麼我們需要編譯資料 ?"></a>為什麼我們需要編譯資料 ?</h3><p>當我們使用 <code>setItem</code> 將資料儲存在本地端資料庫時，會發現所有儲存的資料 <code>value</code> 都被轉換成 “字串”，原因是 <code>Storage</code> 只會儲存字串的格式，所以會將所有存入的資料使用 <code>toString()</code> 方法強行轉換成字串 ; 如果將物件強行轉換成字串，就會得到 <code>[object, Object]</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;testString&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;string&#x27;</span>, <span class="number">123</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="keyword">var</span> object = &#123;<span class="string">&quot;test&quot;</span>: <span class="number">123</span>&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">function</span> = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;<span class="title">alert</span>(<span class="params">test</span>)&#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item1&#x27;</span>, string);</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item2&#x27;</span>, number);</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item3&#x27;</span>, array);</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item4&#x27;</span>, object);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item1&#x27;</span>));   <span class="comment">// testString   (string)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item2&#x27;</span>));   <span class="comment">// 123   (string)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item3&#x27;</span>));   <span class="comment">// string, 123, true   (string)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item4&#x27;</span>));   <span class="comment">// [object, Object]</span></span><br></pre></td></tr></table></figure><h3 id="編譯資料的方式"><a href="#編譯資料的方式" class="headerlink" title="編譯資料的方式"></a>編譯資料的方式</h3><p>在這裡 <code>JSON</code> 提供了兩種方法來轉換資料的型別</p><ul><li><p><code>JSON.stringify()</code></p><p>將資料轉為 <code>JSON</code> 格式的字串</p></li><li><p><code>JSON.parse()</code></p><p>將資料由 <code>JSON</code> 格式字串轉回原來的內容與型別</p></li></ul><p>同樣的資料我們在存入時使用 <code>stringify()</code> 將資料轉成 <code>JSON</code> 格式字串，取出時使用 <code>parse()</code> 轉回原來的資料型別</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item1&#x27;</span>, <span class="built_in">JSON</span>.stringify(string));</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item2&#x27;</span>, <span class="built_in">JSON</span>.stringify(number));</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item3&#x27;</span>, <span class="built_in">JSON</span>.stringify(array));</span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;item4&#x27;</span>, <span class="built_in">JSON</span>.stringify(object));</span><br><span class="line">              </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item1&#x27;</span>)));   testString   (string)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item2&#x27;</span>)));   <span class="number">123</span>   (number)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item3&#x27;</span>)));   [<span class="string">&#x27;string&#x27;</span>, <span class="number">123</span>, <span class="literal">true</span>]   (array)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;item4&#x27;</span>)));   &#123;<span class="string">&quot;test&quot;</span>: <span class="number">123</span>&#125;   (object)</span><br></pre></td></tr></table></figure><p><code>return</code> 回傳數值、中斷 <code>function</code> ，不會執行之後的程式碼</p><h2 id="HTML-5-中的-data-屬性"><a href="#HTML-5-中的-data-屬性" class="headerlink" title="HTML 5 中的 data-* 屬性"></a>HTML 5 中的 data-* 屬性</h2><p>在製作網頁時，如果可以自己新增屬性，為 <code>HTML tag</code> 做上記號，就能更靈活的操作網頁。但為了避免大家隨意添加、命名自己需要的屬性，<code>HTML 5</code> 就多了一個 <code>data-*</code> 屬性，制定了一個統一的規則，其中的米字號 <code>*</code> 是一個可以自定義的名稱</p><p>在 <code>*</code> 自定義名稱時，不能使用 英文大寫，可以是任何字串，如下範例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-num</span>=<span class="string">&quot;0&quot;</span> <span class="attr">data-size</span>=<span class="string">&quot;m&quot;</span> <span class="attr">class</span>=<span class="string">&quot;listLi&quot;</span>&gt;</span>卡斯伯<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在-JS-中選取-data"><a href="#在-JS-中選取-data" class="headerlink" title="在 JS 中選取 data-*"></a>在 JS 中選取 data-*</h3><p>如果是綁定事件來尋找自定義的 <code>data-*</code> 屬性，都會儲存在 <code>target</code> 中的 <code>dataset</code> 物件，物件的屬性就是自定義的 <code>*</code>，屬性的值就是自定義時給定的值了。延續上方的範例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.list li&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkList</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.dataset);        <span class="comment">// DOMStringMap &#123;num: &quot;0&quot;, size: &quot;m&quot;&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.target.dataset.num)     <span class="comment">// 0</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.target.dataset.size);   <span class="comment">// m</span></span><br><span class="line">&#125;;</span><br><span class="line">            </span><br><span class="line">list.addEventListener(<span class="string">&#x27;click&#x27;</span>, checkList, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><strong><code>dataset</code> 與 <code>array</code> 的運用</strong></p><ul><li><p>先將陣列 <code>array</code> 中的資料帶入 <code>HTML</code></p></li><li><p>點擊時再透過 <code>dataset</code> 取得對應的資料</p><p><a href="">範例程式碼</a></p></li></ul><h3 id="在-CSS-中選取-data"><a href="#在-CSS-中選取-data" class="headerlink" title="在 CSS 中選取 data-*"></a>在 CSS 中選取 data-*</h3><p>既然是自定義的屬性 <code>Attribute</code>，黨然也可以在 <code>CSS</code> 中被選取</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span> <span class="attr">data-content</span>=<span class="string">&quot;Hello Everyone&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-size</span>=<span class="string">&quot;m&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">data-size</span>=<span class="string">&quot;xl&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要在 <code>&lt;article&gt;</code> 中顯示 <code>data-content</code> 的內容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atricle<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(data-content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要選取指定的屬性或是屬性的值，也可以搭配 CSS 選擇棄來使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">img</span><span class="selector-attr">[data-size=<span class="string">&quot;m&quot;</span>]</span>&#123;...&#125;</span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">img</span><span class="selector-attr">[data-size=<span class="string">&quot;xl&quot;</span>]</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="toDoList"><a href="#toDoList" class="headerlink" title="toDoList"></a>toDoList</h2><p><a href="https://codepen.io/Jerry-Yeh/pen/jjRjJp?editors=1010">範例程式碼</a></p><ol><li>取得輸入框的內容加入到 <code>data</code> 陣列中</li><li>將 <code>data</code> 陣列轉換成 “字串” 儲存到 <code>localStorage</code></li><li>取出 <code>localStorage</code> 的資料並還原其形態，印出到網頁中</li><li>透過 <code>dataset</code> 刪除點選的指定資料</li></ol><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/users/20065504/ironman/1259">重新認識 JavaScript</a><br><a href="https://ithelp.ithome.com.tw/users/20083608/ironman/1354">邁向 JavaScript 勇者之路</a><br><a href="https://www.udemy.com/javascript-learning/">JavaScript 入門篇 - 學徒的試煉</a><br><a href="https://ithelp.ithome.com.tw/articles/10195522">JS30-Day15-LocalStorage</a><br><a href="https://pjchender.blogspot.com/2017/01/html-5-data-attribute.html">什麼是 HTML 5 中的資料屬性（data-* attribute )</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - AJAX</title>
      <link href="/javascript/20191004/50136/"/>
      <url>/javascript/20191004/50136/</url>
      
        <content type="html"><![CDATA[<p>透過 AJAX，可與伺服器進行非同步更新，不需要重新載入網頁就可以更新內容</p><span id="more"></span><h2 id="什麼是-AJAX"><a href="#什麼是-AJAX" class="headerlink" title="什麼是 AJAX ?"></a>什麼是 AJAX ?</h2><p>AJAX 全名為 非同步 JavaScript 與 <code>XML(Asynchronous JavaScript and XML)</code>，其實並不能稱為一種 “新技術”，而是結合許多現有技術的 “新方法”，這些技術包括 HTML、XHTML、JavaScript、DOM 與最重要的 XMLHttpRequest 物件等</p><h3 id="為什麼需要-AJAX"><a href="#為什麼需要-AJAX" class="headerlink" title="為什麼需要 AJAX ?"></a>為什麼需要 AJAX ?</h3><p>透過 AJAX 我們可以不需要重新讀取整個網頁就能及時更動網頁介面與內容，只會對改變的地方進行動態重新渲染，提高網頁效能並更快回復使用者的操作，常見於用戶註冊、驗證，不需要等到資料填完就會顯示是否重複或錯誤</p><h3 id="AJAX-應用"><a href="#AJAX-應用" class="headerlink" title="AJAX 應用"></a>AJAX 應用</h3><ul><li>使用 JavaScript 的 <code>XMLHttpRequest</code> 物件向網頁伺服器發送 <code>HTTP</code> 請求</li><li>使用 JavaScript 操作 <code>DOM</code> 來執行動態效果</li><li><code>XMLHttpRequest</code> 與 “網頁伺服器” 進行 “非同步” 資料交換</li></ul><h2 id="AJAX-操作"><a href="#AJAX-操作" class="headerlink" title="AJAX 操作"></a>AJAX 操作</h2><h3 id="XMLHttpRequest-物件"><a href="#XMLHttpRequest-物件" class="headerlink" title="XMLHttpRequest 物件"></a><code>XMLHttpRequest</code> 物件</h3><ol><li>宣告一個 <code>XMLHttpRequest</code> 物件<br>當宣告一個 <code>XMLHttpRequest</code> 物件後，我們可以透過 <code>console.log</code> 來查看這個物件的屬性，並透過這些屬性來操作資料與確認狀態<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="built_in">console</span>.log(xhr);</span><br></pre></td></tr></table></figure></li></ol><p>  <img src="XMLHttpRequest.png"></p><ol start="2"><li><p><code>.open(&quot;格式&quot;, &quot;網址&quot;, &quot;同步/非同步&quot;)</code> 定義連線方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;https://hexschool.github.io/ajaxHomework/data.json&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><ul><li>格式<ul><li><code>get</code> : 讀取資料</li><li><code>post</code> : 傳資料到伺服器確認</li></ul></li><li>網址<br>要讀取的資料位置</li><li>同步與非同步<br>通常都使用 <code>true</code> 非同步，否則當資料太大時，會等到資料傳送完畢才會繼續渲染網頁<ul><li><code>true</code> 非同步: 不會等資料傳回來，就會讓程式碼繼續往下跑</li><li><code>false</code> 同步: 會等資料傳回來，才讓程式碼繼續往下跑</li></ul></li></ul></li><li><p><code>send()</code> 送出請求<br>在定義完連線方式後，接著就會送出請求，小括號 <code>()</code> 內放入要送出的資料，如果只是要取得資料，就會填入 <code>null</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>responseText</code> 資料內容<br>送出請求後我們可以透過 <code>responseText</code> 來查看資料內容<br><img src="xhr.responseText.png"><br>但如果在送出請求後，接著使用 <code>console.log</code> 來查看資料，會發現取得 空值，因為 <code>AJAX</code> 是 “非同步” 取得資料，所以在取得資料前網頁就會渲染完畢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(xhr.responseText);   <span class="comment">// 空值</span></span><br></pre></td></tr></table></figure></li><li><p><code>onload</code> 成功取得資料後執行<br>要解決上述問題，只要使用 <code>onload</code> 在成功取得資料後再印出結果，要注意的是，從 <code>.json</code> 檔案取得的資料型態是 “字串”，所以要使用 <code>JSON.parse</code> 還原資料型態</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;message&quot;</span>&gt;</span>王小明<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; in json</span><br><span class="line">[</span><br><span class="line">  &#123;name: &quot;王小名&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(xhr.responseText);   <span class="comment">// &quot;[&#123;&quot;name&quot;:&quot;王小名&quot;&#125;]&quot;</span></span><br><span class="line">  <span class="keyword">var</span> str = JOSN.parse(xhr.responseText);</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.message&#x27;</span>).textContent = str[<span class="number">0</span>].name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>onerror</code> 取得資料失敗後執行<br>除了設定成功取得資料後執行的內容，當然也可以設定取得資料失敗後執行的內容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;...&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="readyState-狀態碼"><a href="#readyState-狀態碼" class="headerlink" title="readyState 狀態碼"></a><code>readyState</code> 狀態碼</h3><p>在操作 <code>XMLHttpRequest</code> 物件的每個步驟都會有專屬的狀態碼以辨別當下進度</p><p>通常 <code>2</code>、<code>3</code> 會在一瞬間執行完畢，所以在取得資料後查看會是 <code>4</code></p><ul><li><code>0</code> : 已經宣告一個 <code>XMLHttpRequest</code> 物件，但是還沒有連結要取得的資料</li><li><code>1</code> : 使用 <code>open()</code> 撈資料，但還沒有傳送資料</li><li><code>2</code> : 偵測到使用 <code>send</code></li><li><code>3</code> : <code>loading</code> 資料中</li><li><code>4</code> : 已經取得資料，且完全接收數據</li></ul><h3 id="傳統表單輸入"><a href="#傳統表單輸入" class="headerlink" title="傳統表單輸入"></a>傳統表單輸入</h3><p>傳統的表單如下，輸入資料後，會傳送到 action 所指定的位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;index.html&quot;</span>&gt;</span></span><br><span class="line">  帳號 : </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span>   // abc@gmail.com</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  密碼 : </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>   // abcde</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>傳送的資料以問號 <code>?</code> 隔開 “位置” 內容，如果有多筆內容，使用 <code>&amp;</code> 隔開</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;指定的網址&quot;</span> + <span class="string">&quot;?&quot;</span> + <span class="string">&quot;內容&quot;</span> + <span class="string">&quot;內容&quot;</span></span><br><span class="line">index.html?email=abc%40gmail.com&amp;password=abcde</span><br></pre></td></tr></table></figure><h3 id="post-傳送表單資料"><a href="#post-傳送表單資料" class="headerlink" title="post 傳送表單資料"></a><code>post</code> 傳送表單資料</h3><ul><li><p>如果要發送資料到資料庫，在 <code>open()</code> 中的第一個參數為 <code>post</code></p></li><li><p>因為要發送的資料會直接寫在 <code>send()</code> 中，所以需要先使用 <code>setRequestHeader</code> 來設定資料類型，如果發送的資料類型是表單，分別設立兩個參數為 <code>Content-Type</code> 和 <code>application/x-www-form-urlencoded</code></p></li><li><p>如上 “傳統表單” 送出一樣的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;https://hexschool-tutorial.herokuapp.com/api/signup&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;email=abc@gmail.com&amp;password=abcde&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>傳送資料過去後，可以使用 console.log 查詢回傳的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(xhr.responseText);   <span class="comment">// &#123;&quot;success&quot;:true,&quot;result&quot;:&#123;&#125;,&quot;message&quot;:&quot;帳號註冊成功&quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>如果帳號已經被註冊。就會出現以下結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(xhr.responseText);   <span class="comment">// &#123;&quot;success&quot;:false,&quot;result&quot;:&#123;&#125;,&quot;message&quot;:&quot;此帳號已被使用&quot;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="post-JSON"><a href="#post-JSON" class="headerlink" title="post JSON"></a>post JSON</h3><p>除了使用 <code>post</code> 傳送表單格式資料外，也可以直接傳送 <code>json</code> 格式，只要把 <code>setRequestHeader()</code> 中第二個參數改成 <code>application/json</code>， 但要注意的是，和 <code>localStorage</code> 一樣，都是使用 “字串” 來傳送，所以要使用 <code>JSON.stringify</code> 和 <code>JSON.parse</code> 來轉換型態</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> account = &#123;</span><br><span class="line">  email: <span class="string">&#x27;abc@gmail.com&#x27;</span>,</span><br><span class="line">  password: <span class="string">&#x27;abcde&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xhr = XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;https://hexschool-tutorial.herokuapp.com/api/signup&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-type&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.stringify(account);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure><h2 id="CORS-Corss-Origin-Resourse-Sharing-跨來源資源共享"><a href="#CORS-Corss-Origin-Resourse-Sharing-跨來源資源共享" class="headerlink" title="CORS (Corss-Origin Resourse Sharing) 跨來源資源共享"></a>CORS (Corss-Origin Resourse Sharing) 跨來源資源共享</h2><p>在開發網頁時，常常需要串接外部的資料、API，這時候我們就會對伺服器送出一個 <code>HTTP request</code> 請求，但是當瀏覽器收到來自伺服器的 <code>HTTP response</code> 回應時，基於安全性考量，在網站與資料 “不同源” <code>not same origin</code> 的情況下，瀏覽器並不會把收到的 <code>response</code> 回傳給 <code>JavaScript</code></p><p>而 <code>CORS</code> 就是一個允許不同源之間資料傳輸的規範，透過以下網站可以判定這個外接網址是否有開啟 <code>CORS</code></p><p><a href="http://www.test-cors.org/">test-cors.org</a></p><p>詳細說明可以參考以下資料</p><p><a href="https://blog.techbridge.cc/2017/05/20/api-ajax-cors-and-jsonp/">輕鬆理解 Ajax 與跨來源請求</a></p><h2 id="HTTP-狀態碼"><a href="#HTTP-狀態碼" class="headerlink" title="HTTP 狀態碼"></a><code>HTTP</code> 狀態碼</h2><p><code>HTTP</code> 狀態碼指的是伺服器回應 <code>HTTP response</code> 我們發出的請求 ，而 <code>HTTP request``HTTP</code> 狀態碼分為五大類、三個層級，而三個層級分別使用三個數字來表示，第一個數字就表示大類</p><ul><li>1xx - 參考資訊 (informational)</li><li>2xx - 成功 (OK)</li><li>3xx - 重新導向 (Redirection)</li><li>4xx - 用戶端錯誤 (Client Error)</li><li>5xx - 伺服器錯誤 (Server Error)</li></ul><p>最常見的為以下兩種</p><ul><li>200 : 用戶端請求成功</li><li>404 : 找不到用戶端請求</li></ul><p>詳細內容操考以下資料</p><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP狀態碼 Wiki</a><br><a href="https://blog.miniasp.com/post/2009/01/16/Web-developer-should-know-about-HTTP-Status-Code">網頁開發人員應了解的 HTTP 狀態碼</a></p><h2 id="AJAX-實務範例"><a href="#AJAX-實務範例" class="headerlink" title="AJAX 實務範例"></a>AJAX 實務範例</h2><p><a href="https://codepen.io/Jerry-Yeh/pen/NZZrov?editors=1010">AJAX 實務範例</a></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/javascript-learning/">JavaScript 入門篇 - 學徒的試煉</a><br><a href="https://ithelp.ithome.com.tw/users/20102891/ironman/1955">從頭開始的API 和ajax</a><br><a href="https://zh.wikipedia.org/wiki/AJAX">AJAX Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - 事件</title>
      <link href="/javascript/20191003/52047/"/>
      <url>/javascript/20191003/52047/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 是一個事件驅動 <code>Event-driven</code> 的程式語言，當瀏覽器載入網頁開始讀取後，會馬上讀取 JS 事件的相關程式碼，但必須等到事件被觸發後，才會進行對應程式的執行</p><span id="more"></span><h2 id="事件介紹"><a href="#事件介紹" class="headerlink" title="事件介紹"></a>事件介紹</h2><p>以下方的 Bootstrap 按鈕為例，當使用者點擊這個按鈕，並跳出另一個視窗， “點擊按鈕” 這件事就是 “事件” Event，而負責處理事件的程式被稱為 事件處理者 <code>Event Handler</code>，也就是 “啟動另一個視窗的顯示” 這個動作</p><p><a href="https://codepen.io/Jerry-Yeh/pen/eYOqLaK?editors=1001">bootstrap button</a></p><h2 id="事件流程"><a href="#事件流程" class="headerlink" title="事件流程"></a>事件流程</h2><h3 id="事件流程介紹"><a href="#事件流程介紹" class="headerlink" title="事件流程介紹"></a>事件流程介紹</h3><p>這裡有兩個 <code>div</code> 元素，外層是 <code>.outer</code>，內層是 <code>.inner</code>，當我們點擊 <code>.inner</code> 的時候，其實也同時在點擊 <code>.outer</code>，更廣義來說，其實也在點擊整個網頁</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="event-flow.png"></p><p>事件流程指的就是 “網頁元素接收事件的順序”，而事件流程分成兩種機制</p><ul><li>事件冒泡 (Event Bubbling)</li><li>事件捕獲 (Event Capturing)</li></ul><h3 id="事件冒泡-Event-Bubbling"><a href="#事件冒泡-Event-Bubbling" class="headerlink" title="事件冒泡 (Event Bubbling)"></a>事件冒泡 (Event Bubbling)</h3><p>“事件冒泡” 指的就是從啟動的元素節點開始，逐漸 “由下而上” 傳遞，直到網頁的根節點 <code>document</code></p><p>如下範例，當我們點擊 <code>&lt;div&gt;click&lt;/div&gt;</code>，在 “事件冒泡” 的機制下，觸發順序為:</p><ol><li><code>&lt;div&gt;click&lt;/div&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;html&gt;</code></li><li><code>document</code></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>click<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   // 被點擊的元素</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件捕獲-Event-Capturing"><a href="#事件捕獲-Event-Capturing" class="headerlink" title="事件捕獲 (Event Capturing)"></a>事件捕獲 (Event Capturing)</h3><p>“事件捕獲” 和 “事件冒泡” 相反，指的就是從啟動的元素節點開始，逐漸 “由上而下” 傳遞，從網頁的根節點 <code>document</code> 開始直到點擊的元素</p><p>同以上範例，當我們點擊 <code>&lt;div&gt;click&lt;/div&gt;</code>，在 事件捕獲的機制下，觸發順序為:</p><ol><li><code>document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;div&gt;click&lt;/div&gt;</code></li></ol><h2 id="事件的註冊綁定"><a href="#事件的註冊綁定" class="headerlink" title="事件的註冊綁定"></a>事件的註冊綁定</h2><p>透過事件的綁定，可以指定 “事件處理器” <code>handler</code> 給事件，也就是當事件被觸發後會執行的動作</p><p>事件的綁定可以分為以下三種:</p><ul><li><code>on-event</code> 處理器 (HTML 屬性)</li><li><code>on-event</code> 處理器 (非 HTML 屬性)</li><li>事件監聽 <code>EventTarget.addEventListener()</code></li></ul><h3 id="on-event-處理器-HTML-屬性"><a href="#on-event-處理器-HTML-屬性" class="headerlink" title="on-event 處理器 (HTML 屬性)"></a>on-event 處理器 (HTML 屬性)</h3><p>我們可以透過加上 <code>on</code> + 事件名稱 的屬性在 HTML 元素上來註冊事件，但基於使用性與維護性，不建議使用此方法來綁定事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span>&gt;</span> click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="on-event-處理器-非-HTML-屬性"><a href="#on-event-處理器-非-HTML-屬性" class="headerlink" title="on-event 處理器 (非 HTML 屬性)"></a>on-event 處理器 (非 HTML 屬性)</h3><p>像是 <code>window</code> 或 <code>document</code> 這種沒有實體元素的情況，還是可以透過 <code>DOM API</code> 提供的 <code>on-event</code> 處理器 來處理事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">          </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="事件監聽-EventTarget-addEventListener"><a href="#事件監聽-EventTarget-addEventListener" class="headerlink" title="事件監聽 EventTarget.addEventListener()"></a>事件監聽 <code>EventTarget.addEventListener()</code></h3><p>事件監聽 <code>EventTarget.addEventListener()</code> 包含三個參數</p><ul><li>事件名稱</li><li>事件的處理器 <code>event handler</code> (事件觸發時執行的 function )</li><li>布林值 : 如果沒有寫預設值就是 <code>false</code> 代表 事件冒泡，反之，<code>true</code> 代表 事件捕獲</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventTarget.addEventListener(<span class="string">&#x27;事件名稱&#x27;</span>, <span class="string">&#x27;事件的處理器(function)&#x27;</span>, <span class="literal">true</span>/<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><strong>指定多個 處理器 handler</strong></p><p>事件監聽 .addEventListener 的好處事可以重複指定多個 事件處理器 event handler 給同一個元素的同一個事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.adaEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">btn.adaEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;World&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure><h3 id="解除事件註冊-EventTarget-removeEventListener"><a href="#解除事件註冊-EventTarget-removeEventListener" class="headerlink" title="解除事件註冊 EventTarget.removeEventListener()"></a>解除事件註冊 <code>EventTarget.removeEventListener()</code></h3><p>解除事件註冊 <code>removeEventListener</code> 與 事件監聽 <code>addEventListener</code> 一樣包含三個參數，分別是 “事件名稱”、”事件處理器” 和 “冒泡/捕獲”</p><p>但要注意的是，<code>removeEventListener</code> 要移除的事件要確定是與 <code>addEventListener</code> 綁定的是同一個 實體，否則無法移除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件，但沒有用</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>如果是透過變數將 事件處理 <code>event handler</code> 拉出來，兩者就會指向 “同一個實體”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br><span class="line">              </span><br><span class="line"><span class="comment">// 成功移除</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, clickHandler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="事件處理器中的事件"><a href="#事件處理器中的事件" class="headerlink" title="事件處理器中的事件"></a>事件處理器中的事件</h2><p>當我們透過 <code>addEventListener</code> 來註冊事件時，會有三個參數，分別是 事件名稱、事件處理器 (Event Handler) 以及 捕獲/冒泡</p><h3 id="事件處理器中的事件介紹"><a href="#事件處理器中的事件介紹" class="headerlink" title="事件處理器中的事件介紹"></a>事件處理器中的事件介紹</h3><p>同時，事件監聽器 <code>EventListener</code> 會建立一個事件物件 <code>Event Object</code>，這個物件包含所有與事件有關的屬性，並以 參數 的形式回傳給 <code>Event Handler</code></p><p>如下範例，參數 <code>e</code> 就是 事件物件，透過 <code>console.log</code> 我們可以查看所有與事件有關的屬性，<code>e</code> 是參數，所以當然可以自定義名稱</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p><img src="event.png"></p><ul><li><code>typeof</code> : 事件名稱</li><li><code>target</code> : 觸發事件的元素</li><li><code>bubbles</code> : 事件是否在冒泡階段觸發 ( true/false )</li><li><code>pageX / page Y</code> : 事件觸發時，滑鼠座標在網頁上的相對位置</li></ul><h3 id="取消預設行為-event-preventDefault"><a href="#取消預設行為-event-preventDefault" class="headerlink" title="取消預設行為 event.preventDefault()"></a>取消預設行為 <code>event.preventDefault()</code></h3><p>如果我們需要在 <code>&lt;a&gt;</code> 或 <code>&lt;submit&gt;</code> 等上綁定事件，就需要適當的取消他們的預設行為</p><p>如下範例，我們想要在點擊這個連結的時候，瀏覽器執行 <code>console.log(&#39;Google&#39;)</code>，而不是直接連結到 <code>Google</code> 首頁，就可以使用 <code>preventDefault()</code> 來取消 <code>&lt;a&gt;</code> 的預設行為</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.google.com&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#link&#x27;</span>);</span><br><span class="line"></span><br><span class="line">link.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault();   <span class="comment">// 取消預設行為</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Google&#x27;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="阻擋事件冒泡傳遞-enent-stopPropagation"><a href="#阻擋事件冒泡傳遞-enent-stopPropagation" class="headerlink" title="阻擋事件冒泡傳遞 enent.stopPropagation"></a>阻擋事件冒泡傳遞 <code>enent.stopPropagation</code></h3><p>當 “子元素” 和 “父元素” 有 相同的事件 ，我們希望觸發子元素的事件時不要觸發到父元素的事件，就可以使用到 <code>event object</code> 提供的另一個方法 <code>event.stopPropagation</code> 來阻擋事件向上冒泡</p><p>如下範例，有時候為了增加 <code>checkbox</code> 的靈活性，會使用 <code>label</code> 包住的寫法，當我們在 label 和 <code>checkbox</code> 上都註冊 <code>click</code> 事件時，會發現 <code>label</code> 上的事件執行了兩次</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;label&quot;</span>&gt;</span></span><br><span class="line">  Label <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> label = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> checkobx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;checkbox&#x27;</span>);</span><br><span class="line"></span><br><span class="line">lable.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;label click&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">checkbox.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;checkbox click&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line"><span class="string">&#x27;label click&#x27;</span></span><br><span class="line"><span class="string">&#x27;checkbox click&#x27;</span></span><br><span class="line"><span class="string">&#x27;label click&#x27;</span></span><br></pre></td></tr></table></figure><p>如上範例，<code>label</code> 會執行兩次是因為當我們點擊 <code>label</code> 時，瀏覽器會自動將 <code>click</code> 事件傳給 <code>checkbox</code>，而 <code>checkbox</code> 受到事件冒泡影響，又會將 <code>click</code> 傳給上層的 <code>label</code>，所以執行了兩次</p><p>要解決這個問題，只要在 <code>checkbox</code> 加上 <code>e.stopPropagation()</code>，就可以阻擋 <code>checkbox</code> 向上傳遞的事件冒泡</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> label = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> checkobx = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;checkbox&#x27;</span>);</span><br><span class="line">            </span><br><span class="line">lable.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;label click&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">            </span><br><span class="line">checkbox.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line">            </span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line"><span class="string">&#x27;label click&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="事件中的自己-this-與-e-target"><a href="#事件中的自己-this-與-e-target" class="headerlink" title="事件中的自己 this 與 e.target"></a>事件中的自己 <code>this</code> 與 <code>e.target</code></h3><ul><li><code>this</code> : 透過 <code>this</code> 可以找到 觸發事件的目標 元素，也就是 <code>event.currentTarget</code></li><li><code>e.target</code> : 透過 <code>e.target</code> 可以找到 觸發事件的元素</li><li>大部分的情況 <code>this</code> 會和 <code>e.target</code> 指向同一個元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">id</span>=<span class="string">&quot;label&quot;</span>&gt;</span></span><br><span class="line">  Label <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> label = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"></span><br><span class="line">label.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.tagName);   <span class="comment">// &#x27;LABEL&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.tagName);       <span class="comment">// &#x27;LABEL&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>但如果是 “傳遞” 的情況兩者指向的元素就會有所不同</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> label = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;label&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> checkbox = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;checkbox&#x27;</span>);</span><br><span class="line"></span><br><span class="line">label.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.tagName, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.tagName, <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">checkbox.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.tagName, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.tagName, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line"><span class="string">&quot;LABEL 1&quot;</span></span><br><span class="line"><span class="string">&quot;LABEL 1&quot;</span></span><br><span class="line"><span class="string">&quot;INPUT 2&quot;</span></span><br><span class="line"><span class="string">&quot;INPUT 2&quot;</span></span><br><span class="line"><span class="string">&quot;INPUT 1&quot;</span></span><br><span class="line"><span class="string">&quot;LABEL 1&quot;</span></span><br></pre></td></tr></table></figure><p>前兩組結果可以輕易理解為 <code>label</code> 和 <code>checkbox</code> 各觸發一次 <code>click</code> 事件</p><p>但最後一組結果就不一樣了，由 <code>1</code> 可以判斷這組結果是 <code>checkbox</code> 經由 “事件冒泡” 傳遞給 <code>label</code> 所觸發的事件</p><p>這裡的 <code>e.target</code> 指的是 觸發事件的元素，也就是觸發事件冒泡的 <code>checkbox</code></p><p>而 <code>this</code> 指的是 觸發事件的目標元素，也就是事件冒泡 的目標 <code>label</code></p><h3 id="事件指派-Event-Delegation"><a href="#事件指派-Event-Delegation" class="headerlink" title="事件指派 Event Delegation"></a>事件指派 <code>Event Delegation</code></h3><p>事件指派 指的是透過前面介紹的 “事件流程” 和 “單一事件監聽器” 來處理多個事件目標</p><p>如下範例，我們為 <code>myList</code> 的 <code>li</code> 綁定 <code>click</code> 事件，就要透過 <code>for</code> 迴圈來一一綁定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 01<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 02<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 03<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得容器</span></span><br><span class="line"><span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myList&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分別為 li 綁定事件</span></span><br><span class="line"><span class="keyword">if</span> ( myList.hasChildNodes() )&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, i &lt; myList.childNodes.length, i++ )&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nodeType === 1 代表為實體 HTML 元素</span></span><br><span class="line">    <span class="keyword">if</span> ( myList.childNodes[i].nodeType === <span class="number">1</span> )&#123;</span><br><span class="line">      myList.childNodes[i].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.textContent);</span><br><span class="line">      &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立新的 li 元素</span></span><br><span class="line"><span class="keyword">var</span> newList = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立文字節點</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello Wordl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 文字結點 加入新增的 li 元素</span></span><br><span class="line">newList.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將新增的 li 元素加入 myList</span></span><br><span class="line">myList.appendChild(newList);</span><br></pre></td></tr></table></figure><p>這時會發生一個問題，新增的 <code>li</code> 並不會有 <code>click</code> 事件的註冊</p><p>如果每次新增新的 <code>li</code> 都要新增新的事件監聽 <code>addEventListener</code>，不僅沒完沒了，沒有移除舊的事件監聽可能會發生錯誤</p><p>因此透過 事件指派 <code>Event Delegation</code> 是比較好的做法</p><p>如下範例，我們是將 <code>click</code> 事件改由外層的 <code>myList</code> 來監聽，利用事件傳遞的原理來取得目標結點，所以後續新增的 <code>li</code> 也會有 <code>click</code> 事件的效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得容器</span></span><br><span class="line"><span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myList&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改由外層 myList 來監聽 click 事件</span></span><br><span class="line">myList.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.target.tagName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.textContent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/ 建立新的 li 元素</span><br><span class="line"><span class="keyword">var</span> newList = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立文字節點</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;Hello Wordl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 文字結點 加入新增的 li 元素</span></span><br><span class="line">newList.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將新增的 li 元素加入 myList</span></span><br><span class="line">myList.appendChild(newList);</span><br></pre></td></tr></table></figure><h2 id="事件的種類"><a href="#事件的種類" class="headerlink" title="事件的種類"></a>事件的種類</h2><p>事件的種類分為以下幾種</p><ul><li>介面相關事件</li><li>滑鼠相關事件</li><li>鍵盤相關事件</li><li>表單相關事件</li><li>特殊事件</li><li>自訂事件</li></ul><h3 id="介面相關事件"><a href="#介面相關事件" class="headerlink" title="介面相關事件"></a>介面相關事件</h3><p>介面事件不一定與使用者對 <code>DOM</code> 的操作有關，反而大多數與 <code>window</code> 物件比較相關</p><h4 id="load"><a href="#load" class="headerlink" title="load"></a>load</h4><p>註冊在 <code>window</code> 物件上，指的是網頁資源 (包括 CSS、JS、圖片等)，全數載入後觸發。</p><p>如果是 <code>img</code> 元素的 <code>load</code> 事件，就代表是在圖片載入後觸發</p><h4 id="unload-與-beforeunload"><a href="#unload-與-beforeunload" class="headerlink" title="unload 與 beforeunload"></a>unload 與 beforeunload</h4><p><code>unload</code> 和 <code>beforeunload</code> 分別會在離開頁面或重新整理時觸發，<code>beforeunload</code> 會跳出對話框詢問使用者是否確定要離開</p><p><img src="beforeunload.png"></p><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>error 事件會在 document 或圖片載入錯誤時觸發。</p><p>基於維護性考量，大部分的 JS 建議都使用 非侵入式 JS 的寫法，也就是另外寫 <code>&lt;script&gt;</code>，但 <code>error</code> 反而很適合以 <code>on-event handler</code> 的寫法來處理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.jpg&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;this.src=&#x27;default.jpg&#x27;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上範例，當 image.jpg 不存在的時候，就會觸發 error 事件，此時會透過 this.src 將 src 屬性替換成 default.jpg</p><p>如果是在 <code>load</code> 完成後才註冊 <code>error</code> 事件，就只會看到破圖的結果，因為 <code>error</code> 事件不會再度被觸發，所以後來掛上的 <code>handler</code> 形同虛設</p><h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>當瀏覽器 <code>window</code> 或指定元素 <code>element</code> 的 “尺寸變更” 時觸發</p><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><p>當瀏覽器 <code>window</code> 或指定元素 <code>element</code> 的 “卷軸被拉動” 時觸發</p><h4 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h4><p>和 <code>load</code> 事件類似，不同的是，<code>load</code> 是在網頁的所有資源載入後才會觸發，而 <code>DOMContentLoaded</code> 是在 <code>DOM</code> 結構被完整的讀取和解析後就會被觸發</p><p>一般來說如果將 <code>&lt;script&gt;</code> 放在 <code>&lt;head&gt;</code> 之間，會發生讀取不到 DOM 的問題，但如果使用 <code>DOMContentLoaded</code>，就可以排除這個問題了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 當 document 結構已解析完成才會執行</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&#x27;hello&#x27;</span>).textContent = <span class="string">&#x27;Hello&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="滑鼠相關事件"><a href="#滑鼠相關事件" class="headerlink" title="滑鼠相關事件"></a>滑鼠相關事件</h3><h4 id="click"><a href="#click" class="headerlink" title="click"></a>click</h4><p>當滑鼠點擊某元素時觸發</p><h4 id="dblclick"><a href="#dblclick" class="headerlink" title="dblclick"></a>dblclick</h4><p>當滑鼠 “連點兩次” 時觸發</p><h4 id="mouseenter-mousemove-mouseleave-不支援事件冒泡"><a href="#mouseenter-mousemove-mouseleave-不支援事件冒泡" class="headerlink" title="mouseenter/mousemove/mouseleave 不支援事件冒泡"></a>mouseenter/mousemove/mouseleave 不支援事件冒泡</h4><p>這三個事件並 “不支援事件冒泡”，也就是無法藉由綁定父元素來觸發子元素的事件</p><ol><li><code>mouseenter</code> : 當滑鼠 “移入” 這個元素時觸發</li><li><code>mousemove</code>: 當滑鼠在這個元素內 “移動” 時觸發</li><li><code>mouseleave</code>: 當滑鼠 “移出” 這個元素時觸發</li></ol><p><a href="https://codepen.io/Jerry-Yeh/pen/zVbKBK?editors=1010">範例程式碼 (mousemove)</a><br><a href="https://codepen.io/Jerry-Yeh/pen/zVbWaO">範例程式碼 (網頁座標)</a></p><h4 id="mouseover-mouseout-支援事件冒泡"><a href="#mouseover-mouseout-支援事件冒泡" class="headerlink" title="mouseover/mouseout 支援事件冒泡"></a>mouseover/mouseout 支援事件冒泡</h4><p>和 <code>mouseover/mouseout</code> 對應的就是 <code>mouseenter/mouseleave</code>，但不同的地方在於 <code>mouseover/mouseout</code> 支援冒泡事件，也就是可以藉由綁定父元素來觸發子元素事件</p><h3 id="鍵盤相關事件"><a href="#鍵盤相關事件" class="headerlink" title="鍵盤相關事件"></a>鍵盤相關事件</h3><p>鍵盤事件分成三種，大多數情況會註冊在 <code>input</code> 上</p><h4 id="keydown"><a href="#keydown" class="headerlink" title="keydown"></a>keydown</h4><p>當 “壓下” 按鍵時觸發</p><h4 id="keypress"><a href="#keypress" class="headerlink" title="keypress"></a>keypress</h4><p>當按著不放時會連續觸發</p><h4 id="keyup"><a href="#keyup" class="headerlink" title="keyup"></a>keyup</h4><p>當 “放開” 按鍵時觸發</p><p>如果同一個元素綁定了這三個鍵盤事件，觸發順序為 <code>keydown=&gt;keypress=&gt;keyup</code></p><h4 id="keycode"><a href="#keycode" class="headerlink" title="keycode"></a>keycode</h4><p>每個按鍵都有自己的代號，透過 keycode 可以知道每個按鍵的代號，進而指定按鍵來觸發</p><p><a href="https://keycode.info/">keycode 對照</a><br><a href="https://codepen.io/Jerry-Yeh/pen/LKaxxp">範例程式碼</a></p><h3 id="表單相關事件"><a href="#表單相關事件" class="headerlink" title="表單相關事件"></a>表單相關事件</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><p>當 input、textarea 以及帶有 contenteditable 的元素內容被改變時，就會觸發 input 事件</p><h4 id="change"><a href="#change" class="headerlink" title="change"></a>change</h4><p>當 input、select、textarea、radio、checkbox 等被改變時觸發。與 input 不同的是， input 事件會在輸入框輸入內容的當下觸發，而 <code>change</code> 事件則是在目前焦點離開輸入框後才觸發</p><p><a href="https://codepen.io/Jerry-Yeh/pen/QXoqPq?editors=1010">範例程式碼</a></p><h4 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h4><p>當表單被送出時觸發，通常表單驗證都會在這一步處理，驗證未過則 <code>return false</code></p><h4 id="focus"><a href="#focus" class="headerlink" title="focus"></a>focus</h4><p>元素被聚焦時觸發</p><h4 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h4><p>當元素失去焦點時觸發</p><h3 id="特殊事件"><a href="#特殊事件" class="headerlink" title="特殊事件"></a>特殊事件</h3><h4 id="Composition-Event-組成事件"><a href="#Composition-Event-組成事件" class="headerlink" title="Composition Event 組成事件"></a>Composition Event 組成事件</h4><p>透過 組成事件 Composition Event，可以將輸入的過程分的更細，針對每個環節綁定不同的事件。組成事件分為以下三種:</p><ol><li><code>compositionstart</code></li></ol><p>  輸入框內開啟輸入法，且 正在拼音時 觸發</p><ol start="2"><li><code>compositionupdate</code></li></ol><p>  輸入框內開啟輸入法，且 正在拼音時 或 選字時 更改了內容觸發</p><ol start="3"><li><code>compositionend</code></li></ol><p>  輸入框內開啟輸入法，且拼字獲選字 完成 時觸發</p><p><a href="https://codepen.io/Jerry-Yeh/pen/EBMEYM?editors=0010">範例程式碼</a></p><h3 id="自訂事件"><a href="#自訂事件" class="headerlink" title="自訂事件"></a>自訂事件</h3><ul><li>使用 <code>Event constructor</code> 建立</li><li>同樣透過 <code>addEventListener</code> 來監聽</li><li>由 <code>dispatchEvent</code> 決定事件觸發的時機</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自訂事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;build&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 監聽事件</span></span><br><span class="line">element.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;...&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 觸發事件</span></span><br><span class="line">element.dispatchEvent(event);</span><br></pre></td></tr></table></figure><ul><li>如果要在自訂事件內增加更多資料，可以改用 CustomEvent 來自訂事件，Event Handler 就可以透過 event 來接收</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自訂事件</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;build&#x27;</span>, &#123;<span class="string">&#x27;detail&#x27;</span>: element.dataset.time&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件監聽</span></span><br><span class="line">element.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;The time is&#x27;</span> + e.detail);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h3><p>其他的事件可以參考 <code>MDN</code> 的 <a href="https://developer.mozilla.org/en-US/docs/Web/Events">Event reference</a></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://ithelp.ithome.com.tw/users/20065504/ironman/1259">重新認識 JavaScript</a><br><a href="https://ithelp.ithome.com.tw/users/20083608/ironman/1354">邁向 JavaScript 勇者之路</a><br><a href="https://www.udemy.com/javascript-learning/">JavaScript 入門篇 - 學徒的試煉</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瀏覽器裡的 JavaScript</title>
      <link href="/javascript/20190928/32632/"/>
      <url>/javascript/20190928/32632/</url>
      
        <content type="html"><![CDATA[<p>前端開發在網頁的操作方法其實都是由 JS 的執行平台，也就是 瀏覽器 所提供，操作方法分別由 <code>BOM</code> 和 <code>DOM</code> 這兩種物件所擁有，而 JavaScript 就是透過 <code>BOM</code> 和 <code>DOM</code> 所提供的 <code>API</code> 來控制瀏覽器的行為與網頁的內容</p><span id="more"></span><h2 id="瀏覽器裡的-JavaScript-實際包含"><a href="#瀏覽器裡的-JavaScript-實際包含" class="headerlink" title="瀏覽器裡的 JavaScript 實際包含"></a>瀏覽器裡的 JavaScript 實際包含</h2><ul><li><code>JavaScript 核心</code> (以 ECMAScript 標準為基礎)</li><li><code>BOM</code> (Browser Object Model，瀏覽器物件模型)</li><li><code>DOM</code> (Document Object Model，文件物件模型)</li></ul><h2 id="什麼是-DOM-Document-Object-Modal"><a href="#什麼是-DOM-Document-Object-Modal" class="headerlink" title="什麼是 DOM (Document Object Modal) ?"></a>什麼是 DOM (Document Object Modal) ?</h2><ul><li><p><code>DOM</code> 是一個將 <code>HTML</code> 文件以樹狀結構來表示的模型，而組合起來的樹狀圖我們稱為 <code>DOM Tree</code></p></li><li><p>每個 <code>HTML</code> 檔案 都會產生一個 <code>document</code></p></li><li><p>每個 <code>HTML</code> 標籤 都會產生一個 節點，往下又可以再延伸出 文本節點 和 屬性節點</p></li><li><p>如下，我們寫了一段網頁程式碼，就會產生這樣的 <code>DOM</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>MyTitle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>MyLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="DOM.png"></p></li></ul><h2 id="什麼是-BOM-Browser-Object-Modal"><a href="#什麼是-BOM-Browser-Object-Modal" class="headerlink" title="什麼是 BOM (Browser Object Modal) ?"></a>什麼是 BOM (Browser Object Modal) ?</h2><ul><li><code>BOM</code> 是瀏覽器所有功能的核心，與網頁內容無關</li><li><code>BOM</code> 的核心是 <code>window</code> 物件</li><li><code>window</code> 物件提供的屬性為 <code>document</code>、<code>location</code>、<code>navigator</code>、<code>screen</code>、<code>history</code> 和 <code>frames</code></li><li><code>window</code> 中的 <code>document</code> 屬性就是 <code>DOM</code></li></ul><p><img src="BOM.png"></p><ul><li><p><code>BOM</code> 是 <code>ECMAScript</code> 標準裡的 “全域物件”，所有在 “全域作用範圍” 內宣告的變數、物件、函式等，都會自動變成 全域物件 的 屬性 ，也就是 “全域變數”，可以透過 <code>window.</code> 的方式取得</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p>在全域範圍宣告的變數無法使用 <code>delete</code> 來刪除，但透過 <code>window.</code> 來指定的物件屬性就可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">window</span>.b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.a;   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.b;   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p><code>window</code> 物件下的屬性，是可以省略 <code>window</code> 不打的，如常見的 <code>alert</code> 完整語法是這樣的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">&quot;message&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="DOM-與-BOM-的區別"><a href="#DOM-與-BOM-的區別" class="headerlink" title="DOM 與 BOM 的區別"></a>DOM 與 BOM 的區別</h2><ul><li><code>BOM</code> : JavaScript 與瀏覽器構通的窗口，不涉及網頁內容</li><li><code>DOM</code> : JavaScript 用來控制網頁的節點與內容的 標準</li><li><code>BOM 規範</code>: 依賴於各家瀏覽器已經實作的部分納入 <code>HTML 5</code> 標準中，也就是 <code>BOM API</code></li><li><code>DOM 規範</code>: 透過 <code>W3C</code> 所制定的標準來規範</li></ul><h2 id="DOM-API-節點控制"><a href="#DOM-API-節點控制" class="headerlink" title="DOM API 節點控制"></a>DOM API 節點控制</h2><h3 id="DOM-節點的選取"><a href="#DOM-節點的選取" class="headerlink" title="DOM 節點的選取"></a>DOM 節點的選取</h3><ul><li><p><code>document.getElementById(&#39;xxx&#39;)</code></p><p>可以選取 <code>DOM</code> 中 <code>ID</code> 為 “xxx” 的元素</p></li><li><p><code>document.getElementTagName(&#39;xxx&#39;)</code></p><p>針對給定的 <code>tag</code> 名稱，回傳所有符合的 <code>NodeList</code> 物件</p></li><li><p><code>document.getElementClassName(&#39;xxx&#39;)</code></p><p>針對給定的 <code>class</code> 名稱，回傳所有符合的 <code>NodeList</code> 物件</p></li><li><p><code>document.querySelector(&#39;xxx&#39;)</code></p><p>可以選取 <code>ID</code>、<code>class</code> 或 <code>HTML tag</code>，遇到相同名稱的元素只會選取第一個</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#id&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.class a&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>document.querySelectorAll(&#39;xxx&#39;)</code></p><p>可以重複選取多個元素，選取到的元素會形成一個 “陣列” ，可以透過 <code>for 迴圈</code> 給值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;titleClass&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;titleClass&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;titleClass&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>0123<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;titleClass&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>1123<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.titleClass em&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(el);   <span class="comment">// [em, em]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elLen = el.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; el &lt; elLen; i++)&#123;</span><br><span class="line">  el[i].textContent = i + <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="DOM-節點的新增"><a href="#DOM-節點的新增" class="headerlink" title="DOM 節點的新增"></a>DOM 節點的新增</h3><ul><li><p><code>innerHTML</code></p><p>組完字串後，傳進語法進行渲染，會直接取代原先的內容，如果外層是 單引號 <code>&#39;&#39;</code>，內層就要使用 雙引號 <code>&quot;&quot;</code> 以做區別</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                      </span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line">el.innerHTML = <span class="string">&#x27;&lt;h1 class=&quot;blue&quot;&gt;&lt;/h1&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>createElement</code></p><p>以 <code>DOM</code> 節點來處理，每個節點都須透過 <code>JavaScript</code> 來新增</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span>title<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">document</span>.createElement(<span class="string">&#x27;em&#x27;</span>);</span><br><span class="line">str.textContent = <span class="string">&#x27;1234&#x27;</span>;</span><br><span class="line">str.setAttribute(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 增加子節點</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.title&#x27;</span>).appendChild(str);</span><br></pre></td></tr></table></figure></li><li><p><code>innerHTML</code> 與 <code>createElement</code> 的差異</p><ul><li>因為 <code>innerHTML</code> 是組完字串一次帶入，所以效能較佳</li><li>也因為 <code>innerHTML</code> 透過組完字串帶入 <code>HTML</code>，所以在某些情況，如在輸入欄位輸入 <code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code> 等檔案載入形式，可能會遭到惡意植入攻擊程式碼，稱為 “XXS 跨網域指令碼 (Cross-site Scripting)”</li></ul></li></ul><h3 id="節點的修改與刪除"><a href="#節點的修改與刪除" class="headerlink" title="節點的修改與刪除"></a>節點的修改與刪除</h3><p>以上新增節點的方法只是建立節點，還未將建立的節點輸出到網頁中，透過以下方法，改變網頁中的節點</p><ul><li><code>Node.appendChild(&#39;子節點&#39;)</code></li></ul><p>透過這個方法可以將指定的 “子節點” 加入到父容器節點的末端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得容器</span></span><br><span class="line"><span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myList&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 li 元素</span></span><br><span class="line"><span class="keyword">var</span> newList = <span class="built_in">document</span>.creatElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立文字節點</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.creatTextNode(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將文字節點加入 li </span></span><br><span class="line">newList.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 li 子節點加入 #myList 父節點</span></span><br><span class="line">myList.appendList(newList);</span><br></pre></td></tr></table></figure><ul><li><code>NODE.insertBefore(&#39;新節點&#39;, &#39;指定節點&#39;)</code></li></ul><p>透過這個方法將 “新節點” 加到 “指定節點” 的 “前面”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得容器</span></span><br><span class="line"><span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myList&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得 &lt;li&gt;Item 2&lt;/li&gt; 元素</span></span><br><span class="line"><span class="keyword">var</span> refNode = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 li 元素節點</span></span><br><span class="line"><span class="keyword">var</span> newNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立文字節點</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.creatTextNode(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">newNode.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將&#x27;新節點&#x27;插入到 &#x27;指定節點&#x27; 的 前方</span></span><br><span class="line">myList.insertBefore(newNode, refNode);</span><br></pre></td></tr></table></figure><ul><li><code>NODE.replaceChild(&#39;新節點&#39;, &#39;指定節點&#39;)</code></li></ul><p>透過這個方法將 “新節點” 取代 “指定節點”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                  </span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得容器</span></span><br><span class="line"><span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myList&#x27;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 取得 &lt;li&gt;Item 2&lt;/li&gt; 元素</span></span><br><span class="line"><span class="keyword">var</span> refNode = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 建立 li 元素節點</span></span><br><span class="line"><span class="keyword">var</span> newNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 建立文字節點</span></span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.creatTextNode(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">newNode.appendChild(textNode);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 將&#x27;新節點&#x27; 取代 &#x27;指定節點&#x27; </span></span><br><span class="line">myList.replaceChild(newNode, refNode);</span><br></pre></td></tr></table></figure><ul><li><code>NODE.removeChild(&#39;指定節點&#39;)</code></li></ul><p>透過這個方法將 “指定節點” 移除</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                    </span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得容器</span></span><br><span class="line"><span class="keyword">var</span> myList = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myList&#x27;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 取得 &lt;li&gt;Item 2&lt;/li&gt; 元素</span></span><br><span class="line"><span class="keyword">var</span> removeNode = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 將&#x27;#myList&#x27; 下的 &#x27;指定節點&#x27; 移除 </span></span><br><span class="line">myList.removeChild(removeNode);</span><br></pre></td></tr></table></figure><h3 id="新增節點屬性"><a href="#新增節點屬性" class="headerlink" title="新增節點屬性"></a>新增節點屬性</h3><p><code>setAttribute(&#39;屬性&#39;, &#39;新增的值&#39;)</code> : 動態為 html tag 增加屬性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;titleClass&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- after js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;titleClass&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.google.com/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.titleClass a&#x27;</span>);</span><br><span class="line">el.setAttribute(<span class="string">&#x27;href&#x27;</span>, <span class="string">&#x27;http://www.google.com&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="DOM-節點的類型"><a href="#DOM-節點的類型" class="headerlink" title="DOM 節點的類型"></a>DOM 節點的類型</h2><p>DOM 節點的類型常見的有以下幾種 :</p><table>  <thead>    <tr>      <th>節點類型常數</th>      <th>對應數值</th>      <th>說明</th>    </tr>  </thead>  <tbody>    <tr>      <td>Node.ELEMENT_NODE</td>      <td>1</td>      <td>HTML 元素的 Element 節點</td>    </tr>    <tr>      <td>Node.TEXT_NODE</td>      <td>3</td>      <td>實際文字節點，包括了換行與空格</td>    </tr>    <tr>      <td>Node.COMMENT_NODE</td>      <td>8</td>      <td>註解節點</td>    </tr>    <tr>      <td>Node.DOCUMENT_NODE</td>      <td>9</td>      <td>根節點 (Document)</td>    </tr>    <tr>      <td>Node.DOCUMENT_TYPE_NODE</td>      <td>10</td>      <td>文件類型的 DocumentType 節點，例如 HTML5 的 <code>&lt;!DOCTYPE html&gt;</code></td>    </tr>    <tr>      <td>Node.DOCUMENT_FRAGMENT_NODE</td>      <td>11</td>      <td>DocumentFragment 節點</td>    </tr>  </tbody></table><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType">Node.nodeType</a></p><h2 id="DOM-API-節點間的查找"><a href="#DOM-API-節點間的查找" class="headerlink" title="DOM API 節點間的查找"></a>DOM API 節點間的查找</h2><p>DOM 節點有分層的概念，節點與節點之間的關係分成兩種</p><ul><li><code>父子節點</code> : 每個節點的上層節點稱為 父節點 <code>Parent node</code> ; 相對地，下層的節點稱為子節點 <code>Child node</code>，而隔層的節點基本上沒有直接關係，也就是 不具備孫節點</li><li><code>兄弟節點</code> : 如果節點與節點有同一個 父節點，那彼此就是 兄弟節點 <code>Siblings node</code></li></ul><h3 id="子節點"><a href="#子節點" class="headerlink" title="子節點"></a>子節點</h3><p><code>Node.childNodes</code> 與 <code>Node.children</code> 所有子節點</p><ul><li><p>所有的 <code>DOM</code> 節點都包含 <code>childNodes</code> 屬性，此種屬性無法被修改。</p></li><li><p>可以透過 <code>Node.hasChildNodes()</code> 來檢查某個 <code>DOM</code> 節點是否有子節點，如果有會回傳 <code>true</code>，否則 <code>false</code></p></li><li><p><code>Node.childNodes</code> 回傳的是 <code>NodeList</code>，包含以下三、可能</p><ul><li>HTML 元素節點 (element nodes)</li><li>文字節點 (text nodes)，包含空白</li><li>註解節點 (comment nodes)</li></ul></li><li><p><code>Node.children</code> 回傳的是 <code>HTMLColllection</code> 只包含一種可能就是 “HTML 元素節點 (element nodes)”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  我是第一個子節點 ( 文本節點 )</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是第二個子節點 ( 第一個 元素節點 )<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  我是第三個子節點 ( 文本節點 )</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是第四個子節點 ( 第二個 元素節點 )<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 我是註解 (註解節點)--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是第五個子節點 ( 第三個 元素節點 )，但我前面有空行</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是第五個子節點的子節點<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test.childNodes.length);   <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(test.childNodes);   <span class="comment">// NodeList(9) [text, div, text, div, text, comment, text, div, text]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.childNodes[<span class="number">7</span>].hasChildNodes());   <span class="comment">// true</span></span><br><span class="line">              </span><br><span class="line"><span class="built_in">console</span>.log(test.children.length);   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(test.children);   <span class="comment">// HTMLCollection(3) [div, div, div]</span></span><br></pre></td></tr></table></figure></li><li><p><code>Node.firstChild</code> 第一個子節點</p><p><code>Node.firstChild</code> 可以取得 <code>Node</code> 節點的 第一個子節點，沒有子節點則會回傳 <code>null</code></p><p>如下範例取得的第一個子節點為 <code>&lt;p&gt;</code> 與 <code>&lt;span&gt;</code> 中間的 “換行字元”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.firstChild.tagName);   <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.firstChild.textContent);   <span class="comment">// </span></span><br></pre></td></tr></table></figure><p>如果把中間的換行與空白移除，就會得到預期的 <code>SPAN</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(p.firstChild.tagName);   <span class="comment">// SPAN</span></span><br><span class="line"><span class="built_in">console</span>.log(p.firstChild.textContent);   <span class="comment">// span1</span></span><br></pre></td></tr></table></figure></li><li><p><code>Node.lastChild</code> 最後一個子節點</p></li></ul><p><code>Node.lastChild</code> 可以取得 Node 節點的 “最後一個” 子節點，沒有子節點則會回傳 <code>null</code></p><p>概念同 <code>Node.firstChild</code>，取得的子節點包含 “空白節點”</p><h3 id="父節點"><a href="#父節點" class="headerlink" title="父節點"></a>父節點</h3><p><code>Node.parentNode</code> 父節點</p><p><code>Node.parentNode</code> 可以用來取得 “父節點”，回傳值可能回以下三種</p><ul><li><p>HTML 元素節點 (Element node)</p></li><li><p>根節點 (Document node)</p></li><li><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/DocumentFragment">DocumentFragment</a> 節點 (詳細介紹可以參考此連結)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(el.parentNode.nodeName);   <span class="comment">// &quot;P&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="兄弟節點"><a href="#兄弟節點" class="headerlink" title="兄弟節點"></a>兄弟節點</h3><ul><li><p><code>Node.previousSibling</code> 和 <code>Node.nextSibling</code> 兄弟節點(包含所有節點)</p><p>透過 <code>Node.previousSibing</code> 和 <code>Node.nextSibling</code> 分別可以取得同層的 “前一個” 與 “下一個” 節點，如果 Node 沒有前一個或下一個節點，則會回傳 <code>null</code> ; 特別注意的是，這兩個語法包含 “所有節點”，也就是包含 “空白節點”、”文字節點” 和 “元素節點”</p><p><code>querySelectorAll</code> 會選取所有符合的元素形成陣列，透過 中括號 <code>[]</code> 可以選取指定元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> el3 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( el.previousSibling );    <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log( el2.previousSibling.textContent );    <span class="comment">// &quot;span 2&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log( el3.previousSibling.textContent );    <span class="comment">// &quot;我是空白&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><code>Node.previousElementSibling</code> 和 <code>Node.nextElementSibling</code> 兄弟節點(只包含 “元素節點”)</p><p>和上一組尋找兄弟節點的語法在用法上相同，唯一不同的是，搜尋時只包括 “元素節點”，會忽略空白節點和文字節點，是比較實用的方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> el2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> el3 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span&#x27;</span>)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( el.previousElementSibling );    <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log( el2.previousElementSibling.textContent );    <span class="comment">// &quot;span 1&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log( el3.previousElementSibling.textContent );    <span class="comment">// &quot;span 2&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="document-getElementsBy-與-document-querySelector-querySelectorAll-的差異"><a href="#document-getElementsBy-與-document-querySelector-querySelectorAll-的差異" class="headerlink" title="document.getElementsBy** 與 document.querySelector/.querySelectorAll 的差異"></a><code>document.getElementsBy**</code> 與 <code>document.querySelector/.querySelectorAll</code> 的差異</h3><p><code>document.getElementsBy**</code> 與 <code>Node.childNodes</code> 回傳的同樣是 <code>NodeList</code> 包含以下三種可能</p><ul><li>HTML 元素節點 (element nodes)</li><li>文字節點 (text nodes)，包含空白</li><li>註解節點 (comment nodes)</li></ul><p><code>document.getElementsBy**</code> 和 <code>Node.children</code> 回傳的同樣是 <code>HTMLCollection</code>，只有一種可能</p><ul><li>HTML 元素節點 (element nodes)</li></ul><p><code>HTHLCollection</code> 與 <code>NodeList</code> 都可以使用 “陣列索引” 來存取內容，兩者在大部分的情況下也都是 “即時更新” 的，但透過 <code>document.querySelector/doucment.querySelectorAll</code> 取得的 <code>NodeList</code> 是 “靜態的”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outerDiv = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;outer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allDivs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> allDivs2 = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            </span><br><span class="line"><span class="built_in">console</span>.log(allDivs.length);   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(allDivs2.length);   <span class="comment">// 2</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 清空 &lt;div id=&quot;outer&quot;&gt; 下的節點</span></span><br><span class="line">outerDiv.innerHTML = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因為  &lt;div id=&quot;inner&quot;&gt; 被清空，所以只剩下 &lt;div id=&quot;outer&quot;&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(allDivs.length);   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 document.querySelectorAll 回傳的是 &quot;靜態&quot; 的 NodeList ，所以不受 outerDiv 更新影響</span></span><br><span class="line"><span class="built_in">console</span>.log(allDivs2.length);   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="BOM-API"><a href="#BOM-API" class="headerlink" title="BOM API"></a>BOM API</h2><h3 id="回上一頁功能實作-window-history"><a href="#回上一頁功能實作-window-history" class="headerlink" title="回上一頁功能實作 window.history"></a>回上一頁功能實作 <code>window.history</code></h3><p>透過 <code>window.history.forward()</code> 切換到下一頁，<code>window.history.back(</code>) 切換到上一頁，以此功能切換頁面</p><p><a href="https://codepen.io/Jerry-Yeh/pen/KjrgNW?editors=1010">範例程式碼</a></p><h3 id="列印功能-window-print"><a href="#列印功能-window-print" class="headerlink" title="列印功能 window.print()"></a>列印功能 window.print()</h3><p><a href="https://codepen.io/Jerry-Yeh/pen/ewQdPj">範例程式碼</a></p><h3 id="位置訊息-window-location"><a href="#位置訊息-window-location" class="headerlink" title="位置訊息 window.location"></a>位置訊息 window.location</h3><p><a href="https://codepen.io/Jerry-Yeh/pen/ewQdPj">範例程式碼</a></p><h3 id="移動位置-window-open"><a href="#移動位置-window-open" class="headerlink" title="移動位置 window.open()"></a>移動位置 window.open()</h3><p>使用此方法移動位置會 “開新分頁”</p><p><a href="https://codepen.io/Jerry-Yeh/pen/ewQdPj">範例程式碼</a></p><h3 id="動態擷取瀏覽器尺寸"><a href="#動態擷取瀏覽器尺寸" class="headerlink" title="動態擷取瀏覽器尺寸"></a>動態擷取瀏覽器尺寸</h3><ul><li><code>window.innerHeight</code> : 擷取瀏覽器內部高度</li><li><code>window.innerWidth</code> : 擷取瀏覽器內部寬度</li><li><code>window.outerHeight</code> : 擷取瀏覽器外部高度</li><li><code>window.outerWidth</code> : 擷取瀏覽器外部寬度</li><li><code>window.onresize</code> : 瀏覽器尺寸改變就會觸發</li></ul><p><a href="https://codepen.io/Jerry-Yeh/pen/mZQjxG">範例程式碼</a></p><h2 id="DOM-API"><a href="#DOM-API" class="headerlink" title="DOM API"></a>DOM API</h2><p><a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/541219/">JS 和 jquery 獲取各種螢幕的寬度和高度</a></p><h2 id="參考資料-1"><a href="#參考資料-1" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://ithelp.ithome.com.tw/users/20065504/ironman/1259">重新認識 JavaScript</a><br><a href="https://ithelp.ithome.com.tw/users/20083608/ironman/1354">邁向 JavaScript 勇者之路</a><br><a href="https://www.udemy.com/javascript-learning/">JavaScript 入門篇 - 學徒的試煉</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 設計模式</title>
      <link href="/css/20190927/6900c966/"/>
      <url>/css/20190927/6900c966/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>隨著網站逐漸開發，CSS 的程式碼也會越來越繁雜，如果沒有一套方法來管理 CSS，不僅在維護上不方便，程式碼也會變得難以重複使用</p><span id="more"></span><h3 id="為什麼我們需要-CSS-設計模式"><a href="#為什麼我們需要-CSS-設計模式" class="headerlink" title="為什麼我們需要 CSS 設計模式 ?"></a>為什麼我們需要 CSS 設計模式 ?</h3><p>如同收納術一般，當我們生活用品越積越多時，我們就需要一些收納的方法來管理，以便在尋找需要的用品時更容易<br>同樣的，在開發一個網站時，CSS 也會越寫越多，甚至是多人一起偕同開發，這時候如果沒有一套共同的方法或標準來管理我們的 CSS，就會使的開發與維護上效率低落，合作上也不容易快速理解別人的程式，甚至是之後自己看自己的程式碼也無法快速的理解當初的思考邏輯</p><h3 id="CSS-設計模式的特色"><a href="#CSS-設計模式的特色" class="headerlink" title="CSS 設計模式的特色"></a>CSS 設計模式的特色</h3><p>常見的 CSS 設計模式有 SMACSS、OOCSS 和 BEM，其目的都是為了達到命名語意化、可重用性高、後期維護容易和加載渲染快等優點</p><p>但方法是死的，提高工作效率才是唯一目的，如同我們不會為了整理好一個桌面而運用到畢生所學的 20 種收納方法吧 ?同樣的在運用 css 設計模式時，也是視各個專案的狀況來選擇要使用的模式，而非一味遵守這些方法使開發效率未獲提升</p><h3 id="良好的-CSS-設計模式"><a href="#良好的-CSS-設計模式" class="headerlink" title="良好的 CSS 設計模式"></a>良好的 CSS 設計模式</h3><p>一個良好的 CSS 設計模式會具備以下特質</p><ul><li>預測性 - Predictable</li><li>複用性 - Reusable</li><li>維護性 - Maintainable</li><li>延展性 - Scalable</li></ul><h2 id="SMACSS-Scalable-and-Modular-Architecture-for-CSS"><a href="#SMACSS-Scalable-and-Modular-Architecture-for-CSS" class="headerlink" title="SMACSS (Scalable and Modular Architecture for CSS)"></a>SMACSS (Scalable and Modular Architecture for CSS)</h2><h3 id="SMACSS-介紹"><a href="#SMACSS-介紹" class="headerlink" title="SMACSS 介紹"></a>SMACSS 介紹</h3><p>SMACSS 顧名思義是將 CSS 模組化並提高可重用性，被模組化的 CSS 是獨立的，不會被父元素或是 ID 選擇器、標籤選擇器所綁定，能夠活用在頁面上各個地方，並將 CSS 結構分類</p><h3 id="SMACSS-分類"><a href="#SMACSS-分類" class="headerlink" title="SMACSS 分類"></a>SMACSS 分類</h3><p>SMACSS 分類會使用每個類別的前綴詞加以區分，例如 layout 裡面的 list 會寫成 <code>.l-list</code>，以提高辨識度快速搜尋相關 CSS</p><ul><li><h4 id="Base-全站設定"><a href="#Base-全站設定" class="headerlink" title="Base : 全站設定"></a>Base : 全站設定</h4><p>定義大部分的 CSS ，避免一直重複撰寫相同的 CSS 樣式，包含 CSS Reset、Reboot，以下為常見的全站設定<br>注意 Base 的 CSS 絕對不能使用 <code>!important</code> ，以免後續新增的 CSS 無法覆蓋</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html&#123;font-family:sans-serif&#125;</span><br><span class="line">a &#123;<span class="attr">color</span>: red;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><h4 id="Layout-網站布局"><a href="#Layout-網站布局" class="headerlink" title="Layout : 網站布局"></a>Layout : 網站布局</h4><p>所有頁面都會用到的內容，例如 header 與 footer，重複出現的內容以 “功能” 取代 “語意”，例如 書籍列表 與 DVD列表不會個別是 <code>.bookList</code> 與 <code>.dvdList</code>，而是統一為 <code>.list</code></p></li><li><h4 id="Module-模組化"><a href="#Module-模組化" class="headerlink" title="Module : 模組化"></a>Module : 模組化</h4><p>Module 是一個獨立的 CSS 組件，可以靈活運用在頁面的任何地方，不會綁定父元素、ID 選擇器和 HTML 標籤，直接將所有 CSS 寫在 class 上，不論要更動 HTML或新增 CSS 都會更有彈性<br>如下為一個名為 <code>.fld</code> 的模組，而兩個 <code>span</code> 隸屬於 <code>.fld</code> ，所以都以 <code>.fld-</code>做為開頭，在依據不同的需求各別寫入不同的 CSS，因為不是直接寫成 <code>.fld &gt; span</code> 所以後續新增的 <code>span</code> ，也不會受到影響而需要用更高的權重覆蓋</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fld&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fld-name&quot;</span>&gt;</span>Folder Name<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fld-items&quot;</span>&gt;</span>(32 items)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>為了方便 HTML 語意化調整，CSS 盡量不指定 HTML tag，以下為常見寫法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.l-grid</span> &#123;</span><br><span class="line">  <span class="selector-class">.l-gird</span> <span class="selector-tag">h2</span> &#123;...&#125;</span><br><span class="line">  <span class="selector-class">.l-gird</span> <span class="selector-tag">ul</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以寫成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.l-grid</span> &#123;</span><br><span class="line">  <span class="selector-class">.l-gird-title</span> &#123;...&#125;</span><br><span class="line">  <span class="selector-class">.l-gird-list</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此做法也可以優化 SEO，如下 <code>article</code> 的權重會大於 <code>div</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;.l-gird&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;l-gide-title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;l-gird&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;l-gide-title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h4 id="State-狀態"><a href="#State-狀態" class="headerlink" title="State : 狀態"></a>State : 狀態</h4><p>State 表達的是一個狀態，與 layout、 module 搭配，也常常利用 JavaScript 動態改變狀態，加上 <code>!important</code> 是因為有時候模組會有好幾層架構，防止 State 權重不足無法覆蓋</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.is-error</span>&#123;<span class="attribute">display</span>: block <span class="meta">!important</span>&#125;  </span><br><span class="line"><span class="selector-class">.is-hidden</span>&#123;<span class="attribute">display</span>:none <span class="meta">!important</span>&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Theme-主題"><a href="#Theme-主題" class="headerlink" title="Theme : 主題"></a>Theme : 主題</h4><p>運用在網站結構相同，但有多種的主題樣式時，Theme 不會在核心 CSS(all.css) 內，通常都會將其抽離(theme.css)，常見的變動有 color、background-color、border …等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//in html</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;all.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;theme.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//in all<span class="selector-class">.css</span></span><br><span class="line"><span class="selector-class">.mod</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> solid&#125;</span><br><span class="line"></span><br><span class="line">//in theme<span class="selector-class">.css</span></span><br><span class="line"><span class="selector-class">.mod</span> &#123;<span class="attribute">border</span>: red&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Typography-文字排版"><a href="#Typography-文字排版" class="headerlink" title="Typography : 文字排版"></a>Typography : 文字排版</h4><p>建議不要超過 6 種文字大小，以免網站失焦，在建立全域變數(Base)，可以將文字納入規則</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in base</span></span><br><span class="line"><span class="variable">$font-size-base</span>: <span class="number">14px</span> !default;</span><br><span class="line"><span class="variable">$font-l</span>: (<span class="variable">$font-size-base</span>) * <span class="number">1.25</span>;</span><br><span class="line"><span class="variable">$font-m</span>: <span class="variable">$font-size-base</span>;</span><br><span class="line"><span class="variable">$font-s</span>: (<span class="variable">$font-size-base</span>) * <span class="number">0.75</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="OOCSS-Object-Oriented-CSS"><a href="#OOCSS-Object-Oriented-CSS" class="headerlink" title="OOCSS (Object Oriented CSS)"></a>OOCSS (Object Oriented CSS)</h2><p>為鼓勵開發者使 CSS 複用性達到最高，用一套 CSS 即可持續開發，不需要隨著開發新增 CSS</p><h3 id="結構與樣式分離-Separate-Structure-and-Skin"><a href="#結構與樣式分離-Separate-Structure-and-Skin" class="headerlink" title="結構與樣式分離 (Separate Structure and Skin)"></a>結構與樣式分離 (Separate Structure and Skin)</h3><p>以 bootstrap 為例，<code>btn</code> 只包含結構，<code>btn-primary</code>提供顏色，<code>btn-lg</code> 增加大小，這樣的好處在於不用重複寫結構，只需要依據開發需求新增樣式即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-lg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或是常用到小技巧也可以使它成為獨立的樣式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.clearfix &#123;overflow: hidden;&#125;</span><br></pre></td></tr></table></figure><h3 id="容器與內容分離-Separate-Container-and-Content"><a href="#容器與內容分離-Separate-Container-and-Content" class="headerlink" title="容器與內容分離 (Separate Container and Content)"></a>容器與內容分離 (Separate Container and Content)</h3><p>常見的容器有 <code>header</code>、<code>footer</code>和格線系統等，與內容分離的好處在於內容不只能使用在特定容器，可以提高內容的複用性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><ul><li>使用 OOCSS 時，盡量不要用後代選擇器 (.header ul)，以免無法活用到其他 <code>html tag</code></li><li>網站規模小時不建議使用，因為設立各個獨立功能會消耗許多時間，後續開發沒有重複用到便失去它的意義</li></ul><h2 id="BEM-Block-Element-Modifier"><a href="#BEM-Block-Element-Modifier" class="headerlink" title="BEM (Block Element Modifier)"></a>BEM (Block Element Modifier)</h2><p><code>BEM</code> 由 <code>Block</code> (區塊)、<code>Element</code> (元素)、<code>Modifier</code> (修飾符)三者所構成，主義的功能是瀏覽 <code>HTML CODE</code> 時，可以透過 <code>class</code> 直接了解 CSS 架構與彼此的關係，不用去細看 CSS 才能了解</p><h3 id="BEM結構"><a href="#BEM結構" class="headerlink" title="BEM結構"></a>BEM結構</h3><ul><li><h4 id="Block-區塊"><a href="#Block-區塊" class="headerlink" title="Block (區塊)"></a>Block (區塊)</h4><p>Block 是模組的名稱，位於模組的最外層，為模組的容器，在設計網站時，我們會先設計出幾個區塊，再對其命名對應的語意</p><ul><li>不能使用 html tag 和 ID 選擇器，否則難以複用到其他地方</li><li>Block 名稱能清楚表達含意，使用 “功能” 取代 “語意”</li><li>每個 Block 獨立運作，不能依附在其他的 Block</li><li>不要定義過多影響外部的樣式 (如 margin)，因為複用到其他地方時不一定有相同的外部樣式</li><li>Block 可以複製到頁面上任何位位置，甚至互相嵌套，但不互相依賴</li></ul><p><img src="block.png"></p></li><li><h4 id="Element-元素"><a href="#Element-元素" class="headerlink" title="Element (元素)"></a>Element (元素)</h4><p><code>Block</code> 內部會有許多 <code>Element</code> (元素)，在區塊的後方加入雙下底線 <code>__</code> 以辨識此為該去塊內的元素</p><p>基本原則 :</p><ul><li>如果無法拿到 <code>Block</code> 外單獨使用，就應該為 <code>Element</code>，且不能相依於其他的 <code>Block</code></li><li><code>Element</code> 能簡單的表達出其結構、布局和意義，在語意上與 <code>Block</code> 相呼應</li><li>同一個 <code>Block</code> 的內 <code>Element</code> 與 <code>Element</code> 可以互相嵌套，靈活運用</li></ul><p><img src="element.png"></p></li><li><h4 id="Modifier-修飾符"><a href="#Modifier-修飾符" class="headerlink" title="Modifier (修飾符)"></a>Modifier (修飾符)</h4><p><code>Modifier</code> (修飾符)的觀念和 <code>SMACSS</code> 的 <code>State</code>、<code>OOCSS</code> 的樣式很類似，在區塊或元素後方加上雙中線 <code>--</code> 以辨識此為該區塊或元素的修飾符，修飾符改變的可以是狀態或是樣式，圖中 Tab3 具有不同的 modifier</p><p>基本原則 :</p><ul><li>能直觀的表達出其所代表的外觀和狀態</li><li>無法脫離 <code>Block</code> 和 <code>Element</code> 單獨使用，因為本身不具備結構</li><li>改變的僅是外觀和狀態，並不是替換結構</li><li>不會同時使用一個以上不同值的相同 Modifier，例如: <code>--red</code> 和 <code>--green</code></li></ul><p><img src="modifier.png"></p><p>常見表狀態的用法，此用法為布林值(boolean)，拿掉即是原始狀態</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn btn--active&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一種常見表樣式的用法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 顏色樣式</span><br><span class="line"><span class="selector-class">.btn--primary</span> &#123;...&#125;</span><br><span class="line"><span class="selector-class">.btn--secondary</span> &#123;...&#125;</span><br><span class="line">// 大小樣式</span><br><span class="line"><span class="selector-class">.btn-lg</span> &#123;...&#125;</span><br><span class="line"><span class="selector-class">.btn-m</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>不同值的樣式可以同時使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-lg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="連接符"><a href="#連接符" class="headerlink" title="連接符"></a>連接符</h3><ul><li><code>-</code> 中線 : 僅連接區塊的多單詞</li><li><code>__</code> 雙底線 : 用來連接 <code>Block</code> (區塊)與 <code>Element</code> (元素)</li><li><code>--</code> 雙中線 : 用來描述 <code>Block</code> (區塊)或 <code>Element</code> (元素)的狀態 (Modifier)</li></ul><h3 id="BEM-常見的問題"><a href="#BEM-常見的問題" class="headerlink" title="BEM 常見的問題"></a>BEM 常見的問題</h3><ul><li><p>可以單獨使用到的功能就不需要 BEM，例如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//清除浮動</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;over-flow: hidden&#125;</span><br><span class="line">//隱藏文字</span><br><span class="line"><span class="selector-class">.text-hide</span> &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">101%</span>;</span><br><span class="line">  over-flow: hidden;</span><br><span class="line">  text-trap: no-wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果沒有直接的關係，Element 可以不用重複嵌套，盡量避免超過四層，以免降低網頁渲染速度，例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;menu__list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu__list__item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu__list__item__link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以寫成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;menu__list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;menu__item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;menu__link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>沒有直接關係且會複用到頁面其他地方的 Block 應該獨立出來</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content__menu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以獨立成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加 <code>Element</code> 和 <code>Modifier</code> 時需要重複撰寫前面的 <code>Block</code> 與 <code>Element</code> 很麻煩 ?</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;...&#125;</span><br><span class="line"><span class="selector-class">.menu__list</span> &#123;...&#125;</span><br><span class="line"><span class="selector-class">.menu__item--active</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>Sass3 開始支援 <code>&amp;</code> 連接字串可以解決這個問題</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">&amp;__list &#123;...&#125;</span><br><span class="line">  &amp;__item &#123;</span><br><span class="line">    &amp;--active &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="guideline-指南"><a href="#guideline-指南" class="headerlink" title="guideline (指南)"></a>guideline (指南)</h2><p>當網站架構越來越大或多人協作時，我們就需要一套規範指南來使大家的程式碼具有一致性，以減少不必要的溝通與衝突，提高開發效率</p><h3 id="常見的設計規範"><a href="#常見的設計規範" class="headerlink" title="常見的設計規範"></a>常見的設計規範</h3><p>並非每次專案都要遵守所有設計規範，回歸設計規範的目的在於提升加載渲染、開發與維護效率，所以每次的 <code>guideline</code> 都不盡相同，而是視各個專案的複雜程度與參與的開發人員互相溝通而訂</p><ul><li><p>類別階層不超過 “四” 層為原則</p></li><li><p>不使用 <code>ID</code>，一律使用 <code>class</code></p></li><li><p>使用 <code>OOCSS</code> 建立類別工具庫</p></li><li><p>使用 <code>SMACSS</code> 來建立 Sass 結構</p></li><li><p>排版結構以 <code>BEM</code> 來開發</p></li><li><p>導入 BS4 的 <code>Grid System</code></p></li><li><p>使用 <code>Sass for</code> 來管理擴充元件</p></li><li><p>一率採用駝峰式命名，利用大小寫區分單詞</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 小駝峰式 (開頭小寫)</span><br><span class="line"><span class="selector-class">.listTitle</span> &#123;...&#125;</span><br><span class="line">// 大駝峰式(開頭大寫)</span><br><span class="line"><span class="selector-class">.ListTitle</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>導入第三方插件在 <code>Sass import vendor</code></p></li><li><p>使用 <code>REM</code> 單位</p></li><li><p>佈局使用 <code>flexbox</code> 進行元件設計</p></li></ul><h3 id="sass-7-1-設計模式"><a href="#sass-7-1-設計模式" class="headerlink" title="sass 7+1 設計模式"></a>sass 7+1 設計模式</h3><ul><li><p>base : 全站設定</p><p>定義大部分的 CSS ，避免一直重複撰寫相同的 CSS 樣式，概念同於 SMACSS 的 Base<br>注意 base 的 CSS 絕對不能使用 <code>!important</code> ，以免後續新增的 CSS 無法覆蓋</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_reset.scss      # Reset&#x2F;normalize 樣式重製</span><br><span class="line">_reboot.scss     # 重製部分樣式</span><br><span class="line">_typography.scss # 文字規範</span><br></pre></td></tr></table></figure></li><li><p>components : 組件</p><p>為獨立的組件，放到頁面上任何位置、容器都可以自適應延伸，概念同於 bootstrap 中的 component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_button.scss  # 按鈕</span><br><span class="line">_menu.scss    # 選單</span><br></pre></td></tr></table></figure></li><li><p>layout : 排版</p><p>控制頁面的版型，彼此具備獨立性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_grid.scss   # 格線系統</span><br><span class="line">_header.scss # 表頭</span><br><span class="line">_footer.scss # 表尾</span><br></pre></td></tr></table></figure></li><li><p>pages : 個頁設定</p><p>當個別頁面出現唯一且複雜的內容時，就可以單獨切分出來管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_index.scss # 首頁</span><br><span class="line">_cart.scss  # 購物車頁</span><br></pre></td></tr></table></figure></li><li><p>themes : 主題</p><p>工具型的 CSS，例如，<code>.clearfix</code> (清除浮動)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_variables.scss  # Sass variables</span><br><span class="line">_functions.scss  # Sass function</span><br><span class="line">_minin.scss      # Sass mixin</span><br><span class="line">_helper.scss     # 工具型的 CSS</span><br></pre></td></tr></table></figure></li><li><p>vendors : 套件</p><p>如果網站有載入其他外掛套件，可以統一放到這個資料夾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_bootstrap.scss  # Bootstrap</span><br><span class="line">_jquery-ui.scss   # jQuery 套件</span><br></pre></td></tr></table></figure></li></ul><h3 id="收納"><a href="#收納" class="headerlink" title="收納"></a>收納</h3><p>當網站的 CSS 眾多且複雜，我們使用 Sass 7+1 進行管理時，可以將每個分類建立一個資料夾，將檔案個別放入，並建立一個名為 <code>all.scss</code> 的檔案載入其他所有檔案</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in all.scss</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// utils</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;utils/_variables.scss&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;utils/_mixin.scss&quot;</span>;</span><br><span class="line"><span class="comment">// base</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;base/_reset.scss&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;base/_typography.scss&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>所有規範都不是構成網站的必要條件，設計規範的目的終究還是為了提高開發與維護的效率，並讓其他共同開發者能對彼此的程式碼一目了然，如果專案使用到 <code>Sass 7+1</code> ，甚至依照需求可以對分類自行新增或修改，同理其他的規範如 <code>SMACSS</code>、<code>OOCSS</code> 或 <code>BEM</code>，都可以只擷取部分概念使用，再次強調規範是死的，效率才是最終目的 !</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON概述</title>
      <link href="/json/20190927/b2a33033/"/>
      <url>/json/20190927/b2a33033/</url>
      
        <content type="html"><![CDATA[<p>JSON 常用來作為資料傳遞的檔案格式，這篇文章針對 JSON 做一個簡單的概述</p><span id="more"></span><h2 id="資料來源"><a href="#資料來源" class="headerlink" title="資料來源"></a>資料來源</h2><p><a href="https://zh.wikipedia.org/wiki/JSON">JSON Wiki</a><br><a href="https://ithelp.ithome.com.tw/articles/10159700">Day13– 前端小字典三十天【每日一字】– JSON</a><br><a href="https://data.kcg.gov.tw/">高雄市政府資料開放平台</a><br><a href="https://opendata.epa.gov.tw/Data/Contents/RainTenMin/">行政院環境保護署</a></p><h2 id="JSON-是什麼"><a href="#JSON-是什麼" class="headerlink" title="JSON 是什麼 ?"></a>JSON 是什麼 ?</h2><ul><li><code>JSON</code> 是一種輕量級的 資料交換語言，但其並非一種新的程式語言，而是一種 資料傳輸的格式</li><li>透過 JS 的物件 <code>Object &#123;&#125;</code> 和 陣列 <code>Array []</code> 所構成</li><li>目前很多程式語言都可以支援 <code>JSON</code> 的格式，其附檔名為 <code>.json</code></li></ul><h2 id="JSON-view-chrome-插件"><a href="#JSON-view-chrome-插件" class="headerlink" title="JSON view chrome 插件"></a>JSON view chrome 插件</h2><p>如果是 chrome 的使用者，可以下載 <code>JSON view</code> 這個插件，它能將 <code>JSON</code> 檔案整理成易讀的格式</p><p><a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=zh-TW">JSON view</a></p><h2 id="JSON-的載入方式"><a href="#JSON-的載入方式" class="headerlink" title="JSON 的載入方式"></a>JSON 的載入方式</h2><p>將未經 <code>JSON view</code> 處理過的格式複製下來( 未經插件處理過的資料在載入 JS 中比較不會出問題 )，存入到一個變數中，就可以透過物件、陣列的擷取方式來擷取資料</p><p><a href="https://codepen.io/Jerry-Yeh/pen/ydRqNy?editors=0010">範例程式碼</a></p>]]></content>
      
      
      <categories>
          
          <category> JSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入門篇 - 迴圈</title>
      <link href="/javascript/20190927/25fb3458/"/>
      <url>/javascript/20190927/25fb3458/</url>
      
        <content type="html"><![CDATA[<p>迴圈指的是透過 “遞增” 或 “遞減” 來完成退出的條件，使我們不用反覆撰寫相同的程式，在 JS 中，常見的迴圈語法有 <code>for</code> 和 <code>while</code> 兩種</p><span id="more"></span><h2 id="for-迴圈"><a href="#for-迴圈" class="headerlink" title="for 迴圈"></a>for 迴圈</h2><h3 id="for-基本寫法"><a href="#for-基本寫法" class="headerlink" title="for 基本寫法"></a>for 基本寫法</h3><ul><li>使用 <code>for</code> 開頭</li><li>接著小括號 <code>()</code> 的內容分為三個部分， 初始值、條件、更新內容</li><li>當滿足條件，就會執行 大括號 <code>&#123;&#125;</code> 內的程式碼</li><li>當執行完 大括號 <code>&#123;&#125;</code> 內的程式碼，就會 更新值，如果符合條件，就會再次執行 大括號 <code>&#123;&#125;</code> 內的程式碼，如果不符合，就會結束並 跳出迴圈</li></ul><h3 id="for-與-array-的寫法"><a href="#for-與-array-的寫法" class="headerlink" title="for 與 array 的寫法"></a>for 與 array 的寫法</h3><p>在使用 <code>for</code> 取的陣列中的資料時，可以透過 <code>.length</code> 來取的陣列的長度，以此作為 <code>for</code> 迴圈執行次數的條件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 撈出每個農場的農夫名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> farms = [</span><br><span class="line">  &#123;</span><br><span class="line">    farmer: <span class="string">&#x27;卡斯柏&#x27;</span>,</span><br><span class="line">    field: <span class="number">6</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    farmer: <span class="string">&#x27;查理&#x27;</span>,</span><br><span class="line">    field: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> farmsTotal = farms.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; farmsTotal; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (i+<span class="number">1</span>) + <span class="string">&#x27;個農場主人是&#x27;</span> + farms[i].farmer)</span><br><span class="line">  &#125;;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line">第 <span class="number">1</span> 個農場主人是 卡斯柏</span><br><span class="line">地 <span class="number">2</span> 個農場主人是 查理</span><br></pre></td></tr></table></figure><h3 id="for-與-if-的寫法"><a href="#for-與-if-的寫法" class="headerlink" title="for 與 if 的寫法"></a>for 與 if 的寫法</h3><p>透過在 <code>for</code> 中加入 <code>if</code> 可以為撈出的資料設定條件，而非撈出所有資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 撈出小雞數量超過 100 隻的農夫</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> farms = [</span><br><span class="line">  &#123;</span><br><span class="line">    farmer: <span class="string">&#x27;卡斯柏&#x27;</span>,</span><br><span class="line">    chick: <span class="number">50</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    famrer: <span class="string">&#x27;約翰&#x27;</span>,</span><br><span class="line">    chick: <span class="number">120</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> farmsTotal = farms.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; farmsTotal; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (farms[i].chick &gt; <span class="number">100</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(farms[i].farmer + <span class="string">&#x27;的小雞超過 150 隻&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line">約翰 的小雞超過 <span class="number">150</span> 隻</span><br></pre></td></tr></table></figure><h3 id="for-加總"><a href="#for-加總" class="headerlink" title="for 加總"></a><code>for</code> 加總</h3><p>透過 <code>+=</code> 我們可以不斷地將前面的項目累加上去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將所有香蕉數量加總</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> farms = [</span><br><span class="line">  &#123;</span><br><span class="line">    farmer: <span class="string">&#x27;卡斯柏&#x27;</span>,</span><br><span class="line">    banana: <span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    farmer: <span class="string">&#x27;查理&#x27;</span>,</span><br><span class="line">    banana: <span class="number">1000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    farmer: <span class="string">&#x27;約翰&#x27;</span>,</span><br><span class="line">    banana: <span class="number">3215</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> farmsTotal = farms.length;</span><br><span class="line"><span class="keyword">var</span> bananaTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; farmsTotal; i++)&#123;</span><br><span class="line">  bananaTotal += farms[i].banana;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;今年的香蕉採收量為&#x27;</span> + bananaTotal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line">今年的香蕉採收量為 <span class="number">9215</span></span><br></pre></td></tr></table></figure><h2 id="while-迴圈"><a href="#while-迴圈" class="headerlink" title="while 迴圈"></a>while 迴圈</h2><p><code>while</code> 和 <code>for</code> 在原理上大同小異，只是在寫法上有點不同</p><ul><li>在外層宣告 “初始值”</li><li>使用 <code>while</code> 開頭</li><li>接著 小括號 <code>()</code> 包住 條件</li><li>再接著 大括號 <code>&#123;&#125;</code> 包住 符合條件時執行的內容</li><li>符合條件時執行的內容 後才寫 “更新值”</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;初始值&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( <span class="string">&quot;條件&quot;</span> )&#123;</span><br><span class="line">  <span class="comment">// 符合條件時執行的內容</span></span><br><span class="line">  <span class="string">&quot;更新值&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="for-與-while-的差異"><a href="#for-與-while-的差異" class="headerlink" title="for 與 while 的差異"></a>for 與 while 的差異</h2><h3 id="適合-for-的情境"><a href="#適合-for-的情境" class="headerlink" title="適合 for 的情境"></a>適合 <code>for</code> 的情境</h3><p>因為 <code>for</code> 包含 <code>初始值</code>、<code>條件</code>、 <code>更新值</code> 三部分，能夠一目了然執行次數，所以更適合用在迴圈執行次數 “明確” 的狀態</p><h3 id="適合-while-的情境"><a href="#適合-while-的情境" class="headerlink" title="適合 while 的情境"></a>適合 <code>while</code> 的情境</h3><p>因為 <code>while</code> 只包含 <code>條件</code>，所以較適合用在迴圈執行次數 不明確 的狀態</p><h2 id="無窮迴圈"><a href="#無窮迴圈" class="headerlink" title="無窮迴圈"></a>無窮迴圈</h2><p>當條件設定錯誤，不管如何都會符合條件時，就會無限執行內部程式碼，無法跳出迴圈，稱為 “無窮迴圈”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 當 i 不管如何都會大於等於 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( i &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="break-與-continue"><a href="#break-與-continue" class="headerlink" title="break 與 continue"></a>break 與 continue</h2><h3 id="break-會直接跳出迴圈"><a href="#break-會直接跳出迴圈" class="headerlink" title="break : 會直接跳出迴圈"></a>break : 會直接跳出迴圈</h3><p>找到陣列中第一個 <code>非 0</code> 的數字並印出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( i &lt; array.length )&#123;</span><br><span class="line">  <span class="keyword">if</span> ( array[i] !== <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  i++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="continue-只會跳過這次，然後繼續執行下一次迴圈"><a href="#continue-只會跳過這次，然後繼續執行下一次迴圈" class="headerlink" title="continue: 只會跳過這次，然後繼續執行下一次迴圈"></a>continue: 只會跳過這次，然後繼續執行下一次迴圈</h3><p>印出 1 ~ 10 的數字但跳過 3 的倍數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span> ( i % <span class="number">3</span> === <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入門篇 - 流程判斷</title>
      <link href="/javascript/20190927/2be5d539/"/>
      <url>/javascript/20190927/2be5d539/</url>
      
        <content type="html"><![CDATA[<p>JS 用來控制流程的條件語法指的是，當指定條件為 <code>true</code>，就會執行後續指令，JS 條件語法分為以兩種 : <code>if...else</code> 和 <code>switch</code></p><span id="more"></span><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><p>顧名思義，如果怎樣，就執行某事，否則就執行另一件事，而其中的條件會透過 <code>ToBoolean</code> 轉換成 <code>true</code> 或 <code>false</code></p><ul><li>使用 小括號 <code>()</code> 包住 條件</li><li>使用 大括號 <code>&#123;&#125;</code> 包住 條件成立時要執行的事</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;條件&quot;</span>)&#123;</span><br><span class="line">  <span class="comment">// 條件成立執行這件事</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 否則執行這件事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>if</code> 和 <code>else</code>，還可以透過 <code>else if</code> 增加條件，增加條件可以不只一個，但為了維護與可讀性，建議不要過度增加條件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;條件1&quot;</span>)&#123;</span><br><span class="line">  <span class="comment">// 條件成立執行這件事</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;條件2&quot;</span>)&#123;</span><br><span class="line">  <span class="comment">// 以上條件都不成立就執行這件事</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;條件2&quot;</span>)&#123;</span><br><span class="line">  <span class="comment">// 以上條件都不成立就執行這件事</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 以上條件都不成立就執行這件事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code> 和 <code>if..else</code> 具有相同的功能，但當條件過多時，使用 <code>if...else</code> 會因為需要跑完每個條件而造成維護不易且效能較差</p><ul><li>同樣使用 小括號 <code>()</code> 包住 條件 但不比較</li><li><code>case</code> 後方放要 與條件進行判斷的值</li><li>值後使用 冒號 :隔開 條件成立後要執行的指令</li><li>每個 <code>case</code> 最後 使用 <code>break;</code> 隔開其他的 <code>case</code>，如果沒有使用 b<code>reak;</code> 隔開，就會執行所有 <code>case</code> 的指令</li><li>如果以上所有 <code>case</code> 都不成立，就執行 <code>default</code> 中的指令</li></ul><h2 id="if…else-與-switch-比較"><a href="#if…else-與-switch-比較" class="headerlink" title="if…else 與 switch 比較"></a>if…else 與 switch 比較</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">Math</span>.ceil( month/<span class="number">3</span> ) === <span class="number">1</span> )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;春天&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( <span class="built_in">Math</span>.ceil( month/<span class="number">3</span> ) === <span class="number">2</span> )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;夏天&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( <span class="built_in">Math</span>.ceil( month/<span class="number">3</span> ) === <span class="number">3</span> )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;秋天&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( <span class="built_in">Math</span>.ceil( month/<span class="number">3</span> ) === <span class="number">4</span> )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;冬天&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;月份錯誤&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( <span class="built_in">Math</span>.ceil(month / <span class="number">3</span>))&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;月份錯誤&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果沒有 <code>break</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( <span class="built_in">Math</span>.ceil(month/<span class="number">3</span>) )&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;春天&#x27;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;夏天&#x27;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;秋天&#x27;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冬天&#x27;</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;月份錯誤&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in console</span></span><br><span class="line"><span class="string">&#x27;春天&#x27;</span></span><br><span class="line"><span class="string">&#x27;夏天&#x27;</span></span><br><span class="line"><span class="string">&#x27;秋天&#x27;</span></span><br><span class="line"><span class="string">&#x27;冬天&#x27;</span></span><br><span class="line"><span class="string">&#x27;月份錯誤&#x27;</span></span><br></pre></td></tr></table></figure><p>適當的使用 <code>break</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (month)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;春天&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;夏天&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;秋天&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冬天&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;月份錯誤&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入門篇 - 運算式(Expression)與運算子(Operator)</title>
      <link href="/javascript/20190927/d8cdf04e/"/>
      <url>/javascript/20190927/d8cdf04e/</url>
      
        <content type="html"><![CDATA[<p>在 JS 語法可以分為兩大類，敘述句 <code>Statement</code> 與 運算式 <code>Expression</code></p><span id="more"></span><ul><li><p>敘述句 <code>Statement</code> :</p><p>簡單來說，敘述句就是執行某個動作，如變數的宣告、賦值、迴圈或 <code>if</code> 判斷式等，都可以被歸類於此</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br></pre></td></tr></table></figure></li><li><p>運算式 <code>Expression</code> :</p><p>運算式最大的特性是會產生一個 值，如 <code>function</code> 的參數 <code>arguments</code>，或是透過等號 <code>=</code> 賦值時，在等號 <code>=</code> 右側的部分都屬於運算式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span> * <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>如上，在等號 = 右側的 10 * 10 就是屬於運算式</p></li></ul><h2 id="運算子的分類"><a href="#運算子的分類" class="headerlink" title="運算子的分類"></a>運算子的分類</h2><p>運算子的類型很多，常見的可以分為以下幾類，其餘可以操考 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators">MDN 運算式與運算子</a></p><ul><li>算術運算子 (Arithmetic Operator)</li><li>賦值運算子 (Assignment Operator)</li><li>比較運算子 (Comparison Operator)</li><li>邏輯運算子 (Logical Operator)</li><li>逗號運算子 (Comma Operator)</li><li>三元(條件)運算子</li></ul><h2 id="算術運算子-Arithmetic-Operator"><a href="#算術運算子-Arithmetic-Operator" class="headerlink" title="算術運算子 (Arithmetic Operator)"></a>算術運算子 (Arithmetic Operator)</h2><p>算術運算子包括大家熟知的 四則運算(加、減、乘、除)，但運算後的結果常常會出現一些特例，以下一一介紹</p><p><a href="#%E5%8A%A0%E8%99%9F">加號 <code>+</code></a><br><a href="#%E6%B8%9B%E8%99%9F">減號 <code>-</code></a><br><a href="#%E4%B9%98%E8%99%9F">乘號 <code>*</code></a><br><a href="#%E9%99%A4%E8%99%9F">除號 <code>/</code></a><br><a href="#%E5%8F%96%E9%A4%98%E6%95%B8">取餘數 <code>%</code></a><br><a href="#%E9%81%9E%E5%A2%9E-%E8%88%87-%E9%81%9E%E6%B8%9B">遞增 <code>++</code> 與 遞減 <code>--</code></a></p><h3 id="加號"><a href="#加號" class="headerlink" title="加號 +"></a>加號 <code>+</code></h3><ul><li><p>單純數字的相加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>特殊字無限大 <code>Infinity</code>、負無限大 <code>-Infinity</code> 和 <code>Not a Number NaN</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> + <span class="literal">Infinity</span>      <span class="comment">// Infinity</span></span><br><span class="line">-<span class="literal">Infinity</span> + -<span class="literal">Infinity</span>    <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="literal">Infinity</span> + <span class="literal">Infinity</span>     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>而只要加號 <code>+</code> 兩側其中一個是 <code>NaN</code>，結果就會是 <code>NaN</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="literal">NaN</span>            <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> + <span class="literal">NaN</span>      <span class="comment">// NaN</span></span><br><span class="line">-<span class="literal">Infinity</span> + <span class="literal">NaN</span>     <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p>如果加號 <code>+</code> 兩側其中一個是 字串 <code>string</code>，另一端就會 “自動轉型” 為 “字串”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 數字 + 字串 </span></span><br><span class="line"><span class="number">100</span> + <span class="string">&quot;100&quot;</span>      <span class="comment">// &quot;100100&quot;</span></span><br><span class="line"><span class="number">100</span> + <span class="string">&quot;ABC&quot;</span>      <span class="comment">// &quot;100ABC&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字串 + 字串</span></span><br><span class="line"><span class="string">&quot;ABC&quot;</span> + <span class="string">&quot;XYZ&quot;</span>    <span class="comment">// &quot;ABCXYZ&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布林 + 字串</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">&quot;abc&quot;</span>     <span class="comment">// &quot;trueabc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 + 物件</span></span><br><span class="line"><span class="number">100</span> + &#123;&#125;         <span class="comment">// &quot;100[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 + undefined，undefined 會被轉成數字 NaN</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">undefined</span>  <span class="comment">// NaN</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span> + <span class="literal">undefined</span>    <span class="comment">// &quot;abcundefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 + null，null 會被轉成數字 0</span></span><br><span class="line"><span class="number">123</span> + <span class="literal">null</span>  <span class="comment">// 123</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span> + <span class="literal">null</span>    <span class="comment">// &quot;abcnull&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>由於運算式是 “由左而右” 且 “先乘除後加減” 做運算，所以如果要讓數字先做運算，可以使用小括號 <code>()</code> 將數字運算包起來</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;10 加 100 的結果是 &quot;</span> + <span class="number">10</span> + <span class="number">100</span>;   <span class="comment">// &quot;10 加 100 的結果是 10100&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;10 加 100 的結果是 &quot;</span> + (<span class="number">10</span> + <span class="number">100</span>);   <span class="comment">// &quot;10 加 100 的結果是 110&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="減號"><a href="#減號" class="headerlink" title="減號 -"></a>減號 <code>-</code></h3><ul><li><p>單純數字相減</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span> - <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li><li><p>特殊的數字，如無限大 <code>Infinity</code>、負無限大 <code>-Infinity</code> 和 <code>Not a Number NaN</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> - <span class="literal">Infinity</span>   <span class="comment">// NaN</span></span><br><span class="line">-<span class="literal">Infinity</span> - -<span class="literal">Infinity</span>   <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line">-<span class="literal">Infinity</span> - <span class="literal">Infinity</span>    <span class="comment">// -Infinity</span></span><br><span class="line"><span class="literal">Infinity</span> - -<span class="literal">Infinity</span>    <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>如果減號 <code>-</code> 兩側其中之一是 <code>NaN</code>，那結果就會是 <code>NaN</code></p></li><li><p>與加號 <code>+</code> 不同的地方是如果減號 <code>-</code> 兩側其中之一不是數字，會透過 <code>Number()</code> 嘗試將數值轉為 “數字”</p><ul><li><p>不含數字的字串、<code>undefined</code> 和 物件 <code>object</code> 會被轉型成 <code>NaN</code></p></li><li><p>含數字的字串 會被轉型為 數字</p></li><li><p><code>true</code>、會被轉型為 <code>1</code></p></li><li><p><code>false</code>、<code>null</code> 會被轉型為 <code>0</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 數字 - 字串</span></span><br><span class="line"><span class="number">100</span> - <span class="string">&quot;50&quot;</span>    <span class="comment">// 50</span></span><br><span class="line"><span class="number">100</span> - <span class="string">&quot;abc&quot;</span>   <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 - 布林</span></span><br><span class="line"><span class="number">100</span> - <span class="literal">false</span>   <span class="comment">// 100</span></span><br><span class="line"><span class="number">100</span> - <span class="literal">true</span>    <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 - undefined</span></span><br><span class="line"><span class="number">100</span> - <span class="literal">undefined</span>   <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 - null</span></span><br><span class="line"><span class="number">100</span> - <span class="literal">null</span>   <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 - 物件</span></span><br><span class="line"><span class="number">100</span> - &#123;&#125;   <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="乘號"><a href="#乘號" class="headerlink" title="乘號 *"></a>乘號 <code>*</code></h3><ul><li><p>單純數字的運算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></li><li><p>超出數字的範圍由就看結果是正數或負數來決定是 <code>Infinity</code> 或 <code>-Infinity</code></p></li><li><p>如果乘號兩側其中之一出現 <code>NaN</code>，那結果就會是 <code>NaN</code>， <code>Infinity * 0</code> 也是 <code>NaN</code></p></li><li><p>如果乘號兩側其中之一出現非數字的型別，會和減號 <code>-</code> 一樣使用 <code>Number()</code> 嘗試轉型為 “數字”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 數字 * 字串</span></span><br><span class="line"><span class="number">100</span> * <span class="string">&quot;10&quot;</span>   <span class="comment">// 1000</span></span><br><span class="line"><span class="number">100</span> * <span class="string">&quot;abc&quot;</span>   <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 * 布林</span></span><br><span class="line"><span class="number">100</span> * <span class="literal">true</span>   <span class="comment">// 100</span></span><br><span class="line"><span class="number">100</span> * <span class="literal">false</span>  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 * undefined</span></span><br><span class="line"><span class="number">100</span> * <span class="literal">undefined</span>   <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//數字 * null</span></span><br><span class="line"><span class="number">100</span> * <span class="literal">null</span>   <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字 * 物件</span></span><br><span class="line"><span class="number">100</span> * &#123;&#125;   <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="除號"><a href="#除號" class="headerlink" title="除號 /"></a>除號 <code>/</code></h3><ul><li>單純數字的運算</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> / <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ul><li><p>“被除數” 為 <code>0</code> 的情況下</p><ul><li>除數為 “正數”，結果為 <code>Infinity</code></li><li>除數為 “負數”，結果為 <code>-Infinity</code></li><li>除數為 <code>0</code>，結果為 <code>NaN</code></li></ul></li><li><p>和乘號 <code>*</code> 相同，如果除號 <code>/</code> 兩側其中之一為數字以外的型別，會透過 <code>Number()</code> 嘗試轉型為數字</p></li></ul><h3 id="取餘數"><a href="#取餘數" class="headerlink" title="取餘數 %"></a>取餘數 <code>%</code></h3><ul><li><p>單純數字的運算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> % <span class="number">33</span></span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure></li><li><p>如果 “被除數” 為 <code>Infinity</code> 或 <code>-Infinity</code>，取餘數的結果為 <code>NaN</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span> % <span class="number">0</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> % <span class="number">100</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> % <span class="literal">Infinity</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">Infinity</span> % -<span class="literal">Infinity</span>   <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p>如果 “被除數” 為 “一般值”， “除數” 為 <code>Infinity</code>，結果為 “被除數”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> % <span class="literal">Infinity</span>   <span class="comment">// 100</span></span><br><span class="line"><span class="number">0</span> % <span class="literal">Infinity</span>   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p>如果 “被除數” 為 “一般值”， “除數” 為 <code>0</code>，結果為 <code>NaN</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> % <span class="number">0</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> % <span class="number">0</span>   <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p>和除號 <code>/</code> 相同，如果取餘 <code>%</code> 兩側其中之一為數字以外的型別，會透過 <code>Number()</code> 嘗試轉型為數字</p></li></ul><h3 id="遞增-與-遞減"><a href="#遞增-與-遞減" class="headerlink" title="遞增 ++ 與 遞減 --"></a>遞增 <code>++</code> 與 遞減 <code>--</code></h3><ul><li><p>如同字面上的意思，遇到 遞增 <code>++</code> 就會加一，可以看成是 <code>a = a + 1</code> ，遇到 遞減 <code>--</code> 就會減一，可以看成是 <code>a = a - 1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">a--;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p>位置放在變數前後是有差別的，將 遞增 <code>++</code> 放在 前面，回傳的會是 “原始數值” ，放在 後面，回傳的會是 <code>+1</code> 後的結果，但事後再將兩者印出，都會出現 <code>+1</code> 後的結果，同理 遞減 <code>--</code> 也是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">a--;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="賦值運算子-Assignment-Operator"><a href="#賦值運算子-Assignment-Operator" class="headerlink" title="賦值運算子 (Assignment Operator)"></a>賦值運算子 (Assignment Operator)</h2><ul><li><p>賦值運算子透過 等號 <code>=</code> 來將左側的值指派到右側，如下將右側的運算結果指派到左側的變數 <code>a</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span> * <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>除了單純等號 <code>=</code>，還可以結合算術運算子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a += b;   <span class="comment">// a = a + b</span></span><br><span class="line">a -= b;   <span class="comment">// a = a - b</span></span><br><span class="line">a *= b;   <span class="comment">// a = a * b</span></span><br><span class="line">a /= b;   <span class="comment">// a = a / b</span></span><br><span class="line">a %= b;   <span class="comment">// a = a % b</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="比較運算子-Comparison-Operators"><a href="#比較運算子-Comparison-Operators" class="headerlink" title="比較運算子 (Comparison Operators)"></a>比較運算子 (Comparison Operators)</h2><p>比較運算子是用來比較運算子兩側的值，可能是 <code>純值</code>、<code>物件</code>、<code>運算式</code> 或 <code>函式回傳</code> 的結果，比較後會得到 <code>true</code> 或 <code>false</code></p><ul><li><h3 id="賦值-一個等號"><a href="#賦值-一個等號" class="headerlink" title="賦值 : 一個等號 ="></a>賦值 : 一個等號 <code>=</code></h3><p>一個等號 <code>=</code> 的意思是將等號 <code>=</code> 右側的值 指定、賦值 到 等號 <code>=</code> 左側，為 賦值運算子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><h3 id="相等-兩個等號"><a href="#相等-兩個等號" class="headerlink" title="相等 : 兩個等號 =="></a>相等 : 兩個等號 <code>==</code></h3><p>兩個等號 <code>==</code> 的意思是為左右兩側的資料進行比較，但 不同型別的值會 “自動轉型” 後再做比較</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;10&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a == <span class="number">10</span> );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( a == b );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( a == <span class="number">100</span>  );   <span class="comment">// false </span></span><br></pre></td></tr></table></figure></li><li><h3 id="全等-三個等號"><a href="#全等-三個等號" class="headerlink" title="全等 : 三個等號 ==="></a>全等 : 三個等號 <code>===</code></h3><p>三個等號 <code>===</code> 也是為左右兩側的值進行比較，但 “不同型別的值” 不會自動轉型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;10&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a == b );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( a === b );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><h3 id="不等於-與"><a href="#不等於-與" class="headerlink" title="不等於 != 與 !=="></a>不等於 <code>!=</code> 與 <code>!==</code></h3><p>等號 <code>=</code> 前面加上 驚嘆號 <code>!</code> 即為 “不等於”，而不等於分成兩種，一個等號 <code>!=</code> “不會自動轉型” ，兩個等號 <code>!==</code> “會自動轉型”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><h3 id="大於-gt-與-小於-lt"><a href="#大於-gt-與-小於-lt" class="headerlink" title="大於 &gt; 與 小於 &lt;"></a>大於 <code>&gt;</code> 與 小於 <code>&lt;</code></h3><p>除了判斷是否相等，還可以比較大小，在後方加上 等號 <code>=</code> 就會包含等於，大於等於 <code>&gt;=</code> 和 小於等於 <code>&lt;=</code> ，如遇到不同型別就會 “自動轉型”</p><ul><li><p>如果兩者都是 “數字” 則單純就字面大小比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a &gt; b );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( b &gt; a );   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( c &gt; a );   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( a &gt;= c );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>如果其中之一不是數字，則會嘗試將其轉型成 “數字” 再做比較</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;   <span class="comment">// number</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;9&quot;</span>;   <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a &gt; b );   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>如果兩者都是字串，則會依照字母的順序來做比較，如果有多個字母，則會比較到第一個不同的字母為止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;a&quot;</span> &gt; <span class="string">&quot;b&quot;</span> );   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;b&quot;</span> &gt; <span class="string">&quot;a&quot;</span> );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;abd&quot;</span> &gt; <span class="string">&quot;abc&quot;</span> );   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>如果其中之一是 布林 <code>boolean</code>，<code>true</code> 會被轉型為 <code>1</code>，<code>false</code> 會被轉型為 <code>0</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="number">10</span> &gt; <span class="literal">true</span> );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">true</span> &gt; <span class="literal">false</span> );   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>如果其中之一是物件 <code>object</code>，會先透過 <code>valueOf()</code> 求得對應的數值，如果沒有 <code>valueOf()</code> 的方法，就會透過 <code>toString()</code> 轉型再做比較</p></li></ul></li></ul><h2 id="邏輯運算子-Logical-Operator"><a href="#邏輯運算子-Logical-Operator" class="headerlink" title="邏輯運算子 (Logical Operator)"></a>邏輯運算子 (Logical Operator)</h2><p>邏輯運算式包含三種，and <code>&amp;&amp;</code>、or <code>||</code>、not <code>!</code>，通常會在 <code>if 判斷式 </code>和布林 <code>boolean</code> 搭配使用</p><ul><li><h3 id="And-amp-amp"><a href="#And-amp-amp" class="headerlink" title="And &amp;&amp;"></a>And <code>&amp;&amp;</code></h3><p>當 and <code>&amp;&amp;</code> 的兩側都是 <code>true</code> 結果才會是 <code>true</code>，否則就是 <code>false</code>，即 全部條件都必須成立才算成立</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a &gt; <span class="number">0</span> &amp;&amp; b = <span class="literal">true</span> );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( a &lt; <span class="number">0</span> &amp;&amp; b = <span class="literal">true</span> );   <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><h3 id="Or"><a href="#Or" class="headerlink" title="Or ||"></a>Or <code>||</code></h3><p>當 or <code>||</code> 的兩側其中之一是 <code>true</code> 結果就會是 <code>true</code>，除非兩側都是 <code>false</code> 才會是 <code>false</code>，即 滿足其中一個條件就會成立</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line">                  </span><br><span class="line"><span class="built_in">console</span>.log( a &gt; <span class="number">0</span> || b = <span class="literal">true</span> );   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( a &lt; <span class="number">0</span> || b = <span class="literal">true</span> );   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><h3 id="Not"><a href="#Not" class="headerlink" title="Not !"></a>Not <code>!</code></h3><p>not <code>!</code> 代表否定、反向的意思，如果是 <code>! true</code>，就是 <code>false</code> 的意思，兩個驚嘆號 <code>!!</code> ，利用雙重否定可以取代 <code>Boolean()</code> 來判斷某數值 <code>Boolean</code> 轉換後的結果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a = <span class="number">0</span> );   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log( a != <span class="number">0</span> );   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><h3 id="布林-Boolean-的型別轉換"><a href="#布林-Boolean-的型別轉換" class="headerlink" title="布林 Boolean 的型別轉換"></a>布林 Boolean 的型別轉換</h3><ul><li><p>透過 Boolean() 會轉換成 false 的值</p><ul><li>undefined</li><li>null</li><li>0</li><li>NaN</li><li>空字串 “” 、’’</li></ul></li><li><p>其他的值透過 Boolean 轉型後都會是 true</p></li></ul></li><li><h3 id="邏輯運算子的判斷"><a href="#邏輯運算子的判斷" class="headerlink" title="邏輯運算子的判斷"></a>邏輯運算子的判斷</h3><p>透過邏輯運算子 <code>&amp;&amp;</code>、<code>||</code> 做判斷時，會先對左側進行驗證</p><ul><li><p>如果是 <code>Boolean</code> 類型就會做後續判斷，如果不是就會透過 <code>Boolean()</code> 轉型</p></li><li><p>以 and <code>&amp;&amp;</code> 來說，如果第一個值為 <code>true</code>，則回傳第二個值，否則回傳第一個</p></li><li><p>以 or <code>||</code> 來說，如果第一個值為 <code>true</code>，則回傳第一個值，否則回傳第二個</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( a &amp;&amp; b );   <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log( a || b );   <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( c &amp;&amp; a );   <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log( c || b );   <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log( c || a );   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="逗號運算子-Comma-Operator"><a href="#逗號運算子-Comma-Operator" class="headerlink" title="逗號運算子 (Comma Operator)"></a>逗號運算子 (Comma Operator)</h2><p>逗號運算子 <code>,</code> 主要是分隔運算式中的多組運算式，常使用在 <code>for 迴圈</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">10</span>; i &lt; <span class="number">10</span>; i++, j++)&#123;</span><br><span class="line">  k = i + j;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也可以使用在 “變數的宣告”，但要注意的是，以下兩種宣告是 “不相同” 的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = b = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>因為變數 <code>b</code>，其實沒有宣告，只有賦值，所以是全域變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b;</span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log( a, b );   <span class="comment">// 10, 10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 離開作用範圍後</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b);   <span class="comment">// undefined, 10</span></span><br></pre></td></tr></table></figure><h2 id="三元運算子"><a href="#三元運算子" class="headerlink" title="三元運算子"></a>三元運算子</h2><p>三元運算子以 問號 <code>?</code> 和 冒號 <code>:</code> 所組成，如果條件為 <code>true</code>，回傳數值 <code>1</code>，否則回傳數值 <code>2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;(條件)&quot;</span> ? <span class="string">&quot;數值1&quot;</span> : <span class="string">&quot;數值2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果年紀大於等於 &quot;18&quot;，為&quot;成人&quot;，否則為&quot;小孩&quot;</span></span><br><span class="line"><span class="keyword">var</span> status = (age &gt;= <span class="number">18</span>) ? <span class="string">&quot;成人&quot;</span> : <span class="string">&quot;小孩&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滾動視差-滾動套用CSS效果</title>
      <link href="/jquery/20190927/1d3a5dfe/"/>
      <url>/jquery/20190927/1d3a5dfe/</url>
      
        <content type="html"><![CDATA[<p>在這篇文章中，會透過 jQuery 來達到滾動網頁到指定位置時，套用特定的 CSS 效果</p><span id="more"></span><h2 id="建立版型"><a href="#建立版型" class="headerlink" title="建立版型"></a>建立版型</h2><p>首先，建立要動態套用 CSS 的版型，在這裡會做出讓 “三大重點” 中的項目在滾到到該區域時，由下而上浮現<br><strong><a href="https://codepen.io/Jerry-Yeh/pen/vYBgeVv?editors=1010">範例版型</a></strong></p><h2 id="隱藏內容"><a href="#隱藏內容" class="headerlink" title="隱藏內容"></a>隱藏內容</h2><p>要做出動態浮現的效果時，我們會預設內容是隱藏的，但在這裡使用的是透明化 <code>opacity: 0</code>，而不是直接未顯示 <code>display: none</code>，因為在透明化的情況下才會 “保留元素空間”，避免版型走位</p><p>在這裡設定一個 <code>className</code> 並帶入元素中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-three-one animated&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-center m-y-2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-mobile fa-5x&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center m-y-1&quot;</span>&gt;</span></span><br><span class="line">    Fully Responsive</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Natus aut dolorem in autem veniam, nisi repellendus amet a eum laboriosam veritatis doloremque consectetur.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果製作"><a href="#效果製作" class="headerlink" title="效果製作"></a>效果製作</h2><p>接著再新增一個 <code>className</code> 來製作呈現的效果，在這裡先增加不透明的效果 <code>opacity: 1</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fadeIn</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jQuery-滾動"><a href="#jQuery-滾動" class="headerlink" title="jQuery 滾動"></a>jQuery 滾動</h2><h3 id="滾動方法"><a href="#滾動方法" class="headerlink" title="滾動方法"></a>滾動方法</h3><p>在這裡透過 <code>jQuery</code> 的滾動方法 <code>scroll</code> 來觸發滾動事件，並綁定在頂層物件 <code>window</code> 上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="取得位置"><a href="#取得位置" class="headerlink" title="取得位置"></a>取得位置</h2><p>如果要做出這個效果，就必須取得元素的座標位置，才得以在滾動到該位置時觸發效果</p><h3 id="取得元素位置-offset-與-position"><a href="#取得元素位置-offset-與-position" class="headerlink" title="取得元素位置 offset 與 position"></a>取得元素位置 offset 與 position</h3><p>在 <code>jQuery</code> ，這兩種方法都可以取得元素的座標位置，可以先透過 <code>consle.log</code> 來查看取得的座標</p><ul><li><code>top</code>: 取得指定元素的 <code>y</code> 軸 座標</li><li><code>left</code>: 取得指定元素的 <code>x</code> 軸 座標</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thisPos = $(<span class="built_in">this</span>).offset().top;</span><br><span class="line"><span class="keyword">var</span> thisPos = $(<span class="built_in">this</span>).position().left;</span><br></pre></td></tr></table></figure><p><strong><code>offset</code> 與 <code>position</code> 的差異</strong><br>這兩種方法的差異在於 “相對位置”</p><ul><li><code>offset</code>: 以最高級元素 <code>document</code> 也就是整個網站來做為相對位置</li><li><code>position</code>: 會以指定元素網上尋找，直到找到第一個含 <code>position: relative</code> 屬性的元素來取得相對座標</li></ul><h3 id="取得網頁高度"><a href="#取得網頁高度" class="headerlink" title="取得網頁高度"></a>取得網頁高度</h3><p>取得網頁高度有助於在觸發事件的位置上更靈活，而不會在滾動到該區域的最上方才會觸發</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> windowHeight = $(<span class="built_in">window</span>).height();</span><br></pre></td></tr></table></figure><h2 id="套用座標位置"><a href="#套用座標位置" class="headerlink" title="套用座標位置"></a>套用座標位置</h2><p>在了解滾動方法並取得座標位置後，就可以開始設定條件來呈現 CSS 效果</p><p><strong>取得元素</strong><br>透過方法 <code>each()</code> 來取得所有包含該 <code>className</code> 的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;.animated&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>取得元素座標</strong><br>取得元素後，再透過上述提到的方法來取的座標</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;.animated&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> thisPos = $(<span class="built_in">this</span>).offset().top;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>設定條件</strong><br>在這裡設定如果 “網頁座標” 加上 “網頁高度” 大於等於 “元素座標”，就加上要套用的 CSS 效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scrollPos = $(<span class="built_in">window</span>).scrollTop();</span><br><span class="line">  <span class="keyword">var</span> windowHeight = $(<span class="built_in">window</span>).height();</span><br><span class="line"></span><br><span class="line">  $(<span class="string">&#x27;.animated&#x27;</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> thisPos = $(<span class="built_in">this</span>).offset().top;</span><br><span class="line">    <span class="keyword">if</span> ((windowHeight + scrollPos) &gt;= thisPos)&#123;</span><br><span class="line">      $(<span class="built_in">this</span>).addClass(<span class="string">&#x27;fadeIn&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如此一來，就可以在滾動到特定元素時，套用指定的 CSS 效果囉</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/course/responsive/">六角學院課程 - 一變應萬變的響應式網頁設計</a></p>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JaveScript入門篇 - 陣列(Array)與物件(Object)</title>
      <link href="/javascript/20190926/63428deb/"/>
      <url>/javascript/20190926/63428deb/</url>
      
        <content type="html"><![CDATA[<p>在前兩篇關於變數的文章中有提到，在 JavaScript 中，除了基本型別以外都可以歸類為物件型別，在這篇文章中就來介紹最基本的物件型別，陣列 <code>Array</code> 與物件 <code>Object</code></p><span id="more"></span><h2 id="物件-Object"><a href="#物件-Object" class="headerlink" title="物件 Object"></a>物件 <code>Object</code></h2><ul><li><p>物件可以是零至多個屬性 <code>property</code> 的集合</p></li><li><p>每個屬性 <code>property</code> 都有自己的值 <code>value</code></p></li><li><p>值可以是基本型別、另一個物件 <code>object</code> 、陣列 <code>array</code> 或函數 <code>function</code></p></li><li><p>使用大括號 <code>&#123; &#125;</code> 建立起新的物件</p></li><li><p>屬性 property 使用冒號 <code>:</code> 隔開值 <code>value</code>，而值 <code>value</code> 結尾使用逗號 <code>,</code> 連接下一個屬性 <code>property</code></p></li><li><p>屬性 <code>property</code> 可以透過 “點” <code>.</code> 來存取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> farm = &#123;</span><br><span class="line">  farmer: <span class="string">&quot;卡斯伯&quot;</span>,   <span class="comment">// string</span></span><br><span class="line">  dogs: [<span class="string">&#x27;張姆士&#x27;</span>, <span class="string">&#x27;龐的&#x27;</span>],   <span class="comment">// array(object)</span></span><br><span class="line">  chicken: <span class="number">15</span>,   <span class="comment">// number</span></span><br><span class="line">  duck: <span class="number">3</span>,</span><br><span class="line">  poultryTotal: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = farm.chicken + farm.duck;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;001&quot;</span>: <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(farm.farmer);   <span class="comment">// 卡斯伯</span></span><br><span class="line">farm.poultryTotal();   <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></li><li><p>屬性也可以透過中括號 <code>[ ]</code> 來存取，好處是遇到不合法的 JavaScript 的識別字 (如帶有空白的字串或是數字) 時，不會出現錯誤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">farm<span class="number">.001</span>;   <span class="comment">// SyntaxError: Unexpected number</span></span><br><span class="line">farm[<span class="string">&quot;001&quot;</span>];   <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>屬性 <code>property</code> 可以透過 <code>=</code> “新增” 與 <code>delete</code> “刪除”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;123&#x27;</span>;   <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line">obj.name;   <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name;   <span class="comment">// 刪除</span></span><br><span class="line"></span><br><span class="line">obj.name;   <span class="comment">// 刪除屬性後變成 undefined</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="判斷屬性是否存在"><a href="#判斷屬性是否存在" class="headerlink" title="判斷屬性是否存在"></a>判斷屬性是否存在</h3><p>判斷屬性是存在最簡單的方式就是檢查該屬性是不是 <code>undefined</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">          </span><br><span class="line"><span class="built_in">console</span>.log( obj.name );   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>但如果該屬性的值剛好是 <code>undefined</code>，此方法就無效，除了此方法，還有 <code>in</code> 運算子和 <code>hasOwnProperty</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Object&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過 in 檢查屬性</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj );     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> obj );    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過 hasOwnProperty() 方法檢查</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>);       <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;value&#x27;</span>);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="列舉物件-for-in"><a href="#列舉物件-for-in" class="headerlink" title="列舉物件 (for ... in)"></a>列舉物件 <code>(for ... in)</code></h3><p>另一個判斷物件內有什麼屬性的方法就是使用列舉 <code>(for ... in)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Jerry&#x27;</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  bwh: &#123;</span><br><span class="line">    strength: <span class="number">30</span>,</span><br><span class="line">    agility: <span class="number">31</span>,</span><br><span class="line">    intelligence: <span class="number">32</span></span><br><span class="line">  &#125;,</span><br><span class="line">  single: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> Person)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(Person[prop]);   <span class="comment">// Jerry 18 &#123;strength: 30, agility: 31, intelligence: 32&#125; true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="陣列-Array"><a href="#陣列-Array" class="headerlink" title="陣列 Array"></a>陣列 <code>Array</code></h2><ul><li><p>陣列可以是零至多個元素的集合</p></li><li><p>陣列內可以是 原始的資料類型、其他陣列 <code>array</code>、函式<code>function</code> 或物件 <code>object</code></p></li><li><p>使用中括號 <code>[ ]</code> 建立起新的陣列</p></li><li><p>每個元素以逗號 <code>,</code> 隔開</p></li><li><p>可以透過 <code>.length</code> 來取得陣列長度，而陣列長度是 可以被覆寫 的，如下原來的陣列長度為 3，透過 <code>a.length = 1</code> 將陣列長度改成 1 後，後面的元素就被移除了，之後再透過 <code>a.length = 3</code> 將陣列長度改回 3，後面被移除的元素也只會使用 <code>undefined</code> 來填補</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;boy&quot;</span>, <span class="string">&quot;cat&quot;</span>];</span><br><span class="line">a.length;    <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">a.length = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// [&quot;apple&quot;]</span></span><br><span class="line"></span><br><span class="line">a.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);   <span class="comment">// [&quot;apple&quot;, undefined, undefined]</span></span><br></pre></td></tr></table></figure></li><li><p>陣列的索引是從 <code>0</code> 開始計算的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>.push(&#39;要新增的資料&#39;)</code> 新增資料</p><p>透過 <code>.push()</code> 可以在陣列末端新增新元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">array.push(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);   <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p><code>.splice(&#39;從第幾筆資料開始&#39;,&#39;要刪除幾筆資料&#39;)</code> 刪除資料</p><p>透過 <code>.splice()</code> 可以刪除陣列中指定資料以後的資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line">array.splice(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>);   <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(array);   <span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>可以直接指定改變元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">array[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array);   <span class="comment">// [&#x27;a&#x27;, &#x27;B&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>除了 <code>.push</code> 外，陣列還有許多語法，可以參考以下連結</p><p><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array">Array 語法</a></p></li><li><p>使用 <code>typeof</code> 來判斷陣列和物件都會顯示 <code>object</code>，我們可以使用 <code>.inArray</code> 來判斷此變數是陣列而非物件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]);            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]);           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>());   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray();              <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>);          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);     <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="陣列-物件"><a href="#陣列-物件" class="headerlink" title="陣列 + 物件"></a>陣列 + 物件</h2><p>陣列和物件時常會混和著使用，陣列透過中括號 <code>[ ]</code>，而物件透過點 <code>.</code> 來撈出資料</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> farms = [</span><br><span class="line">  &#123;</span><br><span class="line">    dogs: [<span class="string">&#x27;張姆士&#x27;</span>, <span class="string">&#x27;龐的&#x27;</span>],</span><br><span class="line">    chick: <span class="number">15</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    dogs: [<span class="string">&#x27;皮皮&#x27;</span>],</span><br><span class="line">    chick: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(farm[<span class="number">1</span>].dogs[<span class="number">0</span>]);   <span class="comment">// &#x27;皮皮&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入門篇 - function</title>
      <link href="/javascript/20190926/b767e9f3/"/>
      <url>/javascript/20190926/b767e9f3/</url>
      
        <content type="html"><![CDATA[<p>函式 <code>function</code> 指的是將一段程式指令包裝起來，可以重複使用且維護容易，也不會互相干擾</p><span id="more"></span><h2 id="定義函式的方式"><a href="#定義函式的方式" class="headerlink" title="定義函式的方式"></a>定義函式的方式</h2><h3 id="函式宣告（Function-Declaration"><a href="#函式宣告（Function-Declaration" class="headerlink" title="函式宣告（Function Declaration)"></a>函式宣告（Function Declaration)</h3><p>函式宣告為最常見的寫法</p><ul><li><p>函式最面前使用 <code>function</code> 進行宣告</p></li><li><p>接著是函式的名稱 ，但也有可能沒有名稱</p></li><li><p>再來是小括號 <code>( )</code> 的部分，稱為參數 <code>arguments</code>，參數可以不只一個，參數之間使用逗號 , 隔開</p></li><li><p>最後是大括號 <code>&#123; &#125;</code> 的部分，內含需要重複執行的內容，是函式的主要功能區塊</p></li><li><p>透過呼叫函式名稱來使用函式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函式名稱 (<span class="params">參數<span class="number">1</span>, 參數<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">  重複執行的內容</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呼叫函式</span></span><br><span class="line">函式名稱 (參數<span class="number">1</span>, 參數<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="函式表達式-Function-Expressions"><a href="#函式表達式-Function-Expressions" class="headerlink" title="函式表達式 (Function Expressions)"></a>函式表達式 (Function Expressions)</h3><p>函式運算式是透過等號 <code>=</code> 將函式指定給某個變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 變數名稱 = <span class="function"><span class="keyword">function</span> (<span class="params">參數</span>)</span>&#123; 重複執行的內容 &#125;;</span><br></pre></td></tr></table></figure><p>這裡可以發現在等號 <code>=</code> 後面的函式 “沒有函式名稱”，因為這裡的函式名稱只有在自己 “函式內的區塊” 有效，脫離此函式後，函式名稱就不存在，使用此函式則是直接呼叫變數名稱</p><h2 id="變數的有效範圍-Scope"><a href="#變數的有效範圍-Scope" class="headerlink" title="變數的有效範圍 Scope"></a>變數的有效範圍 <code>Scope</code></h2><p>變數分為 “全域變數” 和 “區域變數”，切分變數有效範圍的最小單位是 <code>function</code>，我們透過以下程式碼來解釋他們的差異</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全域變數</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 區域變數</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( count(<span class="number">50</span>) );   <span class="comment">// 150</span></span><br><span class="line"><span class="built_in">console</span>.log( x );   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>在函式內宣告的變數稱為 區域變數，區域變數只有在函式執行的時候存在</li><li>在函式外宣告的變數稱為 全域變數，因為區域變數只屬於函式內，所以最後的 console.log( x ); 自然是全域變數的 1</li><li>所以函式內外兩個變數 x 其實是不同的變數</li></ul><h3 id="如何取得函式內的值"><a href="#如何取得函式內的值" class="headerlink" title="如何取得函式內的值 ?"></a>如何取得函式內的值 ?</h3><p>透過在函式外宣告變數，在函式內賦值，在呼叫函式後，我們就可以取得函式內的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全域變數</span></span><br><span class="line"><span class="keyword">var</span> total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">numOne, numTwo</span>)</span>&#123;</span><br><span class="line">  total = numOne + numTwo;</span><br><span class="line">  <span class="built_in">console</span>.log(total + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">count(<span class="number">8</span>, <span class="number">10</span>);   <span class="comment">// 18元</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(total);   <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><h3 id="沒有使用-var-宣告的變數很危險"><a href="#沒有使用-var-宣告的變數很危險" class="headerlink" title="沒有使用 var 宣告的變數很危險"></a>沒有使用 <code>var</code> 宣告的變數很危險</h3><p>如果全域變數已經有賦值，函式內的變數沒有使用 <code>var</code> 宣告，就會向外層尋找同名的變數，直到最外層的 “全域變數”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全域變數</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span> (<span class="params">y</span>)</span>&#123;</span><br><span class="line">  x = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( doSomeThing(<span class="number">50</span>) );   <span class="comment">// 150</span></span><br><span class="line"><span class="built_in">console</span>.log( x );   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h2 id="全域物件-window"><a href="#全域物件-window" class="headerlink" title="全域物件 window"></a>全域物件 window</h2><p>所有宣告的全域變數其實都是 “全域物件(頂級物件) window “的屬性，在瀏覽器的 <code>console</code> 輸入 <code>window</code>，我們可以看到所有功能和已經宣告的全域變數</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">window</span>.a );   <span class="comment">// 10 </span></span><br></pre></td></tr></table></figure><p><img src="window.png"></p><h2 id="提升-hoisting"><a href="#提升-hoisting" class="headerlink" title="提升 hoisting"></a>提升 <code>hoisting</code></h2><h3 id="變數的提升"><a href="#變數的提升" class="headerlink" title="變數的提升"></a>變數的提升</h3><p>對於已經選告的變數，JS 會自動將其提升至最上方，但要注意的是，提升的只有 “變數的宣告” ，”不包括變數的值”，所以變數還是盡量都在最上面宣告完後再開始使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in .js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span> (<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( x );   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 瀏覽器解讀</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span> (<span class="params">y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x;   <span class="comment">// 變數宣告提升至 scope 最上方</span></span><br><span class="line">  <span class="built_in">console</span>.log ( x );  <span class="comment">// undefined</span></span><br><span class="line">  </span><br><span class="line">  x = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="函式的提升"><a href="#函式的提升" class="headerlink" title="函式的提升"></a>函式的提升</h3><h4 id="函式宣告"><a href="#函式宣告" class="headerlink" title="函式宣告"></a>函式宣告</h4><p>與變數不同的地方是使用 函式宣告 定義的函式會連同內容完全提升，所以可以在宣告前呼叫使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">square(<span class="number">2</span>);   <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函式運算式"><a href="#函式運算式" class="headerlink" title="函式運算式"></a>函式運算式</h4><p>但透過 “函式運算式” 定義的函式則會出現 “錯誤”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">square(<span class="number">2</span>);   <span class="comment">// TypeError: square is not a function</span></span><br><span class="line">              </span><br><span class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="回傳-return"><a href="#回傳-return" class="headerlink" title="回傳 return"></a>回傳 <code>return</code></h2><p>透過 <code>return</code> 可以把值回傳給函式，再透過呼叫函式取得值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHamPrice</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hamPrice = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">var</span> total = hamPrice * num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Tom = getHamPrice(<span class="number">20</span>);   <span class="comment">// 1000</span></span><br><span class="line"><span class="keyword">var</span> John = getHamPrice(<span class="number">50</span>);   <span class="comment">// 2500</span></span><br></pre></td></tr></table></figure><h2 id="function-計算機案例"><a href="#function-計算機案例" class="headerlink" title="function 計算機案例"></a><code>function</code> 計算機案例</h2><p><a href="https://codepen.io/Jerry-Yeh/pen/JQBxmr?editors=0010">範例程式碼</a></p><ul><li>首先透過 <code>.value</code> 取得內部的值，取得的值為字串 <code>string</code></li><li>再透過 <code>.parseInt</code> 將取得的值由字串 <code>string</code> 轉為數字 <code>number</code></li><li>最後將數字運算完後透過 <code>.textContent</code> 帶入</li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>變數有效範圍 <code>scope</code> 的最小單位是 <code>function</code><br>即使是在 <code>function</code> 內，沒有使用 <code>var</code> 宣告的變數仍會變成 “全域變數”<br>“全域變數” 指的是全域物件(頂層物件) <code>window</code> 的 “屬性”</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JaveScript入門篇 - 變數</title>
      <link href="/javascript/20190926/b2bfbc85/"/>
      <url>/javascript/20190926/b2bfbc85/</url>
      
        <content type="html"><![CDATA[<p>變數為 JS 用來儲存資料和進行運算的基本單位，可以視為一個存放資料的盒子，透過 <code>var</code> 來宣告，<code>ES6</code> 開始可以使用 <code>let</code> 和 <code>const</code> 來宣告，關於 <code>ES6</code> 於之後的文章再作介紹</p><span id="more"></span><h2 id="變數的規則"><a href="#變數的規則" class="headerlink" title="變數的規則"></a>變數的規則</h2><ul><li><p>開頭不能是數字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 3k = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li><li><p>不能使用中線 <code>-</code> 和點 <code>.</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box-number = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> box.number = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li><li><p>不能使用關鍵字</p><p><a href="https://www.w3schools.com/js/js_reserved.asp">JS 關鍵字列表</a></p></li><li><p>大小寫有區分，變數 <code>app</code> 不等於 <code>App</code></p></li><li><p>盡量使用語意化命名，能透過名稱了解功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li><p>變數名稱是可以使用非英文(中文)的，但在其他語言系統可能會出現亂碼，所以還是盡量避免</p></li></ul><h2 id="變數的資料型別"><a href="#變數的資料型別" class="headerlink" title="變數的資料型別"></a>變數的資料型別</h2><p>變數本身沒有型別，變數的值才有，我們可以使用 <code>typeof</code> 運算子來判斷型別，型別分成基本型別 <code>string</code>、<code>number</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>，除了以上幾種型別，其他可以歸類為物件型別 <code>object</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="literal">true</span>);   <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">&#x27;name&#x27;</span>);   <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="number">123</span>);   <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span>(&#123; &#125;);   <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span>([ ]);   <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特例</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="built_in">window</span>.alert);   <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>);   <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>由以上結果可以看到 <code>function</code> 這個型別，但 <code>function</code> 其實不是一種獨立的型別，<code>function</code> 仍然是屬於 <code>object</code><br>而 <code>null</code> 反而是不屬於 <code>object</code>，而是獨立的 <code>null</code> 型別，詳細可以參考以下資料</p><p><a href="https://javascriptrefined.io/null-and-typeof-9330e475d272">Null and typeof</a><br><a href="https://2ality.com/2013/10/typeof-null.html">The history of “typeof null”</a></p><ul><li><h3 id="數字-number"><a href="#數字-number" class="headerlink" title="數字 number"></a>數字 number</h3><p>分為整數和浮點數(有小數)，可以透過加 <code>+</code> 、減 <code>-</code>、乘 <code>*</code>、除 <code>/</code> 來做運算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10.32</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span> + <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><h3 id="字串-string"><a href="#字串-string" class="headerlink" title="字串 string"></a>字串 string</h3><ul><li><p>字串必須用單引號 <code>&#39;&#39;</code> 或雙引號 <code>&quot;&quot;</code> 將其包住，而兩者不可混用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;字串1&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;字串2&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">&quot;字串3&#x27;;  // error</span></span><br></pre></td></tr></table></figure></li><li><p>如果內容出現單引號 ‘，就只能用雙引號 <code>&quot;&quot;</code> 包住，若非用不可，可以使用反斜線 <code>\</code> 跳脫字元 (escape character)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Let&#x27;</span>s go!<span class="string">&#x27;;  // error</span></span><br><span class="line"><span class="string">var str = &quot;Let&#x27;</span>s go!<span class="string">&quot;; // OK</span></span><br><span class="line"><span class="string">var str = &#x27;Let\&#x27;s go!&#x27;;  // OK</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用加號 <code>+</code> 來組合字串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>+<span class="string">&#x27;World&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>多行字串可以透過反斜線 <code>\</code> 來換行繼續，注意 每行的反斜線 <code>\</code> 之後不能有任何東西，包括 <code>空白</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;第一行 \</span></span><br><span class="line"><span class="string">第二行 \</span></span><br><span class="line"><span class="string">第三行&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><h3 id="布林值-boolean"><a href="#布林值-boolean" class="headerlink" title="布林值 boolean"></a>布林值 <code>boolean</code></h3><p>分為 true 和 false 兩種，通常用在判斷式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = (<span class="number">100</span> &gt; <span class="number">10</span>);  <span class="comment">//true </span></span><br></pre></td></tr></table></figure></li><li><h3 id="空值-null"><a href="#空值-null" class="headerlink" title="空值 null"></a>空值 <code>null</code></h3><p>代表曾經有值或沒有值，但現在此變數沒有值</p></li><li><h3 id="未定義-undefined"><a href="#未定義-undefined" class="headerlink" title="未定義 undefined"></a>未定義 <code>undefined</code></h3><p>變數的宣告分成兩個步驟，”宣告” 與 “賦值”，當已經宣告變數但還未賦值時，就會出現 <code>undefined</code></p></li><li><h3 id="物件-object"><a href="#物件-object" class="headerlink" title="物件 object"></a>物件 <code>object</code></h3><p>除了以上型別，其他都可以歸類為物件型別，關於物件型別後續會在介紹</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入門篇 - JavaScript簡介與環境</title>
      <link href="/javascript/20190926/e0d364c/"/>
      <url>/javascript/20190926/e0d364c/</url>
      
        <content type="html"><![CDATA[<p>作為前端領域最強勢的語言，<code>JavaScript</code> 隨著新版本演進，功能日趨完善，也不斷出現如 <code>jQuery</code> 與 <code>Vue.js</code> 等開源框架，讓 <code>JavaScript</code> 成為學習前端不可或缺的技能 ; 在這篇文章中，將透過 <code>VSCode</code> 來做為開發的編輯器，並部屬基礎環境設定</p><span id="more"></span><h2 id="JavaScript-環境設定"><a href="#JavaScript-環境設定" class="headerlink" title="JavaScript 環境設定"></a>JavaScript 環境設定</h2><p>有時候我們會利用 JavaScript 新增 HTML 樣板到 HTML 檔案中，而 VSCode 預設在 JavaScript 檔案中是無法使用 <code>Emmet</code> 的，因此我們要在 VSCode 的設定中的 <code>setting.json</code> 加上以下文字</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in setting.json </span></span><br><span class="line">&quot;emmet.includeLanguages&quot;: &#123;</span><br><span class="line">  &quot;javascript&quot;: &quot;html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建構一個-JavaScript-環境"><a href="#建構一個-JavaScript-環境" class="headerlink" title="建構一個 JavaScript 環境"></a>建構一個 JavaScript 環境</h2><p>如同 CSS 使用 <code>&lt;link&gt;</code> 載入 <code>.css</code> 檔案或使用 <code>&lt;style&gt;&lt;/style&gt;</code> 在內部直接撰寫 CSS，JavaScript 是使用 <code>&lt;script&gt;&lt;/script&gt;</code>，而又因為 HTML 是 “由上而下” 讀取，JS 時常會操作當中的 <code>DOM 元素</code>，所以 JS 要放在 “網頁內容之後” 以避免出現目標元素還未渲染而造成讀取錯誤的情況</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 網頁內容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          </span><br><span class="line">  <span class="comment">&lt;!-- 載入 .js 檔案 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/all.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 直接撰寫 JS --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;Hello World!&#x27;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML、CSS、JavaScript-的關聯性"><a href="#HTML、CSS、JavaScript-的關聯性" class="headerlink" title="HTML、CSS、JavaScript 的關聯性"></a>HTML、CSS、JavaScript 的關聯性</h2><ul><li><code>HTML</code> - 內容 : HTML 負責網頁的內容，為網頁的骨架</li><li><code>CSS</code> - 樣式 : CSS 負責網頁的樣式，替網站添加裝飾</li><li><code>JavaScript</code> - 行為 : JavaScript 負責網頁的行為，可以動態操作 HTML、CSS，也可以連接外部的伺服器與資料庫，與使用者互動</li></ul><h2 id="ID-與-textContent"><a href="#ID-與-textContent" class="headerlink" title="ID 與 textContent"></a>ID 與 textContent</h2><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><ul><li><p><code>ID 選擇器</code> 具備 “錨點功能”，也就是能定位在網頁上，如果指定到該錨點，會在網址後方加上該 <code>ID</code> 名稱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 選定前網址 *&#x2F; </span><br><span class="line">https:&#x2F;&#x2F;jerry-yeh.github.io&#x2F;website&#x2F;html&#x2F;JavaScript&#x2F;JavaScript-入門篇.html</span><br><span class="line"></span><br><span class="line">&#x2F;* 選定後網址 *&#x2F; </span><br><span class="line">https:&#x2F;&#x2F;jerry-yeh.github.io&#x2F;website&#x2F;html&#x2F;JavaScript&#x2F;JavaScript-入門篇.html#ID</span><br></pre></td></tr></table></figure></li><li><p>在 JS 中可以透過以下語法選取 ID</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ID 名稱&#x27;</span>).textContent(<span class="string">&#x27;修改後的內容&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h3><p>在 JS 中可以透過此語法選取 <code>DOM 元素</code> 的內容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;ID 名稱&#x27;</span>).textContent(<span class="string">&#x27;修改後的內容&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="直譯器流程介紹"><a href="#直譯器流程介紹" class="headerlink" title="直譯器流程介紹"></a>直譯器流程介紹</h2><p>瀏覽器接收到網頁後，就會由上而下開始解析網頁內容，當解析到 JS <code>&lt;script&gt;&lt;/script&gt;</code> 的部份時，會透過瀏覽器的引擎來將我們寫的 JS 程式語言轉換成電腦認識的語言，而這中介的引擎稱為直譯器 <code>interpreter</code>，如 <code>Chrome</code> 的 <code>V8</code> 引擎，而解析完後瀏覽器才會繼續渲染網頁內容</p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://www.udemy.com/javascript-learning/">六角課程 - JavaScript 入門篇 - 學徒的試煉</a><br><a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 入門</title>
      <link href="/git/20190926/a121fcd1/"/>
      <url>/git/20190926/a121fcd1/</url>
      
        <content type="html"><![CDATA[<p>Git 為分散式版本控制系統，最初目的是為更好地管理Linux核心開發而設計</p><span id="more"></span><h2 id="Git-簡介"><a href="#Git-簡介" class="headerlink" title="Git 簡介"></a>Git 簡介</h2><h3 id="什麼是「分散式」"><a href="#什麼是「分散式」" class="headerlink" title="什麼是「分散式」?"></a>什麼是「分散式」?</h3><p>「分散式」版本控制系統也需要一台專用的伺服器，但即使沒有伺服器或網路的情況下也可以在本地端進行版本更新，等待網路或伺服器恢復再上傳更新，不會受到影響，而 Git 大部分也可以在自己電腦完成</p><h3 id="什麼是「版本控制系統」"><a href="#什麼是「版本控制系統」" class="headerlink" title="什麼是「版本控制系統」 ?"></a>什麼是「版本控制系統」 ?</h3><p>「版本控制系統」指的是會幫你紀錄每次檔案的新增、刪除與修改的狀態變化，並同時記錄修改者的名稱與修改時間，因此檔案出錯時可以輕易找出原因，如果檔案損毀也可以回到上一個紀錄重新來過</p><h3 id="速度快、檔案體積小"><a href="#速度快、檔案體積小" class="headerlink" title="速度快、檔案體積小"></a>速度快、檔案體積小</h3><p>過去要記錄每次檔案的版本往往是複製整個新的檔案或是只複製每個版本的差異，因此檔案會隨著不斷的修改與更新而使檔案大小日益增加</p><p>Git 在版本控制上不同的地方在於使用「快照」（snapshot），如同相機拍照般拍下每式的版本內容，在開啟某個版本時，並非拼湊每次的更新差異，而是各個檔案自動搜尋選擇的版本以前各自最新的檔案版本，因此速度上也較快</p><h2 id="常用的終端機指令"><a href="#常用的終端機指令" class="headerlink" title="常用的終端機指令"></a>常用的終端機指令</h2><h3 id="目錄切換"><a href="#目錄切換" class="headerlink" title="目錄切換"></a>目錄切換</h3><p>輸入 <code>cd</code> 加一個空格後，目錄位置可以複製按右鍵貼上，或是直接將目錄拖曳進終端機</p><p>切換到目錄 (絕對路徑)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /目錄</span><br></pre></td></tr></table></figure><p>切換到目錄 (相對路徑)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> 目錄</span><br></pre></td></tr></table></figure><p>往上一層目錄移動</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>切換到使用者的 <code>home</code> 目錄中的 <code>project</code> 裡的 <code>cards</code> 目錄，”~” 表示 <code>home</code> 目錄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/project/cards</span><br></pre></td></tr></table></figure><p>展開列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br></pre></td></tr></table></figure><h3 id="檔案與目錄"><a href="#檔案與目錄" class="headerlink" title="檔案與目錄"></a>檔案與目錄</h3><p>建立目錄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir <span class="string">&quot;目錄名稱&quot;</span></span><br></pre></td></tr></table></figure><p>建立檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch <span class="string">&quot;檔案名稱&quot;</span></span><br></pre></td></tr></table></figure><p>移除檔案名稱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm <span class="string">&quot;檔案名稱&quot;</span></span><br></pre></td></tr></table></figure><p>刪除所有的 html 檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm *.html </span><br></pre></td></tr></table></figure><p>把檔案 a.html 複製一份成 b.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp a.html b.html</span><br></pre></td></tr></table></figure><p>把檔案 a.html 更名成 b.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv a.html b.html</span><br></pre></td></tr></table></figure><h2 id="Git-環境設定"><a href="#Git-環境設定" class="headerlink" title="Git 環境設定"></a>Git 環境設定</h2><h3 id="使用者設定"><a href="#使用者設定" class="headerlink" title="使用者設定"></a>使用者設定</h3><p>設定使用者的名稱與信箱，每台電腦只有第一次需要設定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">&quot;your email&quot;</span></span><br><span class="line">$ git config --global user.name <span class="string">&quot;your name&quot;</span></span><br></pre></td></tr></table></figure><p>查詢使用者設定列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><p>輸入以上指令後會出現許多資訊，如要確認使用者資訊，只須尋找以下兩點</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.name = <span class="string">&quot;your name&quot;</span></span><br><span class="line">user.email = <span class="string">&quot;your email&quot;</span></span><br></pre></td></tr></table></figure><h3 id="每個專案設定不同作者"><a href="#每個專案設定不同作者" class="headerlink" title="每個專案設定不同作者"></a>每個專案設定不同作者</h3><p>前面新增的 <code>--global</code> 參數為全域設定，如需將特定專案設定不同作者，在專案開始前的 <code>git</code> 設定，加上 <code>--local</code> 參數</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --<span class="built_in">local</span> user.email <span class="string">&quot;your email&quot;</span></span><br><span class="line">$ git config --<span class="built_in">local</span> user.name <span class="string">&quot;your name&quot;</span></span><br></pre></td></tr></table></figure><p>查詢 Git 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git version</span><br></pre></td></tr></table></figure><h2 id="Git-流程圖"><a href="#Git-流程圖" class="headerlink" title="Git 流程圖"></a>Git 流程圖</h2><p>基礎的操作方式為先將要追蹤的檔案使用 <code>add</code> 新增索引，接著使用 <code>commit</code> 提交更新紀錄，最後再將更新的紀錄使用 <code>push</code> 上傳至 “遠端數據庫”，更進階的指令後面會再一一介紹</p><p><img src="git-progress.png"></p><h2 id="Git-基礎操作"><a href="#Git-基礎操作" class="headerlink" title="Git 基礎操作"></a>Git 基礎操作</h2><h3 id="安裝遠端-本地端數據庫"><a href="#安裝遠端-本地端數據庫" class="headerlink" title="安裝遠端/本地端數據庫"></a>安裝遠端/本地端數據庫</h3><p>安裝本地端數據庫 : 先使用 <code>cd</code> 指令到要建立數據庫的目錄，再建立數據庫</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> </span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>安裝遠端數據庫 : 先使用 <code>cd</code> 指令到要建立數據庫的目錄，再建立數據庫</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> </span><br><span class="line">$ git <span class="built_in">clone</span> <span class="string">&quot;遠端數據庫網址&quot;</span></span><br></pre></td></tr></table></figure><p>建立數據庫後會出現 <code>master</code> (版本紀錄的主軸)</p><h3 id="基礎操作流程"><a href="#基礎操作流程" class="headerlink" title="基礎操作流程"></a>基礎操作流程</h3><p>將所有檔案加入索引(暫存區)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add . </span><br><span class="line">$ git add --all </span><br></pre></td></tr></table></figure><p><strong>以上兩者的差異為何 ?</strong><br><code>git add .</code> 只會將當下這個目錄與其子目錄加入索引，但這個目錄以外的檔案不會，而 <code>git add--all</code> 就沒有這個問題了，不管在哪執行都會將所有改變加入索引</p><p>將單一檔案加入索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add <span class="string">&quot;檔案名稱&quot;</span> </span><br></pre></td></tr></table></figure><p>查詢狀態，包含新增、刪除與修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br></pre></td></tr></table></figure><p>將加入索引的檔案提交更新紀錄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;更新紀錄名稱&quot;</span> </span><br></pre></td></tr></table></figure><p>更新紀錄查詢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> </span><br></pre></td></tr></table></figure><p>推送數據到遠端數據庫</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push </span><br></pre></td></tr></table></figure><h3 id="gitignore-忽略檔案"><a href="#gitignore-忽略檔案" class="headerlink" title=".gitignore 忽略檔案"></a>.gitignore 忽略檔案</h3><p>新增 .gitignore 檔案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir .gitginore </span><br></pre></td></tr></table></figure><p><strong>開啟 <code>.gitignore</code> 檔案，輸入要忽略的檔案</strong><br>忽略 index.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.html</span><br></pre></td></tr></table></figure><p>忽略所有 html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*.html</span><br></pre></td></tr></table></figure><p>忽略整個 css 資料夾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css/</span><br></pre></td></tr></table></figure><h3 id="工作狀態還原"><a href="#工作狀態還原" class="headerlink" title="工作狀態還原"></a>工作狀態還原</h3><p>取消所有檔案的索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD</span><br></pre></td></tr></table></figure><p>取消單一檔案的索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD <span class="string">&quot;檔案名稱&quot;</span></span><br></pre></td></tr></table></figure><p>還原所有檔案至最新的 commit 狀態</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard</span><br></pre></td></tr></table></figure><p>還原單一檔案至最新的 commit 狀態</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="string">&quot;檔案名稱&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Git-分支-branch"><a href="#Git-分支-branch" class="headerlink" title="Git 分支(branch)"></a>Git 分支(branch)</h2><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p><code>HEAD</code> 代表目前所在的位置，預設的位置為 <code>master</code>，藉由切換 <code>HEAD</code>，可以瀏覽其他的 <code>commit</code> 紀錄</p><p>每個 <code>commit</code> 都有自己的代碼，藉由輸入代碼的前四碼或以上可以切換到該 <code>commit</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="string">&quot;前四碼&quot;</span></span><br></pre></td></tr></table></figure><p>切換 <code>HEAD</code> 回到 <code>master</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><h3 id="建立分支"><a href="#建立分支" class="headerlink" title="建立分支"></a>建立分支</h3><p>在多人協作或已上線程式時，為避免更新時將 <code>master</code> 改壞，所以會先新增 <code>branch</code> 進行版本更新，確認更新內容無誤後再將 <code>branch</code> 合併回 <code>master</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch <span class="string">&quot;分支名稱&quot;</span></span><br></pre></td></tr></table></figure><p>分支查詢 : 如果新增一支名為 <code>feature</code> 的分支，使用分支查詢後就會出現 <code>feature</code> 與 <code>master</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  master</span><br><span class="line">  feature</span><br></pre></td></tr></table></figure><h3 id="合併分支"><a href="#合併分支" class="headerlink" title="合併分支"></a>合併分支</h3><p>先回到 <code>master</code> ，再合併分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge <span class="string">&quot;分支名稱&quot;</span></span><br></pre></td></tr></table></figure><p>如果 <code>master</code> 與分支都有更新，在合併時會出現以下訊息，輸入 <code>:wq!</code> ，即可離開並自動合併，但分支仍保留原先檔案狀態</p><p><img src="auto-merge.png"></p><h3 id="解決合併分支衝突"><a href="#解決合併分支衝突" class="headerlink" title="解決合併分支衝突"></a>解決合併分支衝突</h3><p>如果再合併分支時，<code>master</code> 與分支在同一行出現不同資料時，就會出現衝突而無法自動合併，這時候只能使用手動合併的方式選擇要保留那些資料，以下是 VS code 出現衝突時的介面</p><p><img src="conflict-merge.png"></p><h2 id="標籤-tag"><a href="#標籤-tag" class="headerlink" title="標籤 (tag)"></a>標籤 (tag)</h2><p>為特定的 <code>commit</code> 加上標籤，例如重要的版本，可以使切換版本上更為輕鬆</p><p>新增輕量標籤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag <span class="string">&quot;標籤名稱&quot;</span></span><br></pre></td></tr></table></figure><p>新增標示標籤，備註內容外的 “” 需要保留</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -am <span class="string">&quot;備註內容&quot;</span> <span class="string">&quot;標籤名稱&quot;</span></span><br></pre></td></tr></table></figure><p>查詢標籤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p>查詢詳細標籤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -n</span><br></pre></td></tr></table></figure><p>切換到標籤的 commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="string">&quot;標籤名稱&quot;</span></span><br></pre></td></tr></table></figure><h2 id="暫存-stash"><a href="#暫存-stash" class="headerlink" title="暫存 (stash)"></a>暫存 (stash)</h2><p>如遇突發狀況時，暫存可將修改的內容先記錄起來，再切換到其他分支作業，作業完後切換回來並還原暫存即可繼續原來的工作</p><p>暫時儲存當前目錄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure><p>還原暫存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><p>清除最新暫存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure><p>清除全部暫存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash clear</span><br></pre></td></tr></table></figure><p>瀏覽暫存列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>如果有多筆暫存資料，輸入瀏覽指令後會出現以下列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: WIP on master: 710851f update</span><br><span class="line">stash@&#123;1&#125;: WIP on master: 710851f update</span><br></pre></td></tr></table></figure><p>還原最近的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure><p>還原第 n 筆暫存內容，n 從 0 開始</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;n&#125;</span><br></pre></td></tr></table></figure><h2 id="Git、Github-團隊協作"><a href="#Git、Github-團隊協作" class="headerlink" title="Git、Github 團隊協作"></a>Git、Github 團隊協作</h2><h3 id="9-1-推送新的分支到遠端數據庫"><a href="#9-1-推送新的分支到遠端數據庫" class="headerlink" title="9-1 推送新的分支到遠端數據庫"></a>9-1 推送新的分支到遠端數據庫</h3><p>查詢遠端數據庫名稱，預設的名稱為 <code>origin</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">  origin</span><br></pre></td></tr></table></figure><p>修改遠端數據庫名稱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename <span class="string">&quot;原名稱(origin)&quot;</span> <span class="string">&quot;新名稱&quot;</span></span><br></pre></td></tr></table></figure><p>推送分支到遠端數據庫</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push <span class="string">&quot;遠端數據庫名稱(預設為 origin)&quot;</span> <span class="string">&quot;分支名稱&quot;</span></span><br></pre></td></tr></table></figure><p><strong>為什麼不能直接使用 git push ?</strong><br>因為如果沒有指定遠端主機與要推送的分支，電腦無法確定要推送到遠端主機 (github)、正式主機 (terminal)或測試主機 (本地端)，且預設推送的分支為 <code>master</code>，所以要指定分支名稱</p><h3 id="下載遠端數據庫"><a href="#下載遠端數據庫" class="headerlink" title="下載遠端數據庫"></a>下載遠端數據庫</h3><p>如果沒有先從遠端數據庫載下最新版本就開始作業，上傳遠端數據庫時會發生衝突，必須先下載最新本進行合併</p><p>首先介紹 <code>fetch</code> ，<code>fetch</code> 就是當遠端數據庫進度超前本地端進度時，使用這個指令會從線上將本地端沒有的內容抓下來，一樣也有 <code>HEAD</code> 和 <code>master</code>，但會在前面加上 <code>origin</code>(遠端數據庫預設名稱)，變成 <code>origin/HEAD</code> 和 <code>origin/master</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br></pre></td></tr></table></figure><p>接著將抓下來的超前內容合併到本地端分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge</span><br></pre></td></tr></table></figure><p><strong>git pull = git fetch + git merge</strong><br>下載遠端數據庫合併到本地端數據庫</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a><br><a href="https://backlog.com/git-tutorial/tw/intro/intro1_1.html">連猴子都能懂的 Git 入門指南</a><br><a href="https://gitbook.tw/chapters/introduction/about-this-book.html">為你自己學 Git</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap 4 Grid System</title>
      <link href="/boostrap/20190925/99a4840c/"/>
      <url>/boostrap/20190925/99a4840c/</url>
      
        <content type="html"><![CDATA[<p>在 Bootstrap 中，設計了相當完善的響應式格線系統，即使沒有要使用其中的模組化框架，也可以單獨使用格線系統，而且只要修改設定檔，就可以輕鬆做出客製化的響應式格線系統 </p><span id="more"></span><h2 id="響應式斷點"><a href="#響應式斷點" class="headerlink" title="響應式斷點"></a>響應式斷點</h2><p>Bootstrap 是設計成行動 (手機) 優先的框架，並透過 <code>media queries</code> 來設立中斷點</p><h3 id="預設斷點"><a href="#預設斷點" class="headerlink" title="預設斷點"></a>預設斷點</h3><p>Bootstrap 的預設斷點</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Small devices (landscape phones, 576px and up) */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">576px</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Medium devices (tablets, 768px and up) */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Large devices (desktops, 992px and up) */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">992px</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extra large devices (large desktops, 1200px and up) */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">1200px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="斷點變數"><a href="#斷點變數" class="headerlink" title="斷點變數"></a>斷點變數</h3><p>Bootstrap 預設的斷點變數如下，我們可以透過修改<code>_variable.scss</code> 中的變數來新增或刪除斷點</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grid-breakpoints</span>: (</span><br><span class="line">  xs: <span class="number">0</span>,</span><br><span class="line">  sm: <span class="number">576px</span>,</span><br><span class="line">  md: <span class="number">768px</span>,</span><br><span class="line">  lg: <span class="number">992px</span>,</span><br><span class="line">  xl: <span class="number">1200px</span></span><br><span class="line">) !default;</span><br></pre></td></tr></table></figure><h3 id="mixin"><a href="#mixin" class="headerlink" title="@mixin"></a>@mixin</h3><p>我們也可以透過 Bootstrap 寫好的 <code>@mixin</code> 使用最大、最小或特定螢幕尺寸的其中一段</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @media (max-width: 575.98px) */</span></span><br><span class="line"><span class="keyword">@include</span> media-breakpoint-down(xs) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @media (min-width: 576px) */</span></span><br><span class="line"><span class="keyword">@include</span> media-breakpoint-up(sm) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @media (min-width: 576px) and (max-width: 1199.98px) */</span></span><br><span class="line"><span class="keyword">@include</span> media-breakpoint-between(sm,xl) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @media (min-width: 576px) */</span></span><br><span class="line"><span class="keyword">@include</span> media-breakpoint-between(sm,lg) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @media (min-width: 576px) and (max-width: 767.98px) */</span></span><br><span class="line"><span class="keyword">@include</span> media-breakpoint-only(sm) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="Grid-System"><a href="#Grid-System" class="headerlink" title="Grid System"></a>Grid System</h2><p>Bootstrap 中的格線系統</p><h3 id="基本架構"><a href="#基本架構" class="headerlink" title="基本架構"></a>基本架構</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 內容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>透過最外層的 <code>.container</code>，為每個斷點提供固定的容器寬度 ; 如果想要滿版寬度，在這層可以使用 <code>.container-fluid</code></li><li>第二層的 <code>.row</code> 為橫列，用來包住內層的欄 <code>.col</code>，確保每個欄位排列適當</li><li>所有內容都放在第三層欄 <code>.col</code> 的 內層，而不是直接撰寫樣式在 <code>.col</code>上，<code>.col</code> 也只能是 <code>.row</code> 的直接子類</li></ul><h3 id="格線變數"><a href="#格線變數" class="headerlink" title="格線變數"></a>格線變數</h3><ul><li><p>預設的欄位數 <code>12</code> 與欄間距 <code>30px</code>，我們可以在 <code>._variable.scss</code> 找到以下相關變數來修改成想要的格式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grid-columns</span>: <span class="number">12</span> !default;</span><br><span class="line"><span class="variable">$grid-gutter-width</span>: <span class="number">30px</span> !default;</span><br></pre></td></tr></table></figure></li><li><p><code>.container</code> 在每個斷點都有預設寬度，同樣的我們也可以在<br><code>._variable.scss</code> 中找到相關變數來修改成想要的寬度</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$container-max-width</span>: (</span><br><span class="line">  sm: <span class="number">540px</span>,</span><br><span class="line">  md: <span class="number">720px</span>,</span><br><span class="line">  lg: <span class="number">960px</span>,</span><br><span class="line">  xl: <span class="number">1140px</span></span><br><span class="line">) !default;</span><br></pre></td></tr></table></figure></li></ul><h3 id="container-容器"><a href="#container-容器" class="headerlink" title="container 容器"></a>container 容器</h3><p>以下為 <code>.container</code> 的預設樣式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>; <span class="comment">/* $grid-gutter-width */</span></span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15px</span>;  <span class="comment">/* $grid-gutter-width */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">1140px</span>;　<span class="comment">/* 隨螢幕尺寸而變 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>margin-right: auto</code> 和 <code>margin-left: auto</code> 為水平置中</li><li>因為有 <code>padding</code>，所以 <code>.container</code> 的實際寬度為 <code>max-width</code> 減 <code>$grid-gutter-width</code>，這個斷點下為 <code>1110px</code></li><li>如果是 <code>.container-fluid</code> 就沒有設定 <code>max-width</code>，所以會自適應延伸滿版寬</li></ul><h3 id="row-列"><a href="#row-列" class="headerlink" title="row 列"></a>row 列</h3><p>以下為<code> .row</code> 的預設樣式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.row</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">15px</span>; <span class="comment">/* $grid-gutter-width */</span></span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">15px</span>; <span class="comment">/* $grid-gutter-width */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>.row</code> 使用 <code>flex</code> 來排版，而 <code>flex</code> 的預設為水平排列</p></li><li><p>負值的 <code>margin</code> 將 <code>.container</code> 的 <code>padding</code> 外推，所以 <code>.container</code> 的內容寬度在此段點變回 1140px</p></li><li><p>因為 <code>.row</code> 是使用 <code>flex</code> 來排版，所以可以直接使用 <code>flexbox</code> 來操作內容，Bootstrap 已經有寫好的 class</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row justify-content-center align-items-end&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="col-欄"><a href="#col-欄" class="headerlink" title="col 欄"></a>col 欄</h3><p>以下為 <code>.col</code> 的預設樣式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">15</span>xp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>因為有 <code>padding</code>，所以此斷點的內容寬度又變回 <code>1110px</code></p></li><li><p>因為是使用 <code>flex</code> 來排版，所以預設每個欄位是等寬的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>當然也可以指定 <code>.col</code> 的寬度，總和超過 <code>12</code> 就會自動換行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="在不同螢幕尺寸下設定不同的寬度"><a href="#在不同螢幕尺寸下設定不同的寬度" class="headerlink" title="在不同螢幕尺寸下設定不同的寬度"></a>在不同螢幕尺寸下設定不同的寬度</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col-</span>&quot;螢幕尺寸&quot;-&quot;欄位數&quot;</span><br></pre></td></tr></table></figure><ul><li>Extra small ( <code>&lt; 576px</code> ) : <code>.col-</code></li><li>Small ( <code>≥ 576px</code> ) : <code>.col-sm-</code></li><li>Extra small ( <code>≥ 768px</code> ) : <code>.col-md-</code></li><li>Large ( <code>≥ 992px</code> ) : <code>.col-lg-</code></li><li>Extra large ( <code>≥ 1200px</code> ) : <code>.col-xl-</code></li></ul><p>Bootstrap 的響應式是 “行動版優先”，也就是 “由小到大”，以下為範例說明</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-12 col-sm-6 col-md-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>欄位預設為 <code>12</code></li><li>螢幕尺寸 <code>≥ 576px</code> 時，欄位為 <code>6</code></li><li>螢幕尺寸 <code>≥ 768px</code> 時，欄位為 <code>3</code></li></ul><h3 id="offset-欄的推移"><a href="#offset-欄的推移" class="headerlink" title="offset 欄的推移"></a>offset 欄的推移</h3><p>如果欄的位移空間與欄間隔相符合，我們就可以使用 <code>offset</code> 向左推移出空欄位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.offset-</span>&quot;螢幕尺寸&quot;-&quot;推移欄位數&quot;</span><br></pre></td></tr></table></figure><p>以下範例為在螢幕尺寸 <code>≥ 768px</code> 時，向左推移 <code>4</code> 欄位</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-3 offset-md-4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Utilities-通用類別"><a href="#Utilities-通用類別" class="headerlink" title="Utilities 通用類別"></a>Utilities 通用類別</h2><p>在 Bootstrap 中，所有共用的變數都會放在 Utilites 這個分類中，以下介紹幾個常見的類別</p><h3 id="spacing-間隔"><a href="#spacing-間隔" class="headerlink" title="spacing 間隔"></a>spacing 間隔</h3><ul><li><h4 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h4><p>我們可以透過 <code>_variable.scss</code> 來修改間距數值，除了新增和刪除，也可以修改 “單位”</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$spacer</span>: <span class="number">1rem</span> !default;</span><br><span class="line"><span class="variable">$spacers</span>: () !default;</span><br><span class="line"></span><br><span class="line"><span class="variable">$spacers</span>: map-merge (</span><br><span class="line">  (</span><br><span class="line">    <span class="number">0</span>: <span class="number">0</span>;</span><br><span class="line">    1: (<span class="variable">$spacer</span> * .<span class="number">25</span>),</span><br><span class="line">    <span class="number">2</span>: (<span class="variable">$spacer</span> * .<span class="number">5</span>),</span><br><span class="line">    <span class="number">3</span>: <span class="variable">$spacer</span>,</span><br><span class="line">    <span class="number">4</span>: (<span class="variable">$spacer</span> * <span class="number">1.5</span>),</span><br><span class="line">    <span class="number">5</span>: (<span class="variable">$spacer</span> * <span class="number">3</span>)</span><br><span class="line">  ),<span class="variable">$spacers</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><h4 id="符號"><a href="#符號" class="headerlink" title="符號"></a>符號</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;屬性&quot;</span><span class="string">&quot;方位&quot;</span>-<span class="string">&quot;螢幕尺寸&quot;</span>-<span class="string">&quot;數值&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>屬性 :<br><code>.m</code> 代表 <code>margin</code><br><code>.p </code>代表 <code>padding</code></p></li><li><p>方位 :<br><code>t</code> 代表 <code>top</code><br><code>r</code> 代表 <code>right</code><br><code>b</code> 代表 <code>bottm</code><br><code>l</code> 代表 <code>left</code><br><code>x</code> 代表 <code>left</code> 和 <code>right</code><br><code>y</code> 代表 <code>top</code> 和 <code>bottom</code><br>沒有給值則是四邊全方位</p></li><li><p><a href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%9E%A2%E5%B9%95%E5%B0%BA%E5%AF%B8%E4%B8%8B%E8%A8%AD%E5%AE%9A%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%AC%E5%BA%A6">螢幕尺寸:</a><br>上方已提過，點選回去查看</p></li><li><p>數值 :<br><code>0</code> 代表 <code>歸零</code><br><code>auto</code> 代表 <code>auto</code><br>其餘數值由上方變數定義，預設為 <code>1 ~ 5</code></p></li></ul></li></ul><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>Bootstrap 4 使用 <code>flex</code> 來排版，並將所有樣式寫成 class 名稱，載入 <code>_utilities.scss</code> 並了解其命名規則就可以靈活運用，詳細參考以下連結</p><p><a href="http://bootstrap.hexschool.com/docs/4.2/utilities/flex/">通用類別 - Flex</a></p><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p><a href="https://getbootstrap.com/">Bootstrap</a><br><a href="https://bootstrap.hexschool.com/">Bootstrap 中文版</a><br><a href="https://github.com/twbs/bootstrap">Bootstrap on Github</a></p>]]></content>
      
      
      <categories>
          
          <category> Boostrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>錯誤的CSS設計方式</title>
      <link href="/css/20190925/1185305d/"/>
      <url>/css/20190925/1185305d/</url>
      
        <content type="html"><![CDATA[<p>在這篇文章中紀錄一下在撰寫 CSS 時，常見的錯誤方式與不利於後續開發的壞習慣</p><span id="more"></span><h2 id="CSS-範圍性常見錯誤"><a href="#CSS-範圍性常見錯誤" class="headerlink" title="CSS 範圍性常見錯誤"></a>CSS 範圍性常見錯誤</h2><p>如果是滿足大部分的樣式盡量寫在外層，其餘的差異再由內層覆蓋，避免重複撰寫相同樣式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 滿足大部分樣式 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;<span class="attribute">font-family</span>: serif&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wrap</span> &#123;<span class="attribute">font-size</span>: <span class="number">16px</span>&#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 其餘差異 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;<span class="attribute">font-size</span>: <span class="number">12px</span>&#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="請勿將高度寫死"><a href="#請勿將高度寫死" class="headerlink" title="請勿將高度寫死"></a>請勿將高度寫死</h2><p>如果將外層高度寫死，當內層高度超過時就無法自適應延伸而破圖，此問題在 <code>RWD</code> 尤為明顯，盡量使用 <code>margin</code> 和 <code>padding</code> 產生相對空間</p><h2 id="請勿使用-ID-綁定網頁樣式"><a href="#請勿使用-ID-綁定網頁樣式" class="headerlink" title="請勿使用 ID 綁定網頁樣式"></a>請勿使用 ID 綁定網頁樣式</h2><p>ID 具備 “錨點功能” ，可以定位網頁位置，也具備 “唯一性” ，如果使用 ID 模組化，後續開發就無法重複使用，且權重較高，新增樣式時難以覆蓋</p><h2 id="解決-JS-與-CSS-功能互相干擾"><a href="#解決-JS-與-CSS-功能互相干擾" class="headerlink" title="解決 JS 與 CSS 功能互相干擾"></a>解決 JS 與 CSS 功能互相干擾</h2><p>將 JS 效果的 class 與樣式分離，好處在於修改 CSS 樣式時不用連同 JS 一併更改，瀏覽 HTML 時，也可以清楚找到有 JS 效果的位置，可以使用前贅詞 <code>js-</code> 區分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary js-hello&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scss 條件與迴圈</title>
      <link href="/scss/20190925/ff62e7a9/"/>
      <url>/scss/20190925/ff62e7a9/</url>
      
        <content type="html"><![CDATA[<p>在 Sass 中，也新增了與一般程式語言類似的條件判斷與迴圈，使 CSS 的運用更加靈活</p><span id="more"></span><h2 id="Conditions-條件運算"><a href="#Conditions-條件運算" class="headerlink" title="Conditions 條件運算"></a>Conditions 條件運算</h2><ul><li><p>Sass 的條件運算與一般程式語言的概念相同，時常會搭配 <code>@function</code> 與 <code>@mixin</code> 組合使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@if</span>(條件)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">@else</span> if(條件)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">@else</span> (條件)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以下為結合 <code>@mixin</code> 做出三角形的作法，使用條件運算產出不同方位的三角形，<code>$type:1</code> 為等腰三角形，<code>$type:0.86666</code> 為正三角形</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line"><span class="keyword">@mixin</span> triangle (<span class="variable">$size</span>, <span class="variable">$color</span>, <span class="variable">$align</span>,<span class="variable">$type</span>:<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">@if</span>  (<span class="variable">$align</span> == top) &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: (<span class="variable">$size</span>*<span class="variable">$type</span>) solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">  &#125;<span class="keyword">@else</span> if  (<span class="variable">$align</span> == right) &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: (<span class="variable">$size</span>*<span class="variable">$type</span>) solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">  &#125;<span class="keyword">@else</span> if  (<span class="variable">$align</span> == bottom)&#123;</span><br><span class="line">    <span class="attribute">border-top</span>: (<span class="variable">$size</span>*<span class="variable">$type</span>) solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">  &#125;<span class="keyword">@else</span> if  (<span class="variable">$align</span> == left)&#123;</span><br><span class="line">    <span class="attribute">border-right</span>: (<span class="variable">$size</span>*<span class="variable">$type</span>) solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: (<span class="variable">$size</span>/<span class="number">2</span>) solid transparent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="keyword">@include</span> triangle(<span class="number">50px</span>, red, top)&#125;</span><br><span class="line"></span><br><span class="line">/* in css */</span><br><span class="line">.box &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid red;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">25px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>現在 CSS 也支援條件運算</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;<span class="attribute">width</span>: <span class="built_in">if</span>(條件, 條件成立帶入的值, 條件不成立帶入的值);&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Loops-迴圈運算"><a href="#Loops-迴圈運算" class="headerlink" title="Loops 迴圈運算"></a>Loops 迴圈運算</h2><h3 id="each-迴圈"><a href="#each-迴圈" class="headerlink" title="@each 迴圈"></a>@each 迴圈</h3><p><code>@each</code> 可以針對陣列 <code>list</code> 和物件 <code>map</code> 中的每一項進行運算，藉由變數 <code>$item</code> 動態帶入每一項進入迴圈</p><ul><li><p>@each 語法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$var</span> in <span class="string">&quot;map or list&quot;</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>list 範例</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line"><span class="variable">$list</span>: (red, blue, green);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$item</span> in <span class="variable">$list</span> &#123;</span><br><span class="line">  .#($item)&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$item</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in css */</span></span><br><span class="line"><span class="selector-class">.red</span> &#123;<span class="attribute">background</span>: red&#125;;</span><br><span class="line"><span class="selector-class">.blue</span> &#123;<span class="attribute">background</span>: blue&#125;;</span><br><span class="line"><span class="selector-class">.green</span> &#123;<span class="attribute">background</span>:green&#125;</span><br></pre></td></tr></table></figure></li><li><p>map 範例，此方式也是 Bootstrap 在管理變數的方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line"><span class="variable">$theme-colors</span>: (</span><br><span class="line">  <span class="string">&#x27;primary&#x27;</span>: blue,</span><br><span class="line">  <span class="string">&#x27;secondary&#x27;</span>: <span class="number">#6c757d</span>;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$name</span>, <span class="variable">$value</span> in <span class="variable">$theme-colors</span> &#123;</span><br><span class="line">  <span class="selector-class">.bg-</span>#&#123;<span class="variable">$name</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in css */</span></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line"><span class="selector-class">.bg-secondary</span> &#123;<span class="attribute">background</span>: <span class="number">#6c757d</span>;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="for-迴圈"><a href="#for-迴圈" class="headerlink" title="@for 迴圈"></a>@for 迴圈</h3><p>Sass 的 <code>@for</code> 迴圈運算與一般程式語言的 <code>for</code> 概念相同，須給定 “起始值” 和 “終止值”</p><ul><li><p><code>@for</code> 語法</p><ul><li><p><code>$i</code> 變數代表 <code>map</code> 和 <code>list</code> 項目的編號</p></li><li><p><code>$begin</code> 和 <code>$end</code> 代表起始值與終止值</p></li><li><p>關鍵字 <code>through</code> 代表從包含起始值到終止值，使用 <code>to</code> 的話則從 “起始值” 開始到 “終止值前一位”</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="variable">$begin</span> through <span class="variable">$end</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>@for 範例: 產生顏色漸變</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">3</span>&#123;</span><br><span class="line">  <span class="selector-class">.box-</span>#&#123;<span class="variable">$i</span>&#125;&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: darken(white, <span class="variable">$i</span> * <span class="number">10%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in css */</span></span><br><span class="line"><span class="selector-class">.box-1</span> &#123;<span class="attribute">background-color</span>: <span class="number">#e6e6e6</span>;&#125;</span><br><span class="line"><span class="selector-class">.box-2</span> &#123;<span class="attribute">background-color</span>: <span class="number">#cccccc</span>;&#125;</span><br><span class="line"><span class="selector-class">.box-3</span> &#123;<span class="attribute">background-color</span>: <span class="number">#b3b3b3</span>;&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scss function</title>
      <link href="/scss/20190924/b33be25b/"/>
      <url>/scss/20190924/b33be25b/</url>
      
        <content type="html"><![CDATA[<p>如同一般程式語言中的函式 <code>function</code> ，Sass 中也提供了類似的方式，而 <code>@function</code> 與 <code>@mixin</code> 不同之處在於其本身就有已經設定好的函式供我們使用，稱為 “內置函式”</p><span id="more"></span><h2 id="function-回傳值"><a href="#function-回傳值" class="headerlink" title="@function 回傳值"></a>@function 回傳值</h2><p>藉由呼叫來使用函式，其本身代表的是一個 “值” ，而不是一個 CSS 樣式，所以無法單獨使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用為錯誤用法</span></span><br><span class="line">darken(#ff3366, <span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作為&quot;變量值&quot;帶入變數中</span></span><br><span class="line"><span class="variable">$redDark</span>: darken(<span class="number">#ff3366</span>, <span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作為&quot;屬性值&quot;帶入 CSS 屬性中</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: darken(<span class="number">#ff3366</span>, <span class="number">50%</span>);&#125;</span><br></pre></td></tr></table></figure><h2 id="內置函式"><a href="#內置函式" class="headerlink" title="內置函式"></a>內置函式</h2><p>Sass 本身就有提供許多已經寫好的函式供我們使用，以下為內置函式的分類</p><ul><li><h3 id="字串函式"><a href="#字串函式" class="headerlink" title="字串函式"></a>字串函式</h3><p><a href="https://yungshenglu.github.io/2018/04/30/SassNotesA3/">Sass 學習雜記 - A3. 字串函式</a></p></li><li><h3 id="數學函式"><a href="#數學函式" class="headerlink" title="數學函式"></a>數學函式</h3><p><a href="https://yungshenglu.github.io/2018/04/30/SassNotesA3/">Sass 學習雜記 - A1. 數學函式</a></p></li><li><h3 id="顏色函式"><a href="#顏色函式" class="headerlink" title="顏色函式"></a>顏色函式</h3><p>常見實用的顏色函式有提高亮度 <code>lighten</code>、降低亮度 <code>darken</code> 、提高飽和度 <code>saturate</code> 、降低飽和度 <code>desaturate</code> 和改變色相值 <code>adjust-hue</code>，可以透過以下連結調色，且不同項目的顏色函式可以疊加使用</p><p><a href="https://sassme.jim-nielsen.com/">Sass 顏色工具｜SassMe</a><br><a href="https://yungshenglu.github.io/2018/04/30/SassNotesA2/">Sass 學習雜記 - A2. 顏色函式</a></p></li></ul><h2 id="自訂函式"><a href="#自訂函式" class="headerlink" title="自訂函式"></a>自訂函式</h2><p>除了以上實用的內置函式，我們也可以自訂想要的函式，函式內部使用 <code>@return</code> 回傳結果到函式名稱，例如將 <code>px</code> 轉成 <code>rem</code> 的函式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line"><span class="keyword">@function</span> pxToRem(<span class="variable">$px</span>, <span class="variable">$base</span>: <span class="number">16</span>)&#123;</span><br><span class="line">  <span class="keyword">@return</span> (<span class="variable">$px</span> / <span class="variable">$base</span>) * <span class="number">1rem</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: pxToRem(<span class="number">20</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in css */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.25rem</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="資料參考"><a href="#資料參考" class="headerlink" title="資料參考"></a>資料參考</h2><p>  <a href="https://yungshenglu.github.io/2018/04/30/SassNotesA3/">Sass 學習雜記 - A3. 字串函式</a><br>  <a href="https://yungshenglu.github.io/2018/04/30/SassNotesA3/">Sass 學習雜記 - A1. 數學函式</a><br>  <a href="https://yungshenglu.github.io/2018/04/30/SassNotesA2/">Sass 學習雜記 - A2. 顏色函式</a></p>]]></content>
      
      
      <categories>
          
          <category> Scss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scss extend</title>
      <link href="/scss/20190924/1a508081/"/>
      <url>/scss/20190924/1a508081/</url>
      
        <content type="html"><![CDATA[<p>為了不要使 CSS 太過龐大，遇到相同樣式時，都會將其合併起來，但這會遇到一個問題，如果開發到後面程式碼太多，遇到相同樣式要合併時又得拉到前面找出來合併</p><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 第20行 */</span></span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">h1</span>, <span class="selector-class">.content</span> <span class="selector-tag">h1</span>, <span class="selector-class">.footer</span> <span class="selector-tag">h1</span> &#123;...&#125; </span><br><span class="line"><span class="comment">/* 第400行 */</span></span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">h1</span> &#123;...&#125;</span><br><span class="line"><span class="comment">/* 第4000行 */</span></span><br><span class="line"><span class="selector-class">.footer</span> <span class="selector-tag">h1</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="extend-基本運用"><a href="#extend-基本運用" class="headerlink" title="@extend 基本運用"></a>@extend 基本運用</h2><p>透過 <code>@extend</code> 可以將其他的 class 拉進來合併延伸使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line"><span class="selector-class">.box1</span> &#123;<span class="attribute">color</span>: red&#125;</span><br><span class="line">.box2 &#123;</span><br><span class="line">  width: <span class="number">100px</span>;</span><br><span class="line">  <span class="keyword">@extend</span> .box1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in css */</span></span><br><span class="line"><span class="selector-class">.box1</span>, <span class="selector-class">.box2</span> &#123;<span class="attribute">color</span>: red&#125;</span><br><span class="line">.box2 &#123;width: <span class="number">100px</span>&#125;</span><br></pre></td></tr></table></figure><p>須注意合併樣式的先後順序，以下情況 <code>.box2</code> 的 <code>border-color</code> 樣式就會被覆蓋</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss*/</span></span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .box1 ;</span><br><span class="line">  <span class="attribute">border-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box1</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> solid red&#125;</span><br><span class="line"></span><br><span class="line">/* in css */</span><br><span class="line">.box2 &#123;border-color: blue;&#125;</span><br><span class="line"><span class="selector-class">.box1</span>, <span class="selector-class">.box2</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> solid red&#125;</span><br></pre></td></tr></table></figure><h2 id="專門被呼叫的樣式"><a href="#專門被呼叫的樣式" class="headerlink" title="% 專門被呼叫的樣式"></a>% 專門被呼叫的樣式</h2><p>可以用 <code>%</code> 建立一個樣式，只有使用 <code>@extend</code> 呼叫時才會作用，本身並不會被 Sass 編譯成 CSS</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line">%all-<span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>: red&#125;</span><br><span class="line">.header &#123;</span><br><span class="line">  width: <span class="number">100px</span>;</span><br><span class="line">  <span class="keyword">@extend</span> %all-h1</span><br><span class="line">&#125;;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="keyword">@extend</span> %all-h1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in css */</span></span><br><span class="line"><span class="selector-class">.header</span>, <span class="selector-class">.footer</span> &#123;<span class="attribute">color</span>: red&#125;;</span><br><span class="line"><span class="selector-class">.header</span> &#123;<span class="attribute">width</span>: <span class="number">100px</span>&#125;;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;<span class="attribute">width</span>: <span class="number">200px</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="extend-與-mixin-的差異"><a href="#extend-與-mixin-的差異" class="headerlink" title="@extend 與 @mixin 的差異"></a>@extend 與 @mixin 的差異</h2><ul><li><h3 id="extend"><a href="#extend" class="headerlink" title="@extend"></a>@extend</h3><p>主要用於樣式的合併，無法帶入參數，如果樣式固定，使用 <code>@extend</code> 程式碼會較為簡潔</p></li><li><h3 id="mixin"><a href="#mixin" class="headerlink" title="@mixin"></a>@mixin</h3><p>將整包程式碼帶到對應的 <code>class</code> 內，可以帶入參數，適合用於多變數運算</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scss mixin</title>
      <link href="/scss/20190924/4fef1f83/"/>
      <url>/scss/20190924/4fef1f83/</url>
      
        <content type="html"><![CDATA[<p>透過 <code>@mixin</code> 可以省去重複撰寫相同的程式碼，並將 CSS 技巧儲存成工具包，快速取用，避免往後用到時還要從舊資料找方法</p><span id="more"></span><h2 id="mixin-用法"><a href="#mixin-用法" class="headerlink" title="@mixin 用法"></a>@mixin 用法</h2><p>以指令 <code>@mixin</code> 進行宣告，並以 <code>@include</code> 呼叫載入，以下為 “圖片取代文字” 的 CSS 技巧</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in Scss</span></span><br><span class="line"><span class="keyword">@mixin</span> text-hide &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">101%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.brand</span> &#123;<span class="keyword">@include</span> text-hide;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in css</span></span><br><span class="line"><span class="selector-class">.brand</span> &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">101%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="參數"><a href="#參數" class="headerlink" title="參數"></a>參數</h2><p><code>@mixin</code> 還可以導入參數並給予預設值，如果沒有給值就會自動導入預設值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in scss</span></span><br><span class="line"><span class="keyword">@mixin</span> bg (<span class="variable">$bgc</span>:red, <span class="variable">$width</span>:<span class="number">200px</span>)&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$bgc</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="keyword">@include</span> bg&#125;</span><br><span class="line">.box2 &#123;<span class="keyword">@include</span> bg(blue, <span class="number">300px</span>)&#125;</span><br><span class="line"></span><br><span class="line">// in css</span><br><span class="line">.box &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字串內插"><a href="#字串內插" class="headerlink" title="#{ } 字串內插"></a>#{ } 字串內插</h2><ul><li><p>Sass 的字串內插是將一個字串型態的變數放在兩個字串之間</p></li><li><p>對於 Sass 的組合來說，字串內插使我們能在選取項中重複使用 相同的 “字串變數” 和 “檔案名稱”</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in scss</span></span><br><span class="line"><span class="keyword">@mixin</span> bgi (<span class="variable">$file</span>)&#123;<span class="attribute">background-image</span>: url(#(<span class="variable">$file</span>).png)&#125;;</span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="keyword">@include</span> bgi(test)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in css</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">background-image</span>:url(test.png)&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果要將變數帶入 <code>class</code> 也必須使用此符號包住變數</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in scss */</span></span><br><span class="line"><span class="variable">$name</span> :primary;</span><br><span class="line"><span class="selector-class">.bg-</span>#&#123;<span class="variable">$name</span>&#125; &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in css */</span></span><br><span class="line"><span class="selector-class">.bg-primary</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="content-傳遞內容"><a href="#content-傳遞內容" class="headerlink" title="@content 傳遞內容"></a>@content 傳遞內容</h2><p><code>@content</code> 的功能在於傳遞內容到 <code>@mixin</code> 中</p><ul><li><p>用在 RWD 斷點設計中，為每個斷點傳遞不同的內容</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in Scss</span></span><br><span class="line"><span class="keyword">@mixin</span> mobile &#123;</span><br><span class="line">  <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)&#123;</span><br><span class="line">    <span class="keyword">@content</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="keyword">@mixin</span> mobile &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in css</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;<span class="attribute">width</span>: <span class="number">500px</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>)&#123;</span><br><span class="line">  <span class="selector-class">.header</span> &#123;<span class="attribute">width</span>: <span class="number">300px</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>用在狀態樣式的表示</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in scss</span></span><br><span class="line"><span class="comment">// 連結樣式</span></span><br><span class="line"><span class="keyword">@mixin</span> link &#123;</span><br><span class="line">  &amp;<span class="selector-pseudo">:link</span>, &amp;<span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被點擊後樣式</span></span><br><span class="line"><span class="keyword">@mixin</span> link-hover &#123;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span>, &amp;focus, &amp;<span class="selector-pseudo">:active</span>, &amp;<span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="keyword">@include</span> link &#123;<span class="attribute">color</span>:red&#125;;</span><br><span class="line">  <span class="keyword">@include</span> link-hover &#123;<span class="attribute">color</span>: blue&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in css</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;<span class="attribute">width</span>: <span class="number">50px</span>&#125;;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:link</span>, <span class="selector-class">.box</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: red&#125;;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>, <span class="selector-class">.box</span><span class="selector-pseudo">:focus</span>, <span class="selector-class">.box</span><span class="selector-pseudo">:active</span>, <span class="selector-class">.box</span><span class="selector-class">.active</span> &#123;<span class="attribute">color</span>: blue&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scss import</title>
      <link href="/scss/20190924/b8cb8afb/"/>
      <url>/scss/20190924/b8cb8afb/</url>
      
        <content type="html"><![CDATA[<p>透過 Sass 中的 <code>@import</code> 功能，可以將檔案拆分成許多支，最後再透過此功能彙整，以方便管理</p><span id="more"></span><h2 id="import-的用法"><a href="#import-的用法" class="headerlink" title="@import 的用法"></a>@import 的用法</h2><ul><li><p>使用 <code>@import</code> 可以將 “多支 Sass” 檔案彙整成 “一支 Sass” 檔案，再透過轉譯轉換成 CSS 檔案，因此載入時只要載一支 CSS 檔案即可</p></li><li><p>在 Sass 檔名前面加上下底線 <code>_</code>，此檔案就不會被編譯成 CSS 檔案，例如: <code>_reset.scss</code></p></li><li><p>將 CSS 拆分成多支 Sass 檔案，使 CSS 程式碼切分模組化，每支檔案的程式碼較少，使維護上更能精準的聚焦</p></li><li><p><a href="https://github.com/twbs/bootstrap/blob/master/scss/bootstrap.scss">Bootstrap</a> 就是用這種方式在管理眾多的 CSS 程式碼</p></li><li><p>如果我們要將變數檔案 <code>_variable.scss</code> 與首頁檔案 <code>index.scss</code> 載入到總檔案 <code>all.scss</code> 中，就可以透過以下方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in all.scss</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;variable&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;index&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>注意載入時不需要加最前面的下底線 <code>_</code> 和最後面的副檔名 <code>.scss</code>，並在每行結尾用分號 <code>;</code> 隔開</p></li><li><p>因為 Scss 檔案是 “由上而下” 讀取，所以會被其他檔案使用到的檔案要優先匯入，例如 <code>_variable.scss</code> 和 <code>_mixin.scss</code></p></li><li><p>通常都是將所有檔案匯入 <code>!import</code> 到一支名為 <code>all.scss</code> 的檔案管理，再將這支檔案編譯成瀏覽器可以讀取的 <code>all.css</code></p></li></ul><h2 id="CSS-reset"><a href="#CSS-reset" class="headerlink" title="CSS reset"></a>CSS reset</h2><ul><li><p>通常在寫網頁時，我們都會載入一支名為 _reset.scss 的檔案來淨空所有樣式</p></li><li><p>要完全靠自己完成 <code>_reset.scss</code>，會比較麻煩，所以通常都會載入網路上已寫好得程式碼，常見的有兩種，<code>meyerweb</code> 和 <code>Normalize</code></p><ul><li><a href="https://meyerweb.com/eric/tools/css/reset/">meyerweb</a> : 完全淨空所有樣式</li><li><a href="https://necolas.github.io/normalize.css/">Normalize</a> : 保留部分樣式，不會完全淨空所有樣式</li></ul></li><li><p>選擇性 : 如果是工程取向，建議使用 <code>meyerweb</code> 完全淨空，設計取向可以使用 <code>Normalize</code> 保留部分樣式，<code>Bootstrap</code> 即是使用 <code>Normalize</code>，在載入後仍然可以依照需求作修改</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scss 變數</title>
      <link href="/scss/20190924/4740e2f1/"/>
      <url>/scss/20190924/4740e2f1/</url>
      
        <content type="html"><![CDATA[<h2 id="為什麼需要變數"><a href="#為什麼需要變數" class="headerlink" title="為什麼需要變數 ?"></a>為什麼需要變數 ?</h2><p>變數可以設定全域樣式，如果我們要改變專案中所有連結的顏色，純 CSS 只能一一去做更改，但將所有連結顏色的值導入變數後，只需要改變變數的值所有連結顏色就會一起更改</p><span id="more"></span><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$link-color</span>: red;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="variable">$link-color</span>;&#125;</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="variable">$link-color</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="變數的格式"><a href="#變數的格式" class="headerlink" title="變數的格式"></a>變數的格式</h2><p>變數可以是任何 CSS 屬性的值，只要在最前面加上 <code>$</code>，接著再加上命名的名稱，最後以 <code>;</code> 結束</p><h3 id="數值"><a href="#數值" class="headerlink" title="數值"></a>數值</h3><p>可以包括單位和小數，其中單位可以是絕對單位 (px)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$z-index-l</span>: <span class="number">10</span>;</span><br><span class="line"><span class="variable">$font-size-base</span>: <span class="number">16px</span>;</span><br></pre></td></tr></table></figure><h3 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h3><p>可以用 雙引號 <code>&quot;&quot;</code>、單引號 <code>&#39;&#39;</code> 或沒有引號，是一個字串列時，可以用 <code>,</code> 或空白隔開</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-family</span>: <span class="string">&quot;Noto Sans TC&quot;</span>,sans-serif;</span><br><span class="line"><span class="variable">$brand-img</span>: <span class="string">&#x27;../img/brand.png&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="顏色"><a href="#顏色" class="headerlink" title="顏色"></a>顏色</h3><p>可以是各種代碼表現</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$white</span>: white;</span><br><span class="line"><span class="variable">$primary</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="variable">$secondary</span>: rgb(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, .<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="布林值"><a href="#布林值" class="headerlink" title="布林值"></a>布林值</h3><p><code>true</code>, <code>false</code></p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p><code>null</code></p><h2 id="變數的運算"><a href="#變數的運算" class="headerlink" title="變數的運算"></a>變數的運算</h2><p>Sass 支援基本的數學運算，加 <code>+</code>、減 <code>-</code>、乘 <code>*</code>、除 <code>/</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-size-base</span>: <span class="number">16px</span>;</span><br><span class="line"><span class="variable">$font-l</span>: <span class="variable">$font-size-base</span> * <span class="number">1.2</span>;</span><br><span class="line"><span class="variable">$font-s</span>: <span class="variable">$font-size-base</span> * <span class="number">0.8</span>;</span><br></pre></td></tr></table></figure><p>如果遇到除不盡的的小數會運算網頁解析度可以容許的範圍，雖然有很微小得留白，但肉眼幾乎無法察覺</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in .scss</span></span><br><span class="line"><span class="variable">$width</span>: <span class="number">960px</span>;</span><br><span class="line"><span class="selector-class">.menu</span> &#123;<span class="attribute">width</span>: <span class="variable">$width</span> / <span class="number">7</span>&#125;</span><br><span class="line">// in .css</span><br><span class="line">.menu &#123;width: <span class="number">137.14286px</span>;&#125;;</span><br></pre></td></tr></table></figure><h2 id="陣列-List"><a href="#陣列-List" class="headerlink" title="陣列 (List)"></a>陣列 (List)</h2><ul><li><p>陣列的英文是 <code>Array</code>，而 Sass 只有 <code>List</code>，但用法上相同</p></li><li><p>陣列是用來存放 “沒有鍵名的變數”，表示只能透過 “索引” (1,2,3,4)取值，而不是 “鍵名”(hover,active,…) ，而一般程式語言都從 <code>0</code> 開始，但 List 從 <code>1</code> 開始，透過 nth() 使用 List</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: red, blue, green;</span><br><span class="line"><span class="comment">// in scss</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: nth(<span class="variable">$color</span>, <span class="number">2</span>)&#125;</span><br><span class="line">// in css</span><br><span class="line">p &#123;color: blue&#125;</span><br></pre></td></tr></table></figure></li><li><p>當然也可以位索引導入變數</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color</span>: red, blue, green;</span><br><span class="line"><span class="comment">// in scss</span></span><br><span class="line"><span class="variable">$index</span>: <span class="number">2</span>;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: nth(<span class="variable">$color</span>, <span class="variable">$index</span>)&#125;</span><br><span class="line">// in css</span><br><span class="line">p &#123;color: blue&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="物件-Map"><a href="#物件-Map" class="headerlink" title="物件 (Map)"></a>物件 (Map)</h2><ul><li><p>陣列的英文是 <code>Object</code>，而在 Sass 中只有 <code>Map</code>，但用法相同</p></li><li><p><code>Map</code> 與 <code>List</code> 不同之處在於可以 “自訂鍵名”，也就是每個值的名稱</p></li><li><p>Map 使用小括號 <code>( )</code> 包住資料，內層使用逗號 <code>,</code> 隔開資料，每筆資料都有獨立的鍵名 <code>key</code> 與值 <code>value</code>，每個鍵名需用引號 <code>&quot;&quot;</code>、<code>&#39;&#39;</code> 包住</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$map</span>: (</span><br><span class="line">  <span class="string">&#x27;key1&#x27;</span>: value1,</span><br><span class="line">  <span class="string">&#x27;key2&#x27;</span>: value2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><code>使用 map-get(map, key)</code> 將值取出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in scss</span></span><br><span class="line"><span class="variable">$theme</span>: (</span><br><span class="line">  <span class="string">&#x27;primary&#x27;</span>: blue,</span><br><span class="line">    <span class="string">&#x27;secondary&#x27;</span>: red,</span><br><span class="line">)</span><br><span class="line">p &#123;color: map-get(<span class="variable">$theme</span>, primary)&#125;</span><br><span class="line"></span><br><span class="line">// in css</span><br><span class="line">p &#123;color: blue&#125;</span><br></pre></td></tr></table></figure></li><li><p>Map 指令</p><ul><li><p><code>map-get(map, key)</code> : 取出指定的值</p></li><li><p><code>map-merge(map1, map2)</code> : 合併 map</p></li><li><p><code>map-remove(map, key)</code> : 移除指定的值</p></li><li><p><code>map-keys(map)</code> : 列出 map 全部的 key</p></li><li><p><code>map-values(map)</code> : 列出 map 全部的 value</p></li><li><p><code>map-has-key(map, key)</code> : 確認 map 中是否有指定 key</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Scss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sass 簡介</title>
      <link href="/scss/20190924/ad533d91/"/>
      <url>/scss/20190924/ad533d91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sass 是一種指令碼解析成 CSS 的手稿語言，即 SassScript。Sass 檔案本身本身不被瀏覽器所讀取，需要透過 Sass 直譯器將 SassScript 轉成 CSS 語法的 CSS 檔案。同時，SassScript 直譯器會同時對 Sass 檔案進行監視，即時更新 CSS 檔案。</p><span id="more"></span><h2 id="Sass-有什麼好處"><a href="#Sass-有什麼好處" class="headerlink" title="Sass 有什麼好處 ?"></a>Sass 有什麼好處 ?</h2><ul><li>將 CSS 模組化，拆分成多支檔案，方便管理與維護</li><li>重複的前綴詞可以透過巢狀的寫法而不需要重複撰寫</li><li>導入變數、函式等程式語言的概念，相同的 CSS 可以集中管理</li><li>常用到的 CSS 技巧可以利用模組化的方式儲存成一個 “工具包”，每次要用到時再透過 Sass 語法呼叫即可，不需要每次再從過去的資料找解法</li><li>許多 CSS framework 也是透過 Sass 完成，學會 Sass 可以更靈活運用在專案上</li></ul><h2 id="Sass-與-Scss"><a href="#Sass-與-Scss" class="headerlink" title="Sass 與 Scss"></a>Sass 與 Scss</h2><p>Sass 有兩種寫法，分別透過 <code>.sass</code> 和 <code>.scss</code> 兩種副檔名作為區分<br>其中 Scss 是 Sass 3 引入的新語法，其語法完全兼容 CSS 語法，也就是原來的 CSS 可以直接寫進 Scss 檔案，在寫法上也與 CSS 較為接近，容易快速上手</p><h3 id="一般-CSS-寫法"><a href="#一般-CSS-寫法" class="headerlink" title="一般 CSS 寫法"></a>一般 CSS 寫法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;...&#125;</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">ul</span> &#123;...&#125;</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">li</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="SASS-寫法"><a href="#SASS-寫法" class="headerlink" title="SASS 寫法"></a>SASS 寫法</h3><p>完全省略 <code>&#123; &#125;</code> 與 <code>;</code> ，利用縮排(兩個空白或一個 Tab)來段行，格式非常簡潔，但縮排也容易看錯</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.menu </span><br><span class="line">  ...</span><br><span class="line">  ul ...</span><br><span class="line">  li ...</span><br></pre></td></tr></table></figure><h3 id="SCSS-寫法"><a href="#SCSS-寫法" class="headerlink" title="SCSS 寫法"></a>SCSS 寫法</h3><p>保留 SASS 運用巢狀的方式省略重複的前綴，也保留原 CSS 的 <code>&#123; &#125;</code> 與 <code>;</code>，從 CSS 轉換過來較為直觀，且兼容 CSS，因此也較受歡迎</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;...&#125;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="巢狀結構"><a href="#巢狀結構" class="headerlink" title="巢狀結構"></a>巢狀結構</h2><p>從以上兩種寫法可以發現到 <code>.menu</code> 內層的 <code>ul</code> 和 <code>li</code> 都已經省略前面的 <code>.menu</code>，不僅可以避免重複撰寫相同的前綴，如果要更改 <code>.menu</code> 的名稱，就只需要改一個地方，也清楚的表示彼此的關係</p><h2 id="amp-連接符號"><a href="#amp-連接符號" class="headerlink" title="&amp; 連接符號"></a>&amp; 連接符號</h2><p>使用 &amp; 連接符號會自動連接上層元素，不需要重複撰寫</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in scss</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;...&#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">::before</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;...&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;...&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">::before</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="Sass-編譯方式"><a href="#Sass-編譯方式" class="headerlink" title="Sass 編譯方式"></a>Sass 編譯方式</h2><p>Sass 檔案無法被瀏覽器解讀，需要編譯成 CSS 檔案，而編譯方式一共有三種，在此先介紹兩種</p><h3 id="軟體編譯-prepros"><a href="#軟體編譯-prepros" class="headerlink" title="軟體編譯 : prepros"></a>軟體編譯 : prepros</h3><p><a href="https://prepros.io/">prepros 官方網站</a></p><ol><li>從網站下載完後，開啟 prepros，將整個跟目錄資料夾拖曳到 prepros 內，也可以藉由左下角的 <code>+</code> 將檔案拉到 prepros 內</li></ol><p>  <img src="prepros-1.png"></p><ol start="2"><li>拖曳到 prepros 後會自動產生一個名為 <code>prepros-6.config</code> 設定檔，就可以開始新增 <code>scss</code> 資料夾，並在裡面建立 <code>.scss</code> 檔案</li></ol><p>  <img src="prepros-2.png"></p><ol start="3"><li>所有在裡面的檔案都會出現在 prepros 的 <code>Files</code> 欄位</li></ol><p>  <img src="prepros-3.png"></p><ol start="4"><li>在檔案內撰寫存檔後，prepros 就會自動在根目錄幫你建立相對的 <code>css</code> 資料夾，同時在裡面也建立相對的 <code>.css</code> 檔案</li></ol><p>  <img src="prepros-4.png"></p><ol start="5"><li>所有編輯的紀錄都會出現在 prepros 的 <code>log</code> 欄位，如果編輯失敗也會列出錯誤的位置</li></ol><p>  <img src="prepros-5.png"></p><h3 id="編輯器內建插件-VS-Code-內建的-Live-Sass-Compiler"><a href="#編輯器內建插件-VS-Code-內建的-Live-Sass-Compiler" class="headerlink" title="編輯器內建插件 :　VS Code 內建的 Live Sass Compiler"></a>編輯器內建插件 :　VS Code 內建的 Live Sass Compiler</h3><ol><li>如果是 <code>VS Code</code> 的使用者，可以下載名為 <code>Live Sass Compiler</code> 的插件</li></ol><p>  <img src="live-sass-1.png"></p><ol start="2"><li>下載後，開啟檔案下方會出現 <code>Watch Sass</code> 按鈕，按下後就會開始監聽 <code>sass</code> 檔案，並建立相對的 <code>css</code> 檔案，且及時更新</li></ol><p>  <img src="live-sass-2.png"></p><ol start="3"><li>如果 Sass 檔案編譯出現錯誤，會在下方的 輸出 欄位顯示 <code>Error</code>，並列出錯誤的位置</li></ol><p>  <img src="live-sass-3.png"></p><ol start="4"><li>如果想要改變 css 檔案的路徑，可以在設定中 <code>setting.json</code>，新增以下程式碼</li></ol>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;liveSassCompile.settings.formats&quot;:[</span><br><span class="line">  <span class="comment">// 預設為在 css 資料夾中產生相對的 .css 檔案</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;expanded&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;extensionName&quot;</span>: <span class="string">&quot;.css&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;savePath&quot;</span>: <span class="string">&quot;/css&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成壓縮檔</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;format&quot;</span>: <span class="string">&quot;compressed&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;extensionName&quot;</span>: <span class="string">&quot;.min.css&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;savePath&quot;</span>: <span class="string">&quot;/css&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="前端任務打包工具-gulp、webpack-需用到-JavaScirpt，在此先不介紹"><a href="#前端任務打包工具-gulp、webpack-需用到-JavaScirpt，在此先不介紹" class="headerlink" title="前端任務打包工具 : gulp、webpack (需用到 JavaScirpt，在此先不介紹)"></a>前端任務打包工具 : gulp、webpack (需用到 JavaScirpt，在此先不介紹)</h3>]]></content>
      
      
      <categories>
          
          <category> Scss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scss </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
